openapi: 3.1.0
info:
  version: '1.8.1'
  title: Nutrient Document Engine API
  description: |-
    Nutrient Document Engine provides an HTTP-based API for integrating with your existing backend.

    - Add documents by either uploading them or specifying URLs where the
      documents can be fetched from.
    - Efficiently copy a previously added document, usually with the
      intention to share it with a different set of users.
    - Delete documents.
    - Fetch, create, update, and delete annotations in a particular document.
    - Add, rotate, remove pages and merge other PDF files into existing documents.

    # Authorization

    Requests to this API are protected with a secret token configurable via the
    `API_AUTH_TOKEN` variable. The token needs to be included in the `Authorization`
    header of each request:

    ```
    Authorization: Token token="<API_AUTH_TOKEN>"
    ```

    Because this API allows full access to all data stored on Nutrient Document Engine, it is
    only meant to be used by your backend services, which we assume are fully
    trusted. For example, when connecting Nutrient iOS SDK to Nutrient Document Engine,
    you must create document-scoped JSON Web Tokens (JWTs) that can be handed
    out to users.

    ## JWT-Based Authorization

    Apart from the API token, you can also use JWTs to authorize requests to the
    Nutrient Document Engine API. This is useful when you want to delegate the authorization
    to your backend services. Refer to the [JWT authorization](#tag/JWT-authorization) section for more information.

    # API Versioning

    Nutrient Document Engine's API is versioned based on the semantic version of the Document Engine release in a form `major.minor.patch` (e.g. 1.3.2)

    Patch version updates are shipped without any breaking changes. In other words, all changes to the API behavior are either bugfixes or
    simple additions of optional parameters that don't require migration on client's side.

    Minor and major version updates can introduce breaking changes and might generally require migration. Refer to the appropriate
    [migration guide](https://www.nutrient.io/guides/document-engine/upgrade/) for more information.

    Most larger changes that would be otherwise breaking are introduced in 2 stages:

    1. Introduce the new API with breaking changes while deprecating the old API, but keeping it functional still.
    2. Deprecated APIs are removed in one of the future minor or major releases.
  contact:
    name: Nutrient
    url: https://www.nutrient.io
  license:
    name: License Agreement
    url: https://www.nutrient.io/legal/Nutrient_SDK_User_Evaluation_Subscription_Agreement
security:
  - ApiAuthToken: []
tags:
  - name: Documents
    description: Manage documents.
  - name: Import and Export
    description: Import and export information from documents.
  - name: Document Editing
    description: Process documents.
  - name: Annotations
    description: Create, read, update, and delete annotations.
  - name: Form Filling
    description: Fill in the form fields and retrieve their values.
  - name: Forms
    description: |-
      Create, read, update and delete form fields and widget anotations.

      A widget annotation describes the physical appearance of a form field in a PDF document, i.e. properties that are used to display the form field on a specific page in the PDF. For this reason, you need to create and associate widgets with the form fields you process using Nutrient Document Engine’s API.

      For example, along with specifying the details of your text form field, you need to specify a widget annotation for that text form field by setting the widget’s ID in the text field’s `content.annotationIds` property.
  - name: Digital Signatures
    description: |-
      Nutrient Document Engine supports reading and applying digital signatures to PDF documents.

      A digital signature is an electronic fingerprint uniquely identifying the signing person. A digital signature on a PDF document is both reliable proof of the document’s origin and protection against modification by third parties.
  - name: Comments
    description: |-
      Each comment is attached to a root annotation. Comments under the same root annotation form a single comment thread. The root annotation serves as an anchor for comments, marking their position in a document. Currently, only comment marker annotations and markup annotations can be used as root annotations.

      ### Working with Root Annotations

      Root annotations are regular annotations stored on Nutrient Document Engine. They can be fetched, created, updated, and deleted using our server-to-server annotation APIs. However, there are a couple rules that apply only to root annotations:

      - When they’re deleted, all comments attached to them are deleted as well.
      - When the last comment under the root annotation is deleted, the annotation itself is removed.

      ### Comment Markers

      `pspdfkit/comment-marker` is an annotation type used for marking a comment thread’s position in the document. It can be manipulated using the annotation APIs, just like any other annotation can. However, it’s only available if the Instant Comments component is enabled in the license.
  - name: Redaction
    description: |-
      Redaction is the process of removing content from a PDF page. This not only involves obscuring the content, but also removing the data in the document within the specified region.

      Redaction is a two-step process:

      - First, redaction annotations are added to the layer, marking the content that should be removed.
      - Later, the redactions are applied to the layer, modifying the underlying PDF file and removing the redaction annotations permanently.

      Just like any other annotation type, redaction annotations are automatically synchronized by our Instant engine, which facilitates effortless collaboration between users viewing the same layer. In addition, Nutrient Document Engine provides a set of APIs that allow users to automate the process of creating redactions and applying them.

      Note that redaction is a separate component that requires a specific license. Without it, you won’t be able to import, create, or apply redactions to documents.

      ### Working with Redaction Annotations

      Redaction annotations are regular annotations, which means they can be retrieved, created, updated, and deleted with the annotation APIs.
  - name: Bookmarks
    description: Create, read, update, and delete bookmarks.
  - name: Attachments
    description: Retrieve document attachments.
  - name: Embedded files
    description: Retrieve embedded files.
  - name: Layers
    description: |-
      Instant Layers are a capability of Nutrient Document Engine that allows you to manage multiple versions of a document while uploading it only once.

      When uploading a document, the content of the document (that is, all annotations and values entered into form fields) is extracted into an immutable base layer. When synchronizing changes via Nutrient Instant or by using the API, you can now specify the layer name by setting the `"layer"` claim in the JSON Web Token (JWT) or by using our layer endpoints. A layer mirrors the original content of a document (i.e. the content of the base layer) until the first change is made to its content. This means that layers don’t have to be manually created, but rather are created for you as soon you make the first changes, at which point the base layer’s content is copied into the layer and your changes are applied.

      If you need only one version of a document or don’t want to use layers, you can just omit the `"layer"` claim and use the annotation endpoints. In this case, all changes are persisted to the default layer with an empty name.

      Layer names are not allowed to contain the `*` character, and their maximum allowed length is 256 characters.
  - name: PDF/A Validation
    description: Validate the conformance of a PDF/A file.
  - name: Maintenance
    description: Perform general maintenance tasks.
  - name: Secrets
    description: |-
      Nutrient Document Engine offers the following options for authentication:

      - Dashboard password — Used to access the Dashboard.
      - Secret keybase — Used for generating secret keys for the purposes of authentication.
      - Public key for authenticating JWT payloads — Used for client authentication.

      Collectively, these options are referred to as secrets.

      ### Managing Secrets via Environment Variables

      Secrets can be configured via environmental variables. By default, current secrets are sourced from the following environmental variables:

      - `JWT_PUBLIC_KEY`
      - `SECRET_KEY_BASE`
      - `DASHBOARD_PASSWORD`

      However, this approach has the following disadvantages:

      - You can't change secrets during runtime.
      - You can't use more than one valid secret.
      - You needed to restart Nutrient Document Engine.

      ### Managing Secrets via API

      PSPDFKit Server 2023.1.0 introduced a new mechanism for managing secrets. There’s always a “current” version of a secret that never expires. You can only change this current version using secret rotation. Next to the current version, you can have other secrets, but the non-current secrets need to have an expiration date.

      To change this behavior, set `REPLACE_SECRETS_FROM_ENV` to `false`. In this case, current secrets are only sourced from environmental variables if the secrets aren’t yet set via the API. `REPLACE_SECRETS_FROM_ENV` must be set to `false` to enable secret rotation. Otherwise, secrets set via the API are replaced on every restart.
  - name: Configuration
    description: |-
      Configuration options for the Document Engine are exposed via environment variables for the `document-engine` container.

      Setting of these options is also supported through
      [Helm values](https://github.com/PSPDFKit/helm-charts/blob/master/charts/document-engine/values.yaml).

      ## General

      - `PORT` — This option determines the port where Document Engine listens for traffic.

      - `ALLOW_DOCUMENT_UPLOADS` — Allow or prevent uploading documents to Document Engine. Supported values are `true` and `false`. The default value for this option is `true`.

      - `ALLOW_REMOTE_DOCUMENTS` — Allow or prevent adding documents from URLs to Document Engine. Supported values are `true` and `false`. The default value for this option is `true`.

      - `ALLOW_DOCUMENT_GENERATION` — Allow or prevent creating documents with PDF Generation. The default value for this option is `true`.

      - `ALLOW_REMOTE_ASSETS_IN_GENERATION` — Allow or prevent loading the resources from the network during PDF generation. If set to `false`, any images, stylesheets, and other assets won’t be loaded from external URLs. The default value for this option is `true`.

      - `AUTOMATIC_LINK_EXTRACTION` — Automatically extract link annotations from text. The default value for this option is `false`.

      - `IGNORE_INVALID_ANNOTATIONS` — If set to `true`, Document Engine will ignore invalid annotations on PDF export instead of throwing an error. Invalid annotations will still be logged. If set to `false`, PDF export for PDFs containing invalid annotations will throw and log an error. Supported values are `true` and `false`. The default value for this option is `true`.

      - `MIN_SEARCH_QUERY_LENGTH` — This option defines the minimum amount of characters required to start a search on a document. By default, the minimum length is three characters.

      ## Trust and Secrets

      - `ACTIVATION_KEY` — online license activation key or offline license key. See more in our [product activation](https://www.nutrient.io/guides/document-engine/deployment/product-activation/) guide.

      - `API_AUTH_TOKEN` — A string used for authenticating with the Document Engine Server API. Choose a sufficiently long random string for this option to prevent unauthorized access to the API.

      - `SECRET_KEY_BASE` — A string used as the base key for deriving secret keys for the purposes of authentication. Choose a sufficiently long random string for this option. To generate a random string, use `openssl rand -hex 256`.

      - `JWT_PUBLIC_KEY` — This is the public key used to verify the JSON Web Token (JWT) payload signature. Ensure that this public key corresponds to the private key used to generate JWTs in your app. For more information, see the [authentication](https://www.nutrient.io/guides/document-engine/viewer/client-authentication/generate-a-jwt/) guide.

      - `JWT_ALGORITHM` — The algorithm used for JSON Web Token (JWT) verification. This should be the same as the one you’ll use for signing JWTs in your app. Supported algorithms: RS256, RS512, ES256, ES512. See [RFC 7518](https://www.ietf.org/rfc/rfc7518.html#section-3) for details about specific algorithms.

      - `DASHBOARD_USERNAME`, `DASHBOARD_PASSWORD` — The username and password to access the [dashboard](https://www.nutrient.io/guides/document-engine/management/dashboard/). To disable the dashboard, leave these unset.

      - `REPLACE_SECRETS_FROM_ENV` — take `JWT_PUBLIC_KEY`, `SECRET_KEY_BASE` and `DASHBOARD_PASSWORD` values from environment variables. The default value is `true`. The alternative approach is setting the secrets [through the API](https://www.nutrient.io/guides/document-engine/management/secrets-rotation/).

      - `TRUSTED_PROXIES` — A comma-separated list of IP addresses or IP address ranges of trusted proxies in front of the Document Engine. Setting this to `default` will use [private IP address ranges](https://en.wikipedia.org/wiki/Private_network).

         When set, the Document Engine will examine some of the request headers to determine the IP address of the actual client, even if the Document Engine is behind one or more proxies.

         Leaving this empty or omitting the setting completely will make the Document Engine use the IP address of the immediate connection that sent a request.

      - `DOWNLOADER_CERT_FILE_PATH` — This option allows you to configure a certificate that’s used to verify the TLS certificate of the server when downloading a remote document. Defaults to the [Mozilla included CAs](https://wiki.mozilla.org/CA) saved as `/certificate-stores-downloader/root-certificates.pem` within the Document Engine container. Refer to our [certificate trust configuration guide](https://www.nutrient.io/guides/document-engine/configuration/certificate-trust/) for more details.

      ## Limits and timeouts

      - `MAX_UPLOAD_SIZE_BYTES` — The maximum allowed size of uploaded documents, in bytes. If set, it applies to all upload types, including remote documents. If unset, the default limit of `1000000000` (one billion) bytes (or around 950&nbsp;MB) applies to multipart and remote uploads.

      - `ASSET_STORAGE_CACHE_SIZE` — This option determines the size of the [document cache](https://www.nutrient.io/guides/document-engine/configuration/cache/) in the local storage. The size is specified in bytes, and it defaults to `2000000000` (=2&nbsp;GB).

      - `PSPDFKIT_WORKER_POOL_SIZE` — This option controls how many `pspdfkitd` processes are started for handling PDF-related work. In general, setting this to two-to-three times the number of cores available will give you the best performance. Keep in mind that if you set this too high, the processes will starve each other for CPU time, leading to unnecessarily long processing times. And if you set this too low, available CPU time won’t be used efficiently, as tasks will have to wait for a long time for a worker to be available. This defaults to `16`.

      - `DATABASE_CONNECTIONS` — This option defines the database connection pool size. The default value for this option is `20`.

      - `PDF_GENERATION_TIMEOUT` — The timeout in milliseconds applied when creating documents with PDF Generation. Any generation taking longer than the configured timeout will fail. Defaults to `20000` (20 seconds).

      - `PSPDFKIT_WORKER_TIMEOUT` — The timeout in milliseconds for the `pspdfkitd` process to handle any PDF-related work. By default, it’s set to `60000` (60 seconds).

      - `REMOTE_URL_FETCH_TIMEOUT` — This option defines the maximum timeout period used, in milliseconds, when waiting for a remote PDF to download. It can be increased if Document Engine needs to handle large files. It defaults to `5000` (5 seconds).

      - `READ_ANNOTATION_BATCH_TIMEOUT` — The timeout in milliseconds applied when reading an annotations batch from a PDF document. Defaults to `20000` (20 seconds).

      - `SERVER_REQUEST_TIMEOUT` — The timeout in milliseconds applied to each request sent to the Document Engine HTTP API. Note that this timeout takes precedence over any other timeout related to the request being processed. Defaults to `60000` (1 minute).

      - `ASYNC_JOBS_TTL` - The amount of time in seconds after which async jobs should expire. The default is 2 days - `172800` seconds. Expired jobs and their output assets will be deleted from the system.

      - `FILE_UPLOAD_TIMEOUT_MS` - Timeout in milliseconds for file uploads to s3. The default is `30000` milliseconds (30 seconds)

      ## Digital Signature Options

      - `SIGNING_SERVICE_URL` — This option only affects a Document Engine instance with support for Digital Signatures. It defines the URL used by Document Engine when contacting the external signing service required to apply a digital signature to a document.

      - `SIGNING_SERVICE_TIMEOUT` — This determines how long Document Engine waits for the response from the signing service when signing a document, in milliseconds. The default is `5000`.

      - `DIGITAL_SIGNATURE_CADES_LEVEL` — This option is relevant when using a Document Engine instance with support for digital signatures. It defines the PAdES/CAdES level to be used when signing a document. The values allowed are `b-b` and `b-t`, which correspond to the PAdES signature levels. The default value is `b-t`.

      - `TIMESTAMP_AUTHORITY_URL` — This option is relevant for PAdES/CAdES signatures with level `b-t` or above. It defines the URL of the timestamp authority to be used when signing a document. By default, Document Engine uses `https://freetsa.org/` as the timestamping authority.

      - `TIMESTAMP_AUTHORITY_USERNAME` and `TIMESTAMP_AUTHORITY_PASSWORD` — The optional username and password required to connect to the timestamping authority.

      - `DEFAULT_SIGNER_NAME`, `DEFAULT_SIGNATURE_REASON`, and `DEFAULT_SIGNATURE_LOCATION` — These options only affect a Document Engine instance with support for Digital Signatures. When signing a document, they’re used to prepare the signature metadata.

      - `DIGITAL_SIGNATURE_HASH_ALGORITHM` — This option only affects a Document Engine instance with support for Digital Signatures. If you require a hash algorithm that’s different than the default `sha256`, you can choose between any of these allowed values: `md5`, `sha160`, `sha224`, `sha256`, `sha384`, or `sha512`. We recommend using `sha256` or higher.

      - `DIGITAL_SIGNATURE_CERTIFICATE_CHECK_TIME` — This option only affects a Document Engine instance with support for Digital Signatures. If set to `current_time` (default), the signing certificate’s validity is validated against the current time. If set to `signing_time`, the signing time (i.e. signature creation time) is used instead. By default, the `current_time` is used. This means that valid signatures with expired certificates validate as expired.

      ### Trusted Root Certificates for Digital Signatures

      Document Engine will search for certificate stores at the `/certificate-stores` path inside its container. Refer to our [certificate trust configuration guide](https://www.nutrient.io/guides/document-engine/configuration/certificate-trust/) for more details.

      ## Database Options

      - `PGUSER`, `PGPASSWORD`, `PGDATABASE`, `PGHOST`, `PGPORT` — These options determine how the `pspdfkit` service will communicate with the `db` service. Don’t forget to replace the default password with a custom one, using the same value for both `PGPASSWORD` and `POSTGRES_PASSWORD`.

      - `PGSSL` — A Boolean string that can be used to enable connection to a PostgreSQL instance that supports encrypted SSL connections.
         By default, the certificates installed in the container are used to verify the server certificate.
         If you need to use a custom CA certificate, you can set `PGSSL` to `"true"` and provide the path to the CA certificate file using the `PGSSL_CA_CERT_PATH` or `PGSSL_CA_CERTS` options. Defaults to `"false"`.

      - `PGSSL_CA_CERT_PATH` — Optional path to the CA certificate file used to verify the server certificate. Mutually exclusive with `PGSSL_CA_CERTS`.

      - `PGSSL_CA_CERTS` — Optional, CA certificate used to verify the server certificate. Mutually exclusive with `PGSSL_CA_CERT_PATH`.

      - `PGSSL_CERT_COMMON_NAME` — Common name of the server certificate. Defaults to the value of `PGHOST`.

      - `PGSSL_DISABLE_HOSTNAME_VERIFY` — A Boolean string that can be used to disable verification of the server certificate's hostname. Defaults to `"false"`.

      - `PGSSL_DISABLE_VERIFY` — A Boolean string that can be used to disable verification of the server certificate. Defaults to `"false"`.

      - `ENABLE_DATABASE_MIGRATIONS` — This option determines whether to check for pending migrations on the database and attempts to run migrations if necessary. The default is `true`.

      - `EXIT_AFTER_DATABASE_MIGRATIONS` — This option determines whether to exit after running any pending migrations. This could be useful for running dedicated migration jobs on infrastructure. The default is `false`.

      - `PG_ADMIN_USER` — If set, overrides `PGUSER`. If Document Engine operates with limited database permissions (`ENABLE_DATABASE_MIGRATIONS` is set to `false`), this option can be used to provide administrative database credentials for separately executed migration jobs (with both `ENABLE_DATABASE_MIGRATIONS` and `EXIT_AFTER_DATABASE_MIGRATIONS` set to `true`).

      - `PG_ADMIN_PASSWORD` — If set, overrides the `PGPASSWORD` variable, which is a counterpart to `PG_ADMIN_USER`.

      - `PG_OPERATION_USER` — This option sets the name of the database user name to be granted operational permissions over the Document Engine database after migration. Defaults to the `PGUSER` value.

      ## Asset Storage Options

      - `ASSET_STORAGE_BACKEND` — How Document Engine stores uploaded PDFs and attachments. Supported backends are `built-in` and `s3`. The default value for this option is `built-in`.

      - `ENABLE_ASSET_STORAGE_FALLBACK` — Determines whether Document Engine will attempt to fetch PDFs and attachments from the secondary backend if they’re not available in the currently configured backend. The default value for this option is `false`. It’s recommended to set this value to `true` during asset storage backend migration.

      - `ENABLE_ASSET_STORAGE_FALLBACK_POSTGRES` - Enable the built-in database storage backend as a fallback. Default is `false`. Requires `ENABLE_ASSET_STORAGE_FALLBACK` to be `true`.

      - `ENABLE_ASSET_STORAGE_FALLBACK_S3` - Enable S3 storage backend as a fallback. Default is `false`. Requires `ENABLE_ASSET_STORAGE_FALLBACK` to be `true`.

      - `ENABLE_ASSET_STORAGE_FALLBACK_AZURE` - Enable Azure Blob Storage backend as a fallback. Default is `false`. Requires `ENABLE_ASSET_STORAGE_FALLBACK` to be `true`.

      - `MULTITENANT_ASSETS` - When set to `true`, Document Engine will ensure that each document is associated with a separate copy of all its assets and is not sharing an asset file with any other document. "Assets" in this case includes PDF Files, image attachments and other types of PDF attachments.

         This is `false` by default.

         With this option set to `true`, it is possible for one document to have an image attachment stored in one S3 bucket, while another document using the exact same image attachment, could have a copy of that attachment stored in a different S3 bucket.

      - `USE_UNSAFE_DELETE_FOR_ASSETS` - This is set to `false` by default. When set to `true`, Document Engine will not attempt to use a trash directory to safely delete assets from the configured asset storage.
         **IMPORTANT**, *this means that assets cannot be restored should an error happen during the deletion transaction*.

      ### S3-Compatible Object Storage

      - `ASSET_STORAGE_S3_BUCKET` — S3 bucket name in case `ASSET_STORAGE_BACKEND` is set to `s3`.

      - `ASSET_STORAGE_S3_REGION` — S3 bucket region.

      - `ASSET_STORAGE_S3_ACCESS_KEY_ID` and `ASSET_STORAGE_S3_SECRET_ACCESS_KEY` — optional AWS credentials. If they are not provided, different platform access options are attempted. Currently supported: AWS EC2 instance roles, AWS ECS task roles, AWS EKS instance roles for service accounts.

      - `ASSET_STORAGE_S3_HOST` — Optional custom endpoint for S3-compatible object storage.

      - `ASSET_STORAGE_S3_PORT` — Optional custom port for S3-compatible object storage.

      - `ASSET_STORAGE_S3_SCHEME` — URL scheme used for accessing the S3-compatible object storage, either `http://` or `https://`. The default is `https://`.

      ### Azure Blob Storage

      - `AZURE_STORAGE_ACCOUNT_NAME`, `AZURE_STORAGE_ACCOUNT_KEY` — Credentials for Azure Blob Storage in case `ASSET_STORAGE_BACKEND` is set to `azure`.

      - `AZURE_STORAGE_ACCOUNT_CONNECTION_STRING` — Azure Blob Storage connection string, an alternative to `AZURE_STORAGE_ACCOUNT_NAME` and `AZURE_STORAGE_ACCOUNT_KEY`.

      - `AZURE_STORAGE_DEFAULT_CONTAINER` - container name.

      ## Rendering Cache Options

      - `USE_REDIS_CACHE` — If set to `true`, Document Engine will use Redis as an additional image cache. Supported values are `true` and `false`. The default value for this option is `true`.

      - `REDIS_HOST`, `REDIS_PORT`, `REDIS_DATABASE`, `REDIS_USERNAME`, `REDIS_PASSWORD` — Only relevant if `USE_REDIS_CACHE` is set to `true`. These options determine how Document Engine will communicate with Redis.

      - `REDIS_SENTINELS` — Only relevant if `USE_REDIS_CACHE` is set to `true`. This option replaces `REDIS_HOST` and `REDIS_PORT`. Instead, you can supply a comma-separated list of Redis URIs specifying the sentinels Document Engine connects to.

         Example Value: `"redis://sentinel1:26379;redis://sentinel2:26379;redis://sentinel3:26379"`

      - `REDIS_SENTINELS_GROUP` — Needs to be provided if `REDIS_SENTINELS` is set. This is the name of your Redis sentinel master group, which is passed as a first argument to `sentinel monitor` in the Sentinel configuration file. You can read more about configuration in the [documentation](https://redis.io/topics/sentinel#configuring-sentinel).

      - `REDIS_SSL` — If set to `true`, enables an encrypted SSL connection to Redis.

      - `REDIS_TTL` — Time to live in milliseconds for Redis cache keys. By default, this is set to `86400000` milliseconds, which means that Redis cache keys expire after 24 hours if this value isn’t set.

      - `USE_REDIS_TTL_FOR_PRERENDERING` — If this is set to `true`, the value configured for `REDIS_TTL` is applied to Redis cache entries that Document Engine generates while prerendering a document in response to `POST /api/documents/:document_id/prerender` requests. If this is set to `false`, the cache keys generated during prerendering exist in the Redis data store until they’re evicted using the eviction policy configured for the Redis data store or until you upgrade your instance of Document Engine to a newer version. This option is set to `true` by default.

      ## Logging and Monitoring Options

      - `LOG_LEVEL` — This option defines a minimum log level. The allowed values, from higher to lower, are `debug`, `info`, `notice`, `warning`, `error`, `critical`, `alert` and `emergency`. The application will emit logs from the chosen level and all lower ones, so if the value is set to `error`, it will log `error`, `critical`, `alert` and `emergency`. This defaults to `info`.

      - `HEALTHCHECK_LOGLEVEL` — This option defines the log level for the healthcheck endpoint. The allowed values are same as for `LOG_LEVEL`, with an additional `none`. This includes root path (`/`) as well. This defaults to `debug`.

      - `STATSD_HOST` and `STATSD_PORT` — The host and port of a running StatsD-compatible daemon that Document Engine can report telemetry data to.

      - `STATSD_CUSTOM_TAGS` — A comma-separated list of `key=value` pairs attached as tags to every metric published by Document Engine, e.g. `region=eu-1,env=prod`.

      - `ENABLE_OPENTELEMETRY` — Enable OpenTelemetry tracing. Enabling requires also specifying `OTEL_EXPORTER_OTLP_ENDPOINT` and, optionally, `OTEL_EXPORTER_OTLP_PROTOCOL` (defaults to `grpc`).

      - `OTEL_EXPORTER_OTLP_PROTOCOL` (default: `grpc`), `OTEL_EXPORTER_OTLP_ENDPOINT` (default: `http://localhost:4317`), `OTEL_RESOURCE_ATTRIBUTES`, `OTEL_SERVICE_NAME` (default: `document-engine`), `OTEL_TRACES_SAMPLER` (default: customised `parent_based` that skips healthchecks and requests to `/`), `OTEL_PROPAGATORS` (default: `baggage,tracecontext`), etc — OpenTelemetry standard parameters.

      ## Conversion Options

      - `SPREADSHEET_MAX_CONTENT_HEIGHT_MM` - Specify the maximum content height for a spreadsheet (unit in millimeter). Default set to `0` for unlimited. Use this to control memory usage within the Document Engine container during Spreadsheet conversions.

      - `SPREADSHEET_MAX_CONTENT_WIDTH_MM` - Specify the maximum content width for a spreadsheet (unit in millimeter). Default set to `0` for unlimited. Use this to control memory usage within the Document Engine container during Spreadhseet conversions.

      ## HTTP proxies

      - `HTTP_PROXY` or `HTTPS_PROXY` — A URL of a proxy server used for Document Engine’s HTTP client. Used by default, if set, when fetching remote documents; fetching or uploading assets; contacting the CDN Server; contacting Nutrient’s licensing service; and interacting with the signing service, OSCP, and time stamping authorities. This is not set by default. If not set, there will be no fallback for any of the other `HTTP(S)_PROXY_*` configurations. 

      - `HTTP_PROXY_ASSET_DOWNLOAD` or `HTTPS_PROXY_ASSET_DOWNLOAD` - Use this to override the default `HTTP_PROXY` / `HTTPS_PROXY` configuration when downloading assets from configured [asset storage backends][asset storage configuration] - S3 or Azure. If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.

      - `HTTP_PROXY_REMOTE_FILE_DOWNLOAD` or `HTTPS_PROXY_REMOTE_FILE_DOWNLOAD` - Use this to override the default `HTTP_PROXY` / `HTTPS_PROXY` configuration when [downloading files from the provided URLs during document upload][adding documents from urls]. If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.

      - `HTTP_PROXY_WEB_CDN` or `HTTPS_PROXY_WEB_CDN` - Use this to override the default `HTTP_PROXY` / `HTTPS_PROXY` configuration when Document Engine is retrieving the [Web SDK][web sdk] from the CDN at [https://cdn.cloud.pspdfkit.com][web sdk cdn].  If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.

      - `HTTP_PROXY_SIGNING_SERVICE` or `HTTPS_PROXY_SIGNING_SERVICE` - Use this to override the default `HTTP_PROXY` / `HTTPS_PROXY` configuration when Document Engine is making requests to the [URL of Signing Service][signing service]. If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.

      - `HTTP_PROXY_LICENSING_SERVICE` or `HTTPS_PROXY_LICENSING_SERVICE` - Use this to override the default `HTTP_PROXY` / `HTTPS_PROXY` configuration when Document Engine is making requests to the Customer Licensing Portal.  If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.If this is not set, Document Engine will fallback to using `HTTP_PROXY` / `HTTPS_PROXY`.

      ## Mounting Custom Fonts

      Document Engine uses `/custom-fonts` directory for additional fonts.
  - name: JWT authorization
    description: |-
      JWT authorization is a method of controlling access to resources through the use of JSON Web Tokens (JWTs). A [JWT](https://datatracker.ietf.org/doc/html/rfc7519) “is a compact, URL-safe means of representing claims to be transferred between two parties.”

      To use JWT authorization, you need a pair of keys: a public key and a private key. The public key is used to verify the JWT, while the private key is used to sign the JWT. The public key needs to be configured in Document Engine to verify the JWT. You can configure the public key in Document Engine by setting the `JWT_PUBLIC_KEY` environment variable. The key is expected to be in PEM format. Note that the appropriate algorithm should be also configured in the `JWT_ALGORITHM` environment variable. The supported algorithms are `RS256`, `RS512`, `ES256`, and `ES512`.

      ## Payload

      The JWT payload should contain the following fields:
      - `exp` (Expiration Time) — The expiration time of the JWT. This field is required.
      - `nbf` (Not Before) — The time before which the JWT must not be accepted for processing. This field is optional.
      - `allowed_operations` (Allowed Operations) — A list of operations the user is allowed to perform. This field is optional.
        If not specified, the user is allowed to perform all operations. The supported operations are:
        `annotations`, `comments`, `compression`, `content_editing`, `data_extraction`, `digital_signatures`,
        `document_editor`, `electronic_signatures`, `forms`, `forms_creator`, `html_conversion`, `image_conversion`,
        `image_rendering`, `email_conversion`, `linearization`, `ocr`, `office_conversion`, `office_templating`,
        `pdf_to_office_conversion`, `pdfa`, `redaction`.
      - `allowed_origins` (Allowed Origins) — A list of origins the user is allowed to access. This field is optional.
        If not specified, the user is allowed to access all origins. This also accepts a regular expression.
      - `allowed_document_ids` (Allowed Document Ids) — A list of document identifiers the user is allowed to access. If not specified, the user is not allowed to access any documents. Access to all documents can be provided by setting it to `any`.
      - `server_url` - Base URL of the Document Engine the JWT is valid for. This is a hint for the clients. Optional, if not provided clients need to configure the correct URL.

      ## Example Payload

      ```json
      {
        "exp": 1112470620,
        "nbf": 1112470620,
        "allowed_operations": ["document_editor", "pdfa"],
        "allowed_origins": ["example.com", ".*\.example-with-subdomains\.com"],
        "allowed_document_ids": "any"
      }
      ```

      ## Request Headers

      The JWT should be included in the `Authorization` header of the request. The value of the header should be in the `Bearer <JWT>` format. For example:

      ```http
      POST /api/build HTTP/1.1
      HOST: document-engine.example.com
      Authorization: Bearer eFHmdpEFSD (...)

      (...)
      ```

      ## JWT Verification Errors

      - If no token is provided, the response will be `401 Unauthorized`.
      - If the token is invalid, the response will be `403 Forbidden`.
      - If the token is expired, the response will be `403 Forbidden` and the response body will contain the following:

      ```
      Invalid `exp` claim in JWT: Expiration time is in the past
      ```

      - If the token has an invalid `exp` or `nbf` claim, the response will be `403 Forbidden` and the response body will contain the following:

      ```
      Invalid `<claim>` claim in JWT: <description>
      ```
      - If the token is not yet valid, the response will be `403 Forbidden` and the response body will contain the following:

      ```
      Invalid `nbf` claim in JWT: The token is not valid before <date>
      ```

      ## Example JWT Generation

      ```python
      import jwt

      private_key = b"-----BEGIN PRIVATE KEY-----\nZm9vYmFyCg (...)"
      public_key = b"-----BEGIN PUBLIC KEY-----\nS2V5Cgs3BZm9vYmFyCg (...)"
      payload = {
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1),
        "nb": datetime.datetime.utcnow(),
        "allowed_operations": ["document_editor", "pdfa"],
        "allowed_origins": ["example.com", ".*\.example-with-subdomains\.com"]
      }
      encoded = jwt.encode(payload, private_key, algorithm="RS256")
      ```

      ```javascript
      const jwt = require('jsonwebtoken');

      const privateKey = `-----BEGIN PRIVATE KEY-----\nZm9vYmFyCg  (...)`;
      const publicKey = `-----BEGIN PUBLIC KEY-----\nS2V5Cgs3BZm9 (...)`;

      const payload = {
        allowed_operations: ["document_editor", "pdfa"],
        allowed_origins: ["example.com", ".*\.example-with-subdomains\.com"]
      };

      const expiresIn = 2 * 60 * 60; // 2 hours
      const notBefore = 60 * 60; // 1 hour

      const encoded = jwt.sign(payload, privateKey, { algorithm: 'RS256', expiresIn: expiresIn, notBefore: notBefore });
      ```
  - name: File Type Support
    description: |-
      Document Engine supports importing documents in different file formats:

      * PDFs
      * Image documents
      * Office files (Word, Excel, PowerPoint etc.)
      * HTML files (including associated assets such as images, CSS, and web fonts)

      The following table shows the allowed file extensions, their MIME types, and the expected Document Engine license.

      | File Extension | MIME Type                                                                 | Required license |
      | -------------- | ------------------------------------------------------------------------- | ---------------- |
      | PDF            | application/pdf                                                           | any              |
      | DOC            | application/msword                                                        | Office Files     |
      | DOCX           | application/vnd.openxmlformats-officedocument.wordprocessingml.document   | Office Files     |
      | XLS            | application/vnd.ms-excel                                                  | Office Files     |
      | XLSX           | application/vnd.openxmlformats-officedocument.spreadsheetml.sheet         | Office Files     |
      | PPT, PPS       | application/vnd.ms-powerpoint                                             | Office Files     |
      | PPTX           | application/vnd.openxmlformats-officedocument.presentationml.presentation | Office Files     |
      | PPSX           | application/vnd.openxmlformats-officedocument.presentationml.slideshow    | Office Files     |
      | RTF            | application/rtf                                                           | Office Files     |
      | ODT            | application/vnd.oasis.opendocument.text                                   | Office Files     |
      | HTML           | text/html                                                                 | HTML Conversion  |
      | BMP            | image/bmp                                                                 | Image Conversion |
      | JPG/JPEG       | image/jpeg                                                                | Image Conversion |
      | PNG            | image/png                                                                 | Image Conversion |
      | TIFF           | image/tiff                                                                | Image Conversion |
      | HEIC           | image/heic                                                                | Image Conversion |
      | GIF            | image/gif                                                                 | Image Conversion |
      | WEBP           | image/webp                                                                | Image Conversion |
      | SVG            | image/svg+xml                                                             | Image Conversion |
      | TGA            | image/x-tga                                                               | Image Conversion |
      | EPS            | image/postscript                                                          | Image Conversion |
      | EML            | message/rfc822                                                            | Email Conversion |
      | MSG            | application/vnd.ms-outlook                                                | Email Conversion |
      | DWG            | image/vnd.dwg                                                             | CAD Conversion   |
      | DXF            | image/vnd.dxf                                                             | CAD Conversion   |
  - name: Instant JSON
    description: |-
      Instant JSON is a format we created for bringing annotations, forms and bookmarks into a modern format while keeping all important properties to make the Instant JSON spec work with PDF. The format is fully documented and can be easily converted to XFDF to make it interoperable.

      Please refer to [Instant JSON Reference](https://www.nutrient.io/api/reference/document-engine/instant-json/) for full reference documentation of the format.
  - name: Build API
    description: |-
      Build API allows you to assemble a PDF from multiple parts, such as an existing PDF, a blank page, or an HTML page. You can apply one or more actions, such as watermarking, rotating pages, or importing annotations. Once the entire PDF is generated from its parts, you can also apply additional actions, such as optical character recognition (OCR), to the assembled PDF itself.

      The Build API can be interacted with two distinct ways:

      * The basic use case for the Build API is to upload all inputs together in the build instructions with the `multipart/form-data` request, where each input is provided as a separate part along with a special `instructions` part with the processing instructions.
      * The Build API supports inputs provided from remote URLs. If all inputs are provided as remote URLs, the multipart request isn’t necessary and can be simplified to a non-multipart request with the `application/json` body with the processing instructions.

      ## Password-Protected PDFs and PDF Permissions

      PDF files can be protected with passwords to control who can access, modify, and print the contents of the document.

      There are two types of passwords that can be used to protect a PDF file: owner password and user password.

      - **Owner password** — This password allows the owner of the PDF file to modify the file and change its permissions. The owner can change the user password, as well as set or modify the user permissions that control what users can do with the file.
      - **User password** — This password allows a user to open the PDF file with a set of permissions defined by the owner of the file. These permissions control what the user can do with the file, such as view, print, copy, or modify the contents. The user password can be used to protect the PDF file from unauthorized access by preventing users from viewing or modifying the file without the password.

      PDF files can have different sets of user permissions, depending on the intended use of the document. Common permissions that can be set include:

      - Printing — Allows the user to print the PDF file.
      - Modification — Allows the user to modify the contents of the PDF file.
      - Copying — Allows the user to copy text and images from the PDF file.
      - Commenting — Allows the user to add comments or annotations to the PDF file.
      - Form filling — Allows the user to fill in form fields in the PDF file.
      - Extracting — Allows the user to extract text or images from the PDF file.
      - Accessibility — Allows the user to access the contents of the PDF file for assistive technology purposes.
      - Assembling — Allows the user to assemble the PDF file from multiple documents.

      Passwords and permissions are important features that protect and control access to the contents of the document. They enable the owner of the file to set specific user permissions for different users, and they also ensure that the document remains secure and protected from unauthorized access.

      With Nutrient Document Engine, it’s possible to control passwords and permissions using the Build API.

      In the context of password and permissions, the `output` part is relevant:

      ```json
      {
        "parts": [...],
        "output": {
          "type": "pdf",
          "owner_password": "owner-password",
          "user_password": "user-password",
          "user_permissions": [
            "printing",
            "modification",
            "extract",
            "annotations_and_forms",
            "fill_forms",
            "extract_accessibility",
            "assemble",
            "print_high_quality"
          ]
        }
      }
      ```

      ## Referencing annotations using IDs assigned by Document Engine

      The Build API allows to use documents that are already stored in Document Engine.
      The annotations, while stored in Document Engine, are assigned unique ID.
      This identifier can be used also in the context of Build API for certain actions to address specific annotation.
      Currently the only action referencing annotations is flattening, however extra actions can added or the existing ones can be extended.

      Such actions can reference annotations by its Document Engine IDs only if they are
       - either applied on single part:
      ```json
      {
        "parts": [
          {"document": {"id": "id"}}
        ],
        "actions": [
          {"type": "flatten", "annotationIds": ["<UUID_OF_ANNOTATION>"]}
        ]
      }
      ```
      - or applied in context of single part:
      ```json
      {
        "parts": [
          {
            "document": {"id": "id"},
            "actions": [
              {"type": "flatten", "annotationIds": ["<UUID_OF_ANNOTATION>"]}
            ]
          },
          {
            "file": "other-file"
          }
        ],
        "actions": [..."some global actions"]
      }
      ```

      This limitation is caused by highly compostable and flexible nature of Build API, that is agnostic to Document Engine storage model.
      In the PDF file annotations are referenced only by `pdfObjectIDs`.
      If the annotation is extracted, it gets ID assigned that is used in Document Engine, that is used to identify it **outside** of file.
      However, if the annotation is not modified at all, its ID is not written back to PDF file.
      As Build pipeline is designed to operate on streamline of PDF files, it cannot be aware of those IDs.
      In certain cases, however, it is possible to perform translation of Document Engine IDs to `pdfObjectIDs`.
      Those scenarios where discussed in this paragraph.
      For example it is not possible when two parts (different PDF files) are merged, because such operation requires reassigning `pdfObjectIDs`, as the may conflict.

      ## Instructions Schema

      When making requests to the API, the instructions object needs to follow the following schema:

      <SchemaDefinition schemaRef="#/components/schemas/BuildInstructions" />
  - name: Fonts
    description: Retrieve fonts and font substitutions used in the document.
externalDocs:
  description: Nutrient Document Engine Guides
  url: https://www.nutrient.io/guides/document-engine/
paths:
  /api/documents:
    post:
      summary: Create a Document
      operationId: upload-document
      description: |-
        ## Basic Usage
        To create a new document from a file, `POST` its contents to
        `/api/documents`, specifying the correct content type.

        You can create a document in any of the supported file formats and then use the functionality of both the Web API and Document Engine-Server API.

        Nutrient Document Engine will extract the title of the document from the file metadata if
        it is present.

        ## Advanced Usage

        Nutrient Document Engine also supports uploading files as `multipart/form-data`. When
        using this method, Document Engine will try reading the title from the file metadata
        and fall back to the filename if the metadata is not available.

        When using `multipart/form-data` you can also attach an XFDF or Instant JSON file to be
        applied to the imported document. This feature is available both for direct file upload
        and importing from remote URL, however, note that you should specify either `url` (and
        optionally `sha256`) or `file`, not both at the same time.

        While using this request format you can also specify a custom `title` or `document_id`.

        ## Adding a Document from a URL

        You can also add a document to Nutrient Document Engine by specifying the URL
        the document can be fetched from. By default, a document added by a URL is not
        persistently stored in Nutrient Document Engine and will be fetched from the URL
        when necessary. This is useful when you already have a document storage
        solution and you want Nutrient Document Engine to fetch the documents from your
        document storage. You can override this default storage behavior to store
        the document persistently by setting a `copy_asset_to_storage_backend` option to `true`.

        To add a document from a URL, `POST` its URL — and optionally, its
        SHA256 hash, your `document_id`, and your `title` — using the
        `application/json` content type.

        ## Processing Document on Upload

        Nutrient Document Engine supports processing documents via Build API. This allows you to
        assemble a PDF from multiple parts, such as an existing document in supported content type, a blank page,
        or an HTML page. You can apply one or more actions, such as watermarking, rotating pages, or importing
        annotations. Once the entire PDF is generated from its parts, you can also apply additional actions,
        such as optical character recognition (OCR), to the assembled PDF itself.

        To Process the document using The Build API, you'll need to provide all inputs and the [Build instructions](#tag/Build-API):
        * Use `multipart/form-data` with special `instructions` part with the processing instructions. You can pass any options allowed
        by the other document creation methods - `document_id`, `title`, etc. - as parts in the multipart request.
        * If all inputs are provided as remote URLs, the multipart request isn't necessary and can be simplified to a simple
        non-multipart request with the `application/json` body with the processing instructions provided as `instructions` key.

        ## Configuring Storage
        By default, Document Engine will store all assets associated with the document - images, PDF, source files that were converted, etc. in the built-in storage.
        If the `ASSET_STORAGE_BACKEND` is configured, then Document Engine will use that instead of `built_in`.

        That said, when uploading a document you can optionally pass in some storage configuration options
        to control where the document's assets are stored by setting the `storage` field.
        For example, you can specify the exact s3 bucket for storage of the document's assets.
        You can also specify that a given document should be stored in Azure Blob Storage or with the `built_in` storage.

        This configuration will overide any default storage backends set in Document Engine's `ASSET_STORAGE_BACKEND` configuration.
        and it will be used to store all assets associated with the document - images, PDF, source files that were converted, etc.

        > ⚠️ NOTE: The `backend` configured in `storage` must be enabled as either the main storage backend or as a fallback otherwise the upload will be done using the default enabled storage after logging a warning.
        > Learn more about configuring Asset Storage for Document Engine [here](https://www.nutrient.io/guides/document-engine/configuration/asset-storage/#migration-between-asset-storage-options)
      parameters:
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/pdf:
            schema:
              type: string
              format: binary
              description: The binary content of the PDF file.
              example: <PDF data>
          multipart/form-data:
            schema:
              oneOf:
                - $ref: '#/components/schemas/CreateDocumentUpload'
                - $ref: '#/components/schemas/CreateDocumentInstructions'
                - $ref: '#/components/schemas/CreateDocumentUrl'
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/CreateDocumentInstructions'
                - $ref: '#/components/schemas/CreateDocumentUrl'
          application/octet-stream:
            schema:
              type: string
              format: binary
              description: The binary content of a file in any of the supported formats.
              example: <binary data>
      responses:
        '200':
          description: |
            The document was successfully created.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentCreated'
        '401':
          description: You are unauthorized.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"instructions":{"parts":[{"file":"pdf-file-from-multipart"}],"actions":[{"type":"applyInstantJson","file":{"url":"https://remote-file-storage/input-file","sha256":"string"}}],"output":{"metadata":{"title":"Nutrient Document Engine API Specification","author":"Document Author"},"labels":[{"pages":{"start":0,"end":-1},"label":"Page I-III"}],"user_password":"string","owner_password":"string","user_permissions":["printing"],"optimize":{"grayscaleText":false,"grayscaleGraphics":false,"grayscaleImages":false,"grayscaleFormFields":false,"grayscaleAnnotations":false,"disableImages":false,"mrcCompression":false,"imageOptimizationQuality":2,"linearize":false},"type":"pdf"}},"storage":{"backend":"s3","bucketName":"string","bucketRegion":"string"},"document_id":"7KPSE41NWKDGK5T9CFS3S53JTP","title":"string","overwrite_existing_document":false}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              instructions: {
                parts: [{file: 'pdf-file-from-multipart'}],
                actions: [
                  {
                    type: 'applyInstantJson',
                    file: {url: 'https://remote-file-storage/input-file', sha256: 'string'}
                  }
                ],
                output: {
                  metadata: {title: 'Nutrient Document Engine API Specification', author: 'Document Author'},
                  labels: [{pages: {start: 0, end: -1}, label: 'Page I-III'}],
                  user_password: 'string',
                  owner_password: 'string',
                  user_permissions: ['printing'],
                  optimize: {
                    grayscaleText: false,
                    grayscaleGraphics: false,
                    grayscaleImages: false,
                    grayscaleFormFields: false,
                    grayscaleAnnotations: false,
                    disableImages: false,
                    mrcCompression: false,
                    imageOptimizationQuality: 2,
                    linearize: false
                  },
                  type: 'pdf'
                }
              },
              storage: {backend: 's3', bucketName: 'string', bucketRegion: 'string'},
              document_id: '7KPSE41NWKDGK5T9CFS3S53JTP',
              title: 'string',
              overwrite_existing_document: false
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"instructions\":{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}},\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"document_id\":\"7KPSE41NWKDGK5T9CFS3S53JTP\",\"title\":\"string\",\"overwrite_existing_document\":false}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"instructions\":{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}},\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"document_id\":\"7KPSE41NWKDGK5T9CFS3S53JTP\",\"title\":\"string\",\"overwrite_existing_document\":false}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"instructions\":{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}},\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"document_id\":\"7KPSE41NWKDGK5T9CFS3S53JTP\",\"title\":\"string\",\"overwrite_existing_document\":false}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/async/jobs/{jobId}:
    get:
      summary: Get the status of an async job
      operationId: get-async-job-status
      description: |-
        Get the status of a previously scheduled asynchronous job

        If a job is `cancelled`, simply retrying the request won't help.
        You might need to make changes to Document Engine's configuration and restart your Document Engine instances.
        For example, a cancellation could occur if you attempted an asset migration job to a storage backend that's not enabled in your Document Engine configuration.

        If a job is `expired`, then the job as well as its output assets (PDFs, images etc.) - if any,
        will have been deleted and thus be unavailable for download. Attempts to check the status of that job return a `404` not found error.
        You need to redo an expired job to regenerate those assets.
        You can configure the expiration time for jobs by setting the `ASYNC_JOBS_TTL` option in the Document Engine configuration.
        The default value is 2 days.
      parameters:
        - $ref: '#/components/parameters/JobId'
      responses:
        '200':
          description: The job status was successfully retrieved.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AsyncJobStatus'
        '401':
          description: Unauthorized
        '404':
          description: Job not found
      tags:
        - Maintenance
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/async/jobs/{jobId} \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/async/jobs/{jobId}",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/async/jobs/{jobId}")
              .get()
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/async/jobs/{jobId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("GET", "/api/async/jobs/{jobId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/fonts:
    get:
      summary: Get global fonts
      operationId: get-global-fonts
      responses:
        '200':
          description: |
            List of fonts that are available in the global context of Nutrient Document Engine.

            Global context here means that these fonts are available for use
            by all documents processed by Nutrient Document Engine
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FontFile'
        '401':
          description: Unauthorized
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/fonts \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/fonts",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/fonts")
              .get()
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/fonts");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("GET", "/api/fonts", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/font_substitutions:
    get:
      summary: Get the list of font substitutions in the configured `font-substitutions.json` file, if any.
      operationId: get-configured-font-substitutions
      description: |-
        If a `font-substitutions.json` file has been mounted on Document Engine's container,
        use this endpoint to get a list of the font substitutions defined in that file,

        Note that the font substitutions returned by this endpoint will be used by Nutrient Document Engine
        when processing all documents.
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/FontSubstitutionList'
        '401':
          description: Unauthorized
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/font_substitutions \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/font_substitutions",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/font_substitutions")
              .get()
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/font_substitutions");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("GET", "/api/font_substitutions", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}:
    delete:
      summary: Delete a Document
      operationId: delete-document
      description: |-
        Deletes a document with all of its annotation, underlying PDF file and attachments
        not referenced by other documents.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
      responses:
        '200':
          description: The document has been deleted.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId} \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}")
              .delete(null)
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("DELETE", "/api/documents/{documentId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/outline.json:
    get:
      summary: Get a Document Outline
      operationId: get-document-outline
      description: This endpoint allows you to fetch the outline of a document.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the document outline.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      outline:
                        $ref: '#/components/schemas/OutlineElements'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/outline.json \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/outline.json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/outline.json")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/outline.json");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/outline.json", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/document_info:
    get:
      summary: Fetch Document Information
      operationId: fetch-document-info
      description: |-
        This endpoint allows you to fetch the document's page count,
        the dimensions of each page, and the document's permissions.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the top-level document information.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentInfo'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/document_info \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/document_info",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/document_info")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/document_info");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/document_info", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/properties:
    get:
      summary: Fetch Document Properties
      operationId: fetch-document-properties
      description: |-
        This endpoint allows you to fetch properties of a document
        including its title, information about password-protection,
        SHA256 hash of the content, and the storage mechanism used
        for the underlying PDF file. All of them are set by Document Engine
        when a document is uploaded.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
      responses:
        '200':
          description: Document Engine returned the document properties.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentProperties'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/properties \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/properties",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/properties")
              .get()
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/properties");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("GET", "/api/documents/{documentId}/properties", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/search:
    get:
      summary: Search for Text
      description: |-
        Use this endpoint to search in a whole document or a continuous range of pages.

        This API offers three different types of search, controlled via `type` query parameter:
        - `text` (default) - simple, text search. By default, the search query is case insensitive,
           but you can change this by setting `case_sensitive` to `true`.
        - `preset` - search using one of the predefined patterns. For the full list of presets,
           see the request parameters schema.
        - `regex` - search using a regular expression. The regular expressions needs to comply
           with the [ICU regex standard](http://userguide.icu-project.org/strings/regexp). By
           default, the regular expression is case sensitive, but you can change that by setting the
           `case_sensitive` parameter to `false`.

        When using `text` search, the search query needs to be at least three characters long.

        By default, search results do not include annotations. If you want to
        search inside annotations in the document, you can include a
        `include_annotations` parameter set to `true`.
      operationId: search-document
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
        - $ref: '#/components/parameters/Q'
        - $ref: '#/components/parameters/Type'
        - $ref: '#/components/parameters/Start'
        - $ref: '#/components/parameters/Limit'
        - $ref: '#/components/parameters/IncludeAnnotations'
        - $ref: '#/components/parameters/CaseSensitive'
      responses:
        '200':
          description: Document Engine returned the search results.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/SearchResults'
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/search?q=SOME__VALUE&type={string_value}&start=SOME_INTEGER_VALUE&limit=SOME_INTEGER_VALUE&include_annotations={boolean_value}&case_sensitive={boolean_value}' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/search?q=SOME__VALUE&type={string_value}&start=SOME_INTEGER_VALUE&limit=SOME_INTEGER_VALUE&include_annotations={boolean_value}&case_sensitive={boolean_value}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/search?q=SOME__VALUE&type={string_value}&start=SOME_INTEGER_VALUE&limit=SOME_INTEGER_VALUE&include_annotations={boolean_value}&case_sensitive={boolean_value}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/search?q=SOME__VALUE&type={string_value}&start=SOME_INTEGER_VALUE&limit=SOME_INTEGER_VALUE&include_annotations={boolean_value}&case_sensitive={boolean_value}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/search?q=SOME__VALUE&type={string_value}&start=SOME_INTEGER_VALUE&limit=SOME_INTEGER_VALUE&include_annotations={boolean_value}&case_sensitive={boolean_value}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pages/text:
    get:
      summary: Fetch Document Text
      description: This endpoint allows you to fetch the text of all pages in a document.
      operationId: get-document-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the lines of text for all pages in the document.
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/PageText'
                description: Text contents for all pages in a document.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/pages/text \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pages/text",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pages/text")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pages/text");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pages/text", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pages/{pageIndex}/text:
    get:
      summary: Fetch Page Text
      description: This endpoint allows you to fetch the text of a specific page in a document.
      operationId: get-document-page-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the lines of text of the specified page in the document.
          content:
            application/json:
              schema:
                type: object
                properties:
                  textLines:
                    type: array
                    items:
                      $ref: '#/components/schemas/TextLine'
                    description: All lines of text on the page.
        '401':
          description: You are unauthorized.
        '404':
          description: |
            The document with given ID doesn't exist, or the page index is invalid or out of bounds.
          content:
            text/plain:
              schema:
                type: string
                example: Parameter 'page_index' is invalid or out of bounds.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/text \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pages/{pageIndex}/text",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/text")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/text");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pages/{pageIndex}/text", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pages/{pageIndex}/highlighted:
    get:
      summary: Fetch Highlighted Text on a Page
      description: |-
        Highlighted text in the document refers to any text that is highlighted with any of the
        markup annotations, like underline, strikeout, or highlight.

        Note that the data returned by this endpoint is just an approximation and might not always
        exactly reflect the text highlighted in the PDF file.
      operationId: get-document-page-highlighted-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned the highlighted text along with respective markup annotations.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/HighlightedText'
                    description: All highlighted text on the page.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/highlighted \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pages/{pageIndex}/highlighted",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/highlighted")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/highlighted");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pages/{pageIndex}/highlighted", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pages/{pageIndex}/image:
    get:
      summary: Render a Page
      description: |-
        Returns an image with the rendered page from a document. Requires exactly one of
        `width` and `height` query parameters to set the required dimensions of the rendered image.

        Annotation AP streams are not rendered by default, use `render_ap_streams` query parameter
        to enable AP streams rendering.

        Rendered image format depends on the value of the `Accept` header. Supported content types
        are `image/png` (default) and `image/webp`.
      operationId: render-document-page
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
        - in: query
          name: width
          required: false
          schema:
            type: number
          description: The width of the page to render.
        - in: query
          name: height
          required: false
          schema:
            type: number
          description: The height of the page to render.
        - in: query
          name: render_ap_streams
          required: false
          schema:
            type: boolean
          description: Whether to render annotation AP streams.
        - in: query
          name: ocg_layers
          schema:
            type: array
            items:
              type: integer
          description: A list of OCG Layer IDs
      responses:
        '200':
          description: Document Engine returned the rendering of the specified page in the document.
          content:
            image/png:
              schema:
                type: string
                format: binary
                example: <image file>
        '400':
          description: |
            One or more of the provided request parameters are invalid, e.g. both `width`
            and `height` were missing or were provided at the same time.
        '401':
          description: You are unauthorized.
        '404':
          description: |
            The document with given ID doesn't exist, or the page index is invalid or out of bounds.
          content:
            text/plain:
              schema:
                type: string
                example: Parameter 'page_index' is invalid or out of bounds.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/prerender:
    post:
      summary: Prerender a Document
      description: |-
        This endpoint allows you to pre-render documents in background so that they
        are cached ahead of time by Nutrient Document Engine.

        This speeds up loading times when opening documents via Nutrient Web SDK.
        The rendering is done asynchronously, and future clients asking for the
        document will receive the already cached, rendered pages. For more details
        about how Nutrient Document Engine caches work, please check out our
        [Cache](https://www.nutrient.io/guides/document-engine/configuration/cache/) guide.

        You can customize prerendering by providing a range of pages to prerender
        and an array of scale factors for prerendered images.

        > ⚠️ Note: Prerendering feature requires setting up the Redis cache.
        > All Redis cache keys are set to expire after the configured `REDIS_TTL`. To opt out of using the `REDIS_TTL`
        > for prerendered cache keys, set `USE_REDIS_TTL_FOR_PRERENDERING` to `false` in your configuration.
      operationId: prerender-document
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Prerender'
      responses:
        '202':
          description: Document Engine started prerendering in the background.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/prerender \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"scales":[1,2,4],"start_page":0,"end_page":3}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/prerender",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({scales: [1, 2, 4], start_page: 0, end_page: 3}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"scales\":[1,2,4],\"start_page\":0,\"end_page\":3}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/prerender")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/prerender");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"scales\":[1,2,4],\"start_page\":0,\"end_page\":3}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"scales\":[1,2,4],\"start_page\":0,\"end_page\":3}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/prerender", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/build:
    post:
      operationId: build-document
      summary: Process Documents And Download the Result
      description: |-
        This endpoint allows to use [Build instructions](#tag/Build-API) to process a document. This allows to
        assemble a PDF from multiple parts, such as an existing document in supported content type, a blank page,
        or an HTML page. You can apply one or more actions, such as watermarking, rotating pages, or importing
        annotations. Once the entire PDF is generated from its parts, you can also apply additional actions,
        such as optical character recognition (OCR), to the assembled PDF itself.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BuildInstructions'
          multipart/form-data:
            schema:
              type: object
              properties:
                instructions:
                  $ref: '#/components/schemas/BuildInstructions'
            encoding:
              instructions:
                contentType: application/json
      responses:
        '200':
          $ref: '#/components/responses/BuildResponseOk'
        '400':
          description: The request is malformed
          content:
            application/json:
              schema:
                type: object
                properties:
                  details:
                    type: string
                    example: The request is malformed
                  status:
                    type: integer
                    enum:
                      - 400
                      - 500
                  requestId:
                    type: string
                    example: xy123zzdafaf
                  failingPaths:
                    type: array
                    description: List of failing paths.
                    items:
                      type: object
                      properties:
                        path:
                          type: string
                          example: $.property[0]
                        details:
                          type: string
                          example: Missing required property
        '401':
          description: You are unauthorized.
        '422':
          description: The request exceeds the size limit for outbound responses
          content:
            application/json:
              schema:
                type: object
                properties:
                  details:
                    type: string
                    example: The request is malformed
                  status:
                    type: integer
                    enum:
                      - 422
                  requestId:
                    type: string
                    example: xy123zzdafaf
      tags:
        - Document Editing
      x-codeSamples:
        - label: cURL
          lang: curl
          source: |
            curl --request POST \
              --url http://localhost:5000/api/documents \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{
              "instructions": {
                "parts": [{ "file": {"url": "https://remote-file-storage/input.pdf"}}],
                "actions": [{ "type": "applyInstantJson", "file": {"url": "https://remote-file-storage/instant.json" }}],
                "output": {
                  "metadata": {
                    "title": "Nutrient Document Engine API Specification",
                    "author": "Document Author"
                  },
                  "labels": [{ "pages": [0], "label": "Page I-III" }],
                  "user_password": "string",
                  "owner_password": "string",
                  "user_permissions": ["printing"],
                  "type": "pdf"
                }
              },
              "document_id": "7KPSE41NWKDGK5T9CFS3S53JTP",
              "title": "string",
              "overwrite_existing_document": false
            }'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/build",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              parts: [{file: 'pdf-file-from-multipart'}],
              actions: [
                {
                  type: 'applyInstantJson',
                  file: {url: 'https://remote-file-storage/input-file', sha256: 'string'}
                }
              ],
              output: {
                metadata: {title: 'Nutrient Document Engine API Specification', author: 'Document Author'},
                labels: [{pages: {start: 0, end: -1}, label: 'Page I-III'}],
                user_password: 'string',
                owner_password: 'string',
                user_permissions: ['printing'],
                optimize: {
                  grayscaleText: false,
                  grayscaleGraphics: false,
                  grayscaleImages: false,
                  grayscaleFormFields: false,
                  grayscaleAnnotations: false,
                  disableImages: false,
                  mrcCompression: false,
                  imageOptimizationQuality: 2,
                  linearize: false
                },
                type: 'pdf'
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/build")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/build");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/build", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/migrate_assets:
    post:
      summary: Migrate a Document's Assets to the Storage in the Configuration
      description: |-
        This endpoint allows you to migrate all the assets that are associated with a document to a new storage backend.

        With this endpoint, you can migrate assets from one s3 compatible storage bucket, to another s3 compatible storage bucket.
        You can also use this endpoint to migrate assets from the built_in storage to s3 or Azure and vice versa.

        This endpoint triggers an asynchronous migration operation.
        If the request parameters are valid will return immediately with a `202 Accepted` response with a `jobId`
        that you can use to track the status of the migration operation.

        You can track the status of the migration operation at `/api/async/jobs/{jobId}`

        > ⚠️ NOTE: The `backend` set in `storage` must be enabled as either the main storage backend or as a fallback otherwise migration will fail
        > Learn more about configuring Asset Storage backends for Document Engine [here](https://www.nutrient.io/guides/document-engine/configuration/asset-storage/#migration-between-asset-storage-options)
      operationId: migrate-document-assets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MigrateDocumentAssetsRequest'
      responses:
        '202':
          description: |
            The migration job was successfully scheduled
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MigrateDocumentAssetsResponse'
        '400':
          description: There was a problem with your request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MigrateDocumentAssetsError'
        '401':
          description: You are unauthorized.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/migrate_assets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"storage":{"backend":"s3","bucketName":"string","bucketRegion":"string"},"copy_remote_files_to_new_storage":false}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/migrate_assets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              storage: {backend: 's3', bucketName: 'string', bucketRegion: 'string'},
              copy_remote_files_to_new_storage: false
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"copy_remote_files_to_new_storage\":false}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/migrate_assets")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/migrate_assets");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"copy_remote_files_to_new_storage\":false}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"},\"copy_remote_files_to_new_storage\":false}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/migrate_assets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/process_office_template:
    post:
      operationId: process-office-template
      summary: Process Office Template And Download the Result
      description: This endpoint allows to populate the document template (in DOCX format) with corresponding data.
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                model:
                  $ref: '#/components/schemas/OfficeTemplateModel'
                document:
                  type: string
                  format: binary
                  description: The binary content of the document to process.
                  example: <DOCX data>
            encoding:
              model:
                contentType: application/json
              document:
                contentType: application/octet-stream
      responses:
        '200':
          $ref: '#/components/responses/OfficeTemplateResponseOk'
        '400':
          description: The request is malformed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '401':
          description: You are unauthorized.
      tags:
        - Document Editing
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/process_office_template \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --form 'model={"config":{"delimiter":{"start":"{{","end":"}}"}},"model":{"placeholder":"replacement value","loop-name":[{"placeholder-within-loop":"replacement value","another-placeholder-within-loop":"replacement value 2"},{"placeholder-within-loop":"another replacement value","another-placeholder-within-loop":"another replacement value 2"}]}}' \
              --form 'document=<DOCX data>'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/process_office_template",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"model\"\r\n\r\n{\"config\":{\"delimiter\":{\"start\":\"{{\",\"end\":\"}}\"}},\"model\":{\"placeholder\":\"replacement value\",\"loop-name\":[{\"placeholder-within-loop\":\"replacement value\",\"another-placeholder-within-loop\":\"replacement value 2\"},{\"placeholder-within-loop\":\"another replacement value\",\"another-placeholder-within-loop\":\"another replacement value 2\"}]}}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"document\"\r\n\r\n<DOCX data>\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"model\"\r\n\r\n{\"config\":{\"delimiter\":{\"start\":\"{{\",\"end\":\"}}\"}},\"model\":{\"placeholder\":\"replacement value\",\"loop-name\":[{\"placeholder-within-loop\":\"replacement value\",\"another-placeholder-within-loop\":\"replacement value 2\"},{\"placeholder-within-loop\":\"another replacement value\",\"another-placeholder-within-loop\":\"another replacement value 2\"}]}}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"document\"\r\n\r\n<DOCX data>\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/process_office_template")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/process_office_template");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"model\"\r\n\r\n{\"config\":{\"delimiter\":{\"start\":\"{{\",\"end\":\"}}\"}},\"model\":{\"placeholder\":\"replacement value\",\"loop-name\":[{\"placeholder-within-loop\":\"replacement value\",\"another-placeholder-within-loop\":\"replacement value 2\"},{\"placeholder-within-loop\":\"another replacement value\",\"another-placeholder-within-loop\":\"another replacement value 2\"}]}}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"document\"\r\n\r\n<DOCX data>\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"model\"\r\n\r\n{\"config\":{\"delimiter\":{\"start\":\"{{\",\"end\":\"}}\"}},\"model\":{\"placeholder\":\"replacement value\",\"loop-name\":[{\"placeholder-within-loop\":\"replacement value\",\"another-placeholder-within-loop\":\"replacement value 2\"},{\"placeholder-within-loop\":\"another replacement value\",\"another-placeholder-within-loop\":\"another replacement value 2\"}]}}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"document\"\r\n\r\n<DOCX data>\r\n-----011000010111000001101001--\r\n"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/process_office_template", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/apply_instructions:
    post:
      operationId: document-apply-instructions
      summary: Process Documents And Persist the Result
      description: |-
        This endpoint allows to use [Build instructions](#tag/Build-API) to process a document.

        The current document can be referred to by using `#self` anchor.
        ```
        {
          "document": { "id": "#self" }
        }
        ```

        The result of the processing will replace the document's base layer after successful completion.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BuildInstructions'
          multipart/form-data:
            schema:
              type: object
              properties:
                instructions:
                  $ref: '#/components/schemas/BuildInstructions'
            encoding:
              instructions:
                contentType: application/json
      responses:
        '200':
          description: The document properties
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentProperties'
        '401':
          description: You are unauthorized.
        '404':
          description: The document or the page doesn't exist.
      tags:
        - Document Editing
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/apply_instructions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"parts":[{"file":"pdf-file-from-multipart"}],"actions":[{"type":"applyInstantJson","file":{"url":"https://remote-file-storage/input-file","sha256":"string"}}],"output":{"metadata":{"title":"Nutrient Document Engine API Specification","author":"Document Author"},"labels":[{"pages":{"start":0,"end":-1},"label":"Page I-III"}],"user_password":"string","owner_password":"string","user_permissions":["printing"],"optimize":{"grayscaleText":false,"grayscaleGraphics":false,"grayscaleImages":false,"grayscaleFormFields":false,"grayscaleAnnotations":false,"disableImages":false,"mrcCompression":false,"imageOptimizationQuality":2,"linearize":false},"type":"pdf"}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/apply_instructions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              parts: [{file: 'pdf-file-from-multipart'}],
              actions: [
                {
                  type: 'applyInstantJson',
                  file: {url: 'https://remote-file-storage/input-file', sha256: 'string'}
                }
              ],
              output: {
                metadata: {title: 'Nutrient Document Engine API Specification', author: 'Document Author'},
                labels: [{pages: {start: 0, end: -1}, label: 'Page I-III'}],
                user_password: 'string',
                owner_password: 'string',
                user_permissions: ['printing'],
                optimize: {
                  grayscaleText: false,
                  grayscaleGraphics: false,
                  grayscaleImages: false,
                  grayscaleFormFields: false,
                  grayscaleAnnotations: false,
                  disableImages: false,
                  mrcCompression: false,
                  imageOptimizationQuality: 2,
                  linearize: false
                },
                type: 'pdf'
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/apply_instructions")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/apply_instructions");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/apply_instructions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/apply_operations:
    post:
      summary: Edit the Document and Persist the Result
      deprecated: true
      description: |-
        > ⚠️ This endpoint is deprecated. Please use `/api/documents/{documentId}/apply_instructions` instead.

        This endpoint allows you to edit the document, performing transformations like
        rotating, adding or deleting pages, and store the resulting PDF file at the
        document's base layer.

        Editing the document affects the responses returned by other endpoints. For
        example, removing a page also deletes all the annotations on that page. Similarly,
        other functionality, like searching in a document will return different results.

        If you need to preserve the original document, PDF file, and related data,
        we recommend leveraging Instant Layers and always using named layers.

        Note that in order to use this endpoint you need to have a document editing feature
        enabled in your license.
      operationId: edit-and-persist-document-pdf
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                operations:
                  $ref: '#/components/schemas/DocumentOperations'
      responses:
        '200':
          description: The changes have been persisted on Document Engine.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentProperties'
        '400':
          description: |
            One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Document Editing
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/apply_operations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"operations":[{"type":"rotatePages","pageIndexes":[0],"rotateBy":90}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/apply_operations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({operations: [{type: 'rotatePages', pageIndexes: [0], rotateBy: 90}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/apply_operations")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/apply_operations");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/apply_operations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pdf_with_operations:
    post:
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      summary: Edit the Document and Download it
      deprecated: true
      description: |-
        > ⚠️ This endpoint is deprecated. Please use `/api/build` instead.

        This endpoint allows you to edit the document, performing transformations like
        rotating, adding or deleting pages. After these operations are applied, the
        Document Engine will return the result as a PDF file.

        Note that in order to use this endpoint you need to have a document editing feature
        enabled in your license.

        ### Operations with external files

        In order to use `importDocument`, `applyInstantJson`, or `applyXfdf` operations, you need to use
        `multipart/form-data` content type.
      operationId: edit-and-download-document-pdf
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                operations:
                  $ref: '#/components/schemas/DocumentOperations'
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: |
            One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Document Editing
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/pdf_with_operations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"operations":[{"type":"rotatePages","pageIndexes":[0],"rotateBy":90}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pdf_with_operations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({operations: [{type: 'rotatePages', pageIndexes: [0], rotateBy: 90}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pdf_with_operations")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pdf_with_operations");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"operations\":[{\"type\":\"rotatePages\",\"pageIndexes\":[0],\"rotateBy\":90}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/pdf_with_operations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pdf:
    get:
      summary: Download the Document as a PDF
      description: |-
        This operation downloads the latest version of the document with annotations
        as a PDF file.

        If the query parameter `source=true` is included in the request, the originally
        uploaded version will be fetched instead.

        Additionally, you can download the flattened version of the file by providing
        `flatten=true` query parameter. Note, however, that `source` and `flatten`
        can't be used at the same time.

        To download a PDF/A conformant document, include the `type=pdfa` query parameter.
        You can also specify the conformance of the PDF/A file by specifying the
        `conformance=pdfa-1a` query parameter.
      operationId: download-document-pdf
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
        - $ref: '#/components/parameters/DocumentType'
        - $ref: '#/components/parameters/Source'
        - $ref: '#/components/parameters/Flatten'
        - $ref: '#/components/parameters/RenderAPStreams'
        - $ref: '#/components/parameters/Annotations'
        - $ref: '#/components/parameters/Comments'
        - $ref: '#/components/parameters/Optimize'
        - $ref: '#/components/parameters/Conformance'
        - $ref: '#/components/parameters/KeepSignatures'
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: |
            One or more of the provided request parameters are invalid, e.g. both `flatten`
            and `source` were provided at the same time.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}&keep_signatures={boolean_value}' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}&keep_signatures={boolean_value}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}&keep_signatures={boolean_value}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}&keep_signatures={boolean_value}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}&keep_signatures={boolean_value}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Download the Document as a PDF
      description: This operation downloads the latest version of the document as a PDF file.
      operationId: download-document-pdf-post
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DownloadPDF'
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: |
            Provided parameters in the request json are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/pdf \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"type":"pdfa","source":true,"flatten":true,"render_ap_streams":true,"annotations":true,"comments":true,"keep_signatures":true,"conformance":"pdfa-1a","optimize":{"grayscaleText":false,"grayscaleGraphics":false,"grayscaleImages":false,"grayscaleFormFields":false,"grayscaleAnnotations":false,"disableImages":false,"mrcCompression":false,"imageOptimizationQuality":2,"linearize":false}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pdf",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              type: 'pdfa',
              source: true,
              flatten: true,
              render_ap_streams: true,
              annotations: true,
              comments: true,
              keep_signatures: true,
              conformance: 'pdfa-1a',
              optimize: {
                grayscaleText: false,
                grayscaleGraphics: false,
                grayscaleImages: false,
                grayscaleFormFields: false,
                grayscaleAnnotations: false,
                disableImages: false,
                mrcCompression: false,
                imageOptimizationQuality: 2,
                linearize: false
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"keep_signatures\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pdf")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pdf");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"keep_signatures\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"keep_signatures\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/pdf", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/document.xfdf:
    get:
      summary: Export Annotations as an XFDF
      operationId: get-document-xfdf
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the XFDF file.
          content:
            application/vnd.adobe.xfdf:
              schema:
                type: string
                example: <XFDF data>
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/document.xfdf \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/document.xfdf",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/document.xfdf")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/document.xfdf");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/document.xfdf", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/document.json:
    get:
      summary: Export Records as an Instant JSON
      description: |-
        Use this endpoint to export a document's records as an Instant JSON file. This includes annotations,
        form field, form field values and bookmarks.

        This API allows to optionally specify the Instant JSON schema version for the annotations, controlled
        via `annotation_version` query parameter. The value of `annotation_version` can be any valid
        positive integer version. If the `annotation_version` parameter is not mentioned, or is
        invalid, the latest version of Instant JSON schema will be exported.
      operationId: get-document-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
        - name: annotation_version
          in: query
          required: false
          description: The version of Instant JSON schema that should be exported for annotations.
          schema:
            type: integer
            enum:
              - 1
              - 2
      responses:
        '200':
          description: Document Engine returned the Instant JSON file.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InstantJson'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/document.json?annotation_version=SOME_INTEGER_VALUE' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/document.json?annotation_version=SOME_INTEGER_VALUE",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/document.json?annotation_version=SOME_INTEGER_VALUE")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/document.json?annotation_version=SOME_INTEGER_VALUE");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/document.json?annotation_version=SOME_INTEGER_VALUE", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/apply_instant_json:
    post:
      summary: Apply an Instant JSON to Document
      operationId: document-apply-instant-json
      description: |-
        To import an Instant JSON file and apply it to an existing document, you can POST a `multipart/form`
        request including an `instant.json` file. This will modify the default layer of the document in place.
        In case of success, the endpoint will respond with an empty JSON object.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
      responses:
        '200':
          description: The Instant JSON has been applied successfully.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/apply_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'instant.json={"format":"https://pspdfkit.com/instant-json/v1","annotations":[{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"}],"attachments":{"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b":{"binary":"YXR0YWNobWVudCBjb250ZW50cwo=","contentType":"image/png"},"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b":{"binary":"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==","contentType":"plain/text"}},"formFields":[{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}],"formFieldValues":[{"name":"string","value":"string","type":"pspdfkit/form-field-value","v":1,"optionIndexes":[0],"isFitting":false}],"bookmarks":[{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"}],"skippedPdfObjectIds":[0],"pdfId":{"permanent":"9C3nLxNzQBuBBzv96LbdMg==","changing":"Oi+XccZpDHChV7I="}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/apply_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/apply_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/apply_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/documents/{documentId}/apply_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pdf_with_instant_json:
    post:
      summary: Download a Document with Instant JSON
      description: |-
        To import an Instant JSON file and download the resulting PDF, you can
        `POST` a `multipart/form` request including an `instant.json` file.

        This will create a new PDF containing the latest annotations of the
        chosen layer, import the uploaded Instant JSON, and respond with the
        resulting PDF. Please note that this action will not modify the
        existing document, but rather only import the Instant JSON on a
        temporary file that will be downloaded in the process.
      operationId: download-document-with-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/pdf_with_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'instant.json={"format":"https://pspdfkit.com/instant-json/v1","annotations":[{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"}],"attachments":{"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b":{"binary":"YXR0YWNobWVudCBjb250ZW50cwo=","contentType":"image/png"},"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b":{"binary":"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==","contentType":"plain/text"}},"formFields":[{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}],"formFieldValues":[{"name":"string","value":"string","type":"pspdfkit/form-field-value","v":1,"optionIndexes":[0],"isFitting":false}],"bookmarks":[{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"}],"skippedPdfObjectIds":[0],"pdfId":{"permanent":"9C3nLxNzQBuBBzv96LbdMg==","changing":"Oi+XccZpDHChV7I="}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pdf_with_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pdf_with_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pdf_with_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/documents/{documentId}/pdf_with_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/copy_with_instant_json:
    post:
      summary: Copy a Default Layer With Instant JSON
      description: |-
        This will create a new PDF containing the latest annotations of the default/base layer, optionally
        import the uploaded Instant JSON, and persist the resulting PDF as a new document.

        If the content type of the request is `multipart/form-data`, the document with its default layer
        will be copied, and uploaded `instant.json` file will be imported into the default layer.

        If the content type is `application/json`, the request body is ignored and the document is copied
        as-is, without any modifications to the default layer.
      operationId: copy-document-with-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
          application/json:
            schema:
              type:
                - object
                - 'null'
      responses:
        '200':
          description: The document has been copied successfully.
          content:
            application/json:
              schema:
                type: object
                required:
                  - createdAt
                  - documentId
                  - errors
                  - password_protected
                  - sourcePdfSha256
                  - title
                properties:
                  createdAt:
                    $ref: '#/components/schemas/IsoDateTime'
                  documentId:
                    $ref: '#/components/schemas/DocumentId'
                  errors:
                    $ref: '#/components/schemas/Errors'
                  password_protected:
                    $ref: '#/components/schemas/PasswordProtected'
                  sourcePdfSha256:
                    $ref: '#/components/schemas/SourcePdfSha256'
                  title:
                    $ref: '#/components/schemas/Title'
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Import and Export
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/copy_with_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/copy_with_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/copy_with_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/copy_with_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/copy_with_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/bookmarks:
    get:
      summary: Fetch Bookmarks
      operationId: get-document-bookmarks
      description: Fetches all bookmarks in a given document.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The bookmarks included in the document
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      bookmarks:
                        type: array
                        items:
                          $ref: '#/components/schemas/BookmarkRecord'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/bookmarks \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/bookmarks",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/bookmarks")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/bookmarks");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/bookmarks", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create a Bookmark
      description: |-
        Bookmarks can be created with and without specifying the ID for the bookmark. When no ID is specified,
        Nutrient Document Engine will assign a random ID to the bookmark. If you want to rely on a specific ID being the
        ID of the created bookmark, the ID can be set with the `id` property in the JSON payload.
        This is useful if you, for example, want a bookmark with the same ID in multiple documents.
      operationId: create-document-bookmark
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BookmarkRecord'
      responses:
        '200':
          description: The newly created bookmark ID
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      id:
                        type: string
                    required:
                      - id
        '400':
          description: Invalid bookmark params
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/bookmarks \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"},"createdBy":"string","updatedBy":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/bookmarks",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                name: 'string',
                type: 'pspdfkit/bookmark',
                v: 1,
                action: {type: 'goTo', pageIndex: 0},
                pdfBookmarkId: 'string'
              },
              createdBy: 'string',
              updatedBy: 'string',
              id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/bookmarks")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/bookmarks");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/bookmarks", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/bookmarks/{bookmarkId}:
    put:
      summary: Update a Bookmark
      operationId: update-document-bookmark
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/BookmarkId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BookmarkRecord'
      responses:
        '200':
          description: Update was successful.
        '400':
          description: Invalid update request. See body for reason.
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"},"createdBy":"string","updatedBy":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/bookmarks/{bookmarkId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                name: 'string',
                type: 'pspdfkit/bookmark',
                v: 1,
                action: {type: 'goTo', pageIndex: 0},
                pdfBookmarkId: 'string'
              },
              createdBy: 'string',
              updatedBy: 'string',
              id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId}")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId}");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/bookmarks/{bookmarkId}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete a Bookmark
      operationId: delete-document-bookmark
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/BookmarkId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Delete was successful.
        '400':
          description: Invalid update request. See body for reason.
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/bookmarks/{bookmarkId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId}")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/bookmarks/{bookmarkId}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/bookmarks/{bookmarkId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/embedded-files:
    get:
      summary: Fetch Embedded Files
      description: |-
        Returned records describe files that are attached to a document.

        Use attachments API to retrieve the actual file contents.
      operationId: get-document-embedded-files
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The embedded files included in the document
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      embeddedFiles:
                        type: array
                        items:
                          $ref: '#/components/schemas/EmbeddedFile'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Embedded files
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/embedded-files \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/embedded-files",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/embedded-files")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/embedded-files");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/embedded-files", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/annotations:
    get:
      summary: Get Annotations
      description: |-
        You can use this endpoint to fetch all annotations from the document's default layer.

        If `Accept: application/json` header is used, only the first 1000 annotations
        from the page will be returned. If the page has more than 1000 annotations,
        the `truncated` property in the response is set to `true`.

        In order to consume greater number of annotations in a controlled manner, use `application/x-ndjson`
        as accepted content type. When `Accept: application/x-ndjson` header is used, the response will be
        returned as [Newline delimited JSON](http://ndjson.org/), allowing the client to process annotations
        individually or in batches before the complete response body has been received.
      operationId: get-document-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned document's first 1000 annotations or a stream of all the document's
            annotations.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
                      truncated:
                        type: boolean
                        description: |
                          Indicates whether the returned annotations are not all of the document's
                          annotations.
            application/x-ndjson:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/annotations", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Annotations
      description: |-
        This endpoint allows you to add one or more new annotations to a document's default layer.

        The endpoint accepts two content types:
        - `application/json` - in this case, the request body is a JSON representation of
          one or more annotation; you can check the schema for more details.
        - `multipart/form-data` - with multipart request, annotation(s) can be uploaded along
          with a new attachment. Annotations are one part of the request, followed by
          attachments.

        The annotation `id` is optional, and will be generated by Document Engine if not provided.
        The `user_id` is set as the creator of the annotation.
      operationId: create-document-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        description: One or more annotations to create.
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/AnnotationCreateSingle'
                - $ref: '#/components/schemas/AnnotationCreateMultiple'
          multipart/form-data:
            schema:
              oneOf:
                - $ref: '#/components/schemas/AnnotationCreateSingleWithAttachment'
                - $ref: '#/components/schemas/AnnotationCreateMultipleWithAttachment'
      responses:
        '200':
          description: Annotation(s) created
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/AnnotationMultipleResponse'
                  - type: object
                    description: Single annotation created successfully.
                    title: SingleAnnotationResponse
                    properties:
                      data:
                        type: object
                        properties:
                          annotation_id:
                            $ref: '#/components/schemas/AnnotationId'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                v: 2,
                type: 'pspdfkit/markup/highlight',
                pageIndex: 0,
                bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                action: {type: 'goTo', pageIndex: 0},
                opacity: 1,
                pdfObjectId: 0,
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                flags: ['noPrint'],
                createdAt: '2019-09-16T15:05:03.712909Z',
                updatedAt: '2019-09-16T15:05:03.712909Z',
                name: 'string',
                creatorName: 'string',
                customData: {foo: 'bar'},
                rects: [[100, 200, 300, 400]],
                blendMode: 'normal',
                color: '#fcee7c',
                note: 'string'
              },
              user_id: 'string',
              group: 'string',
              id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Annotations
      description: |-
        This endpoint allows you to update multiple annotations in the document's default layer.

        The annotation's content will be completely replaced with the `content` provided in
        the request, and its `updatedBy` field will be set to `user_id`.

        The endpoint accepts two content types:
        - `application/json` - in this case, the request body is a JSON representation of
          one or more annotation; you can check the schema for more details.
        - `multipart/form-data` - with multipart request, annotation(s) can be uploaded along
          with a new attachment. Annotations are one part of the request, followed by
          attachments.

        The annotation `id` is required, and it should correspond to an already existing annotation
        in the document. The `user_id` is set as the creator of the annotation.
      operationId: update-document-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        description: Multiple annotations to update.
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AnnotationUpdateMultiple'
          multipart/form-data:
            schema:
              type: object
              properties:
                annotations:
                  $ref: '#/components/schemas/AnnotationUpdateMultiple'
              additionalProperties:
                $ref: '#/components/schemas/AttachmentContent'
      responses:
        '200':
          description: Annotation(s) updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AnnotationMultipleResponse'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotations":[{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"replace_this_with_an_actual_annotation_id"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              annotations: [
                {
                  content: {
                    v: 2,
                    type: 'pspdfkit/markup/highlight',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    rects: [[100, 200, 300, 400]],
                    blendMode: 'normal',
                    color: '#fcee7c',
                    note: 'string'
                  },
                  user_id: 'string',
                  group: 'string',
                  id: 'replace_this_with_an_actual_annotation_id'
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Annotations
      description: |-
        This endpoint allows you to remove multiple annotations from the document's default layer.

        The endpoint accepts one content type `application/json`. The request body is either a JSON
        array of annotations ids, or "all" in order to remove all annotations in one go.
      operationId: remove-document-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeleteAnnotations'
      responses:
        '200':
          description: The annotations have been deleted from the document.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotationIds":"all"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({annotationIds: 'all'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotationIds\":\"all\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotationIds\":\"all\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotationIds\":\"all\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/pages/{pageIndex}/annotations:
    get:
      summary: Fetch Annotations on a Page
      description: |-
        You can use this endpoint to fetch annotations on the given page from the document's
        default layer.

        If `Accept: application/json` header is used, only the first 1000 annotations
        from the page will be returned. If the page has more than 1000 annotations,
        the `truncated` property in the response is set to `true`.

        In order to consume greater number of annotations in a controlled manner, use `application/x-ndjson`
        as accepted content type. When `Accept: application/x-ndjson` header is used, the response will be
        returned as [Newline delimited JSON](http://ndjson.org/), allowing the client to process annotations
        individually or in batches before the complete response body has been received.
      operationId: get-document-page-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine responded with first 1000 annotation, or a stream of annotations,
            from the given page.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
                      truncated:
                        type: boolean
                        description: |
                          Indicates whether the returned annotations are not all of the document's
                          annotations.
            application/x-ndjson:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The document or the page doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/pages/{pageIndex}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/annotations")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/pages/{pageIndex}/annotations");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/pages/{pageIndex}/annotations", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/annotations/{annotationId}:
    get:
      summary: Get Annotation
      description: Use this endpoint to get the annotation from the document's default layer.
      operationId: get-document-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with the annotation.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/annotations/{annotationId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update an Annotation
      description: |-
        This endpoint allows you to update an annotation in the document's default layer.

        The annotation's content will be completely replaced with the `content` provided in
        the request, and its `updatedBy` field will be set to `user_id`.
      operationId: update-document-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AnnotationUpdate'
      responses:
        '200':
          description: The annotation has been updated.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"replace_this_with_an_actual_annotation_id"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                v: 2,
                type: 'pspdfkit/markup/highlight',
                pageIndex: 0,
                bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                action: {type: 'goTo', pageIndex: 0},
                opacity: 1,
                pdfObjectId: 0,
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                flags: ['noPrint'],
                createdAt: '2019-09-16T15:05:03.712909Z',
                updatedAt: '2019-09-16T15:05:03.712909Z',
                name: 'string',
                creatorName: 'string',
                customData: {foo: 'bar'},
                rects: [[100, 200, 300, 400]],
                blendMode: 'normal',
                color: '#fcee7c',
                note: 'string'
              },
              user_id: 'string',
              group: 'string',
              id: 'replace_this_with_an_actual_annotation_id'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/annotations/{annotationId}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete an Annotation
      description: This endpoint allows you to delete an annotation in the document's default layer.
      operationId: delete-document-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The annotation has been deleted.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/annotations/{annotationId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/form-field-values:
    get:
      summary: Get Form Field Values
      operationId: get-document-form-field-values
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The document form field values
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      formFieldValues:
                        $ref: '#/components/schemas/FormFieldValuesRecords'
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Form Filling
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/form-field-values \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-values",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-values")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-values");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/form-field-values", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Update Form Field Values
      operationId: update-document-form-field-values
      description: To update existing form field values, send a POST request with a JSON body containing the list of form fields and their values.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/FormFieldValueUpdate'
      responses:
        '200':
          description: Form field values correctly updated.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
        '422':
          description: One or more of the request parameters were invalid.
      tags:
        - Form Filling
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/form-field-values \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldValues":[{"name":"string","value":"string"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-values",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({formFieldValues: [{name: 'string', value: 'string'}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-values")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-values");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/form-field-values", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/sign:
    post:
      summary: Digitally Sign a PDF File
      description: |-
        Use this endpoint to digitally sign a PDF file.

        ### Signing Service

        The actual signing of the file is performed by a signing service callback that needs to be maintained
        and operated separately. It needs to expose a single HTTP endpoint that receives all callbacks required
        during the document signing flow differentiated by an `action` property in the request's JSON.

        URL of the signing service needs to be configured via `SIGNING_SERVICE_URL` environment variable.
      operationId: sign-file
      parameters:
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
                  description: The binary content of a PDF file.
                  example: <PDF data>
                data:
                  $ref: '#/components/schemas/DigitalSignatureCreate'
                image:
                  type: string
                  format: binary
                  description: The watermark image to be used as part of the signature's appearance
                  example: <Image data>
                graphicImage:
                  type: string
                  format: binary
                  description: The graphic image to be used as part of the signature's appearance
                  example: <Image data>
            encoding:
              file:
                contentType: application/pdf
              image:
                contentType: application/pdf, image/jpg, image/png, image/tiff
              graphicImage:
                contentType: application/pdf, image/jpg, image/png, image/tiff
              data:
                contentType: application/json
      callbacks:
        SigningService:
          $ref: '#/components/callbacks/signing-service'
      responses:
        '200':
          description: The signed document.
          content:
            application/pdf:
              schema:
                type: string
                description: The signed PDF file.
                format: binary
                example: <PDF file>
        '400':
          description: |
            Malformed request.

            If the underlying signing service returns an error in the 4xx range,
            the endpoint will respond with a 400 response. Please check the Nutrient Document Engine logs
            for more information about the nature of the error.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/sign \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'file=<PDF data>' \
              --form 'data={"signatureType":"cades","flatten":false,"appearance":{"mode":"signatureOnly","contentType":"image/png","showSigner":true,"showReason":true,"showLocation":true,"showWatermark":true,"showSignDate":true},"position":{"pageIndex":0,"rect":[0,0,100,100]},"signatureMetadata":{"signerName":"John Appleseed","signatureReason":"accepted","signatureLocation":"Vienna"},"cadesLevel":"b-lt","signatureContainer":"raw","signingToken":"user-1-with-rights"}' \
              --form 'image=<Image data>' \
              --form 'graphicImage=<Image data>'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/sign",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"data\"\r\n\r\n{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"image\"\r\n\r\n<Image data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"graphicImage\"\r\n\r\n<Image data>\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"data\"\r\n\r\n{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"image\"\r\n\r\n<Image data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"graphicImage\"\r\n\r\n<Image data>\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/sign")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/sign");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"data\"\r\n\r\n{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"image\"\r\n\r\n<Image data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"graphicImage\"\r\n\r\n<Image data>\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"data\"\r\n\r\n{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"image\"\r\n\r\n<Image data>\r\n-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"graphicImage\"\r\n\r\n<Image data>\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/sign", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/inspect_signatures:
    post:
      summary: Inspect Digital Signatures in a PDF file
      description: |-
        Returns PDF file's digital signatures.

        A document's digital signature status is computed by looking at all the digital signatures
        included in the document

        The validity of a signature is determined by the signing certificate used to create it: If you're using a
        custom certificate, you need to set up Document Engine to use a corresponding certificate store in order to
        identify the signature as valid. Please check our
        [guide article](https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/validation/#providing-trusted-root-certificates)
        on how to set up custom certificates for digital signature validation.
      operationId: inspect-digital-signatures
      parameters:
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/pdf:
            schema:
              type: string
              format: binary
              description: The binary content of the PDF file.
              example: <PDF data>
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
                  description: The binary content of a PDF file.
                  example: <PDF data>
            encoding:
              file:
                contentType: application/pdf
      responses:
        '200':
          description: The document's digital signatures
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignatures'
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/inspect_signatures \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'file=<PDF data>'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/inspect_signatures",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/inspect_signatures")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/inspect_signatures");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\n<PDF data>\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/inspect_signatures", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/sign:
    post:
      summary: Digitally Sign a Document
      description: |-
        Use this endpoint to digitally sign a document.

        ### Signing Service

        The actual signing of the current state of the document is performed by a signing service callback
        that needs to be maintained and operated separately. It needs to expose a single HTTP endpoint
        that receives all callbacks required during the document signing flow differentiated by an `action`
        property in the request's JSON.

        URL of the signing service needs to be configured via `SIGNING_SERVICE_URL` environment variable.

        ### Watermark and Graphic

        The appearance of a digital signature can include a watermark, which is an image typically depicting a company logo or stamp placed in the center, and a graphic, which is an image usually containing the signer's name in the form of a handwritten signature image positioned on the left side of the signature. You can find more information about these different signature appearance options at https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/configure-digital-signature-appearance/.

        To specify the image to be used as the watermark or graphic in the digital signature, send a multipart request
        with the `application/json` part containing the sign request options and the `image` part containing the watermark image, and the `graphicImage` part containing the graphic.
      operationId: sign-document
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DigitalSignatureCreate'
          multipart/form-data:
            schema:
              type: object
              properties:
                image:
                  type: string
                  format: binary
                  description: The watermark image to be used as part of the signature's appearance
                  example: <Image data>
                graphicImage:
                  type: string
                  format: binary
                  description: The graphic image to be used as part of the signature's appearance
                  example: <Image data>
                data:
                  $ref: '#/components/schemas/DigitalSignatureCreate'
            encoding:
              image:
                contentType: application/pdf, image/jpg, image/png, image/tiff
              graphicImage:
                contentType: application/pdf, image/jpg, image/png, image/tiff
              data:
                contentType: application/json
      callbacks:
        SigningService:
          $ref: '#/components/callbacks/signing-service'
      responses:
        '200':
          description: The newly created document digital signature.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      signature:
                        $ref: '#/components/schemas/DigitalSignature'
        '400':
          description: |
            Malformed request.

            If the underlying signing service returns an error in the 4xx range,
            the endpoint will respond with a 400 response. Please check the Nutrient Document Engine logs
            for more information about the nature of the error.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/sign \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"signatureType":"cades","flatten":false,"appearance":{"mode":"signatureOnly","contentType":"image/png","showSigner":true,"showReason":true,"showLocation":true,"showWatermark":true,"showSignDate":true},"position":{"pageIndex":0,"rect":[0,0,100,100]},"signatureMetadata":{"signerName":"John Appleseed","signatureReason":"accepted","signatureLocation":"Vienna"},"cadesLevel":"b-lt","signatureContainer":"raw","signingToken":"user-1-with-rights"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/sign",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              signatureType: 'cades',
              flatten: false,
              appearance: {
                mode: 'signatureOnly',
                contentType: 'image/png',
                showSigner: true,
                showReason: true,
                showLocation: true,
                showWatermark: true,
                showSignDate: true
              },
              position: {pageIndex: 0, rect: [0, 0, 100, 100]},
              signatureMetadata: {
                signerName: 'John Appleseed',
                signatureReason: 'accepted',
                signatureLocation: 'Vienna'
              },
              cadesLevel: 'b-lt',
              signatureContainer: 'raw',
              signingToken: 'user-1-with-rights'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/sign")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/sign");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/sign", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/refresh_ltv:
    post:
      summary: Refresh signatures on a document
      description: |-
        Use this endpoint to refresh LTV signatures for the given document.

        Learn more about CAdES and LTV signatures here:
        https://www.nutrient.io/guides/web/signatures/digital-signatures/standards/#understanding-ltv-pades-b-lt

        It will refresh the signatures with IDs provided in the `signatureFQNs` field.
        If `signatureFQNs` is not set, or empty, then all the signatures in the document will be refreshed.
      operationId: refresh-document-signatures
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RefreshDigitalSignatures'
      responses:
        '200':
          description: The updated digital signatures for the document.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignature'
        '400':
          description: |
            Malformed request.

            If the underlying signing service returns an error in the 4xx range,
            the endpoint will respond with a 400 response. Please check the Nutrient Document Engine logs
            for more information about the nature of the error.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/refresh_ltv \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"signatureFQNs":["Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85"]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/refresh_ltv",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({signatureFQNs: ['Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85']}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/refresh_ltv")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/refresh_ltv");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/refresh_ltv", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/signatures:
    get:
      summary: Get Digital Signatures
      description: |-
        Returns a document's digital signatures.

        A document's digital signature status is computed by looking at all the digital signatures
        included in the document. Digital signature status is automatically updated after each change
        (e.g. adding a new annotation).

        The validity of a signature is determined by the signing certificate used to create it: If you're using a
        custom certificate, you need to set up Nutrient Document Engine to use a corresponding certificate store in order to
        identify the signature as valid. Please check our
        [guide article](https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/validation/#providing-trusted-root-certificates)
        on how to set up custom certificates for digital signature validation.

        By default, the signature certificates are validated against the current time. This means that valid signatures
        with expired certificates validate as expired. You can modify the `DIGITAL_SIGNATURE_CERTIFICATE_CHECK_TIME`
        configuration option to `signing_time` if you wish to instead validate certificates against the signing time.

        > ⚠ Warning: If you're validating digital signature certificates against the signing time, special care should be
        taken: By default, there's no way of knowing whether the creation time stored with the signature itself can be trusted.
        To solve this issue, digital signatures need to use a Time Stamping Authority to provide a signed timestamp to embed.
        Note that we don't validate the timestamp token's certificates — we always assume a valid proof of existence if it's present.
        Thus, it's expected that the timestamps will be validated independently by your client code.
      operationId: get-document-digital-signatures
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The document's digital signatures
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignatures'
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/signatures \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/signatures",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/signatures")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/signatures");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/signatures", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/annotations/{annotationId}/comments:
    get:
      summary: Get Comments For a Root Annotation
      description: Use this endpoint to list all the annotation attached to the given annotation in the document's default layer.
      operationId: fetch-document-annotation-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with comments
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsList'
        '400':
          description: The annotation is neither markup annotation nor comment marker.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations/{annotationId}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/annotations/{annotationId}/comments", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Add Comments to a Root Annotation
      description: |-
        Use this endpoint to add new comments to an existing annotation in the document's default layer.
        Note that the annotation needs to be either a markup annotation or a comment marker.
        The `id` and `createdAt` properties of the comment are autogenerated by Document Engine if they are not provided.
      operationId: create-document-annotation-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommentsCreate'
      responses:
        '200':
          description: The comments have been added to the annotation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreated'
        '400':
          description: The annotation is neither markup annotation nor comment marker.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation, the layer, or the document doesn't exist.
        '422':
          description: One or mote of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreateErrors'
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"comments":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"text":"What a wonderful idea!","createdAt":"2019-11-14T15:05:03.089Z","updatedAt":"2019-11-22T18:05:03.712Z","customData":{},"creatorName":"John Doe"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/annotations/{annotationId}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              comments: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    text: 'What a wonderful idea!',
                    createdAt: '2019-11-14T15:05:03.089Z',
                    updatedAt: '2019-11-22T18:05:03.712Z',
                    customData: {},
                    creatorName: 'John Doe'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/annotations/{annotationId}/comments");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/annotations/{annotationId}/comments", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/comments:
    post:
      summary: Adds Comments
      description: |-
        Use this endpoint to add comments and their root annotation at the same time.

        Note that the annotation needs to be either a markup annotation or a comment marker.

        The `id` and `createdAt` properties of the comment are autogenerated by Document Engine
        if they are not provided.
      operationId: create-document-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommentsCreateWithRoot'
      responses:
        '200':
          description: The comments have been added to the annotation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreatedWithRoot'
        '401':
          description: You are unauthorized.
        '404':
          description: The document doesn't exist.
        '422':
          description: One or mote of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreateErrorsWithRoot'
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotation":{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"},"comments":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"text":"What a wonderful idea!","createdAt":"2019-11-14T15:05:03.089Z","updatedAt":"2019-11-22T18:05:03.712Z","customData":{},"creatorName":"John Doe"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              annotation: {
                content: {
                  v: 2,
                  type: 'pspdfkit/markup/highlight',
                  pageIndex: 0,
                  bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                  action: {type: 'goTo', pageIndex: 0},
                  opacity: 1,
                  pdfObjectId: 0,
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  flags: ['noPrint'],
                  createdAt: '2019-09-16T15:05:03.712909Z',
                  updatedAt: '2019-09-16T15:05:03.712909Z',
                  name: 'string',
                  creatorName: 'string',
                  customData: {foo: 'bar'},
                  rects: [[100, 200, 300, 400]],
                  blendMode: 'normal',
                  color: '#fcee7c',
                  note: 'string'
                },
                user_id: 'string',
                group: 'string',
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
              },
              comments: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    text: 'What a wonderful idea!',
                    createdAt: '2019-11-14T15:05:03.089Z',
                    updatedAt: '2019-11-22T18:05:03.712Z',
                    customData: {},
                    creatorName: 'John Doe'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/comments")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/comments");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/comments", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/redactions:
    post:
      summary: Create Redactions
      description: |-
        Use this endpoint to add multiple redaction annotations in a single request.

        Available strategies are:

        - `preset` - creates redactions on top of text and annotations matching the predefined
          pattern. For the full list of presets, see the request schema.
        - `regex` - creates redactions on top of text and annotations matching the provided
          regular expression. The regular expressions needs to comply with the
          [ICU regex standard](http://userguide.icu-project.org/strings/regexp).
        - `text` - creates redactions on top of text and annotations matching the provided string
          search term. Note that the search is case-insensitive.

        The shape of the `strategyOptions` depends on the chosen strategy. Currently each
        strategy supports the `includeAnnotations` options (`true` by default), which controls
        whether redactions should also cover annotations whose content match the search query.

        The `user_id` key allows to specify the owner of the newly created annotations,
        and `content` allows to override their visual properties.

        On success, an array of created redaction annotations is returned.
      operationId: create-document-redactions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateRedactions'
      responses:
        '200':
          description: The redaction annotations have been added to the layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The document doesn't exist.
        '422':
          description: One or more of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateRedactionsErrors'
      tags:
        - Redaction
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/redactions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"strategy":"preset","strategyOptions":{"preset":"email-address","includeAnnotations":true,"start":0,"limit":null},"user_id":"string","content":{"v":2,"type":"pspdfkit/markup/redaction","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"outlineColor":"#ffffff","fillColor":"string","overlayText":"string","repeatOverlayText":"string","color":"#ffffff","rotation":0,"note":"string"}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/redactions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              strategy: 'preset',
              strategyOptions: {preset: 'email-address', includeAnnotations: true, start: 0, limit: null},
              user_id: 'string',
              content: {
                v: 2,
                type: 'pspdfkit/markup/redaction',
                pageIndex: 0,
                bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                action: {type: 'goTo', pageIndex: 0},
                opacity: 1,
                pdfObjectId: 0,
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                flags: ['noPrint'],
                createdAt: '2019-09-16T15:05:03.712909Z',
                updatedAt: '2019-09-16T15:05:03.712909Z',
                name: 'string',
                creatorName: 'string',
                customData: {foo: 'bar'},
                rects: [[100, 200, 300, 400]],
                outlineColor: '#ffffff',
                fillColor: 'string',
                overlayText: 'string',
                repeatOverlayText: 'string',
                color: '#ffffff',
                rotation: 0,
                note: 'string'
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/redactions")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/redactions");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/redactions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/redact:
    post:
      summary: Apply Redactions
      description: |-
        Use this endpoint to apply existing redaction annotation to the default layer, erasing
        any content and annotations below them.

        Applying redactions removes the existing redaction annotations and rewrites the underlying
        PDF file.

        Note that regardless of applied redactions, the content and annotations from the originally
        uploaded file are always stored at the document's immutable base layer.
        In some circumstances, e.g. due to legal requirements, this may be undesirable.
        In these cases, you can delete the document after applying redactions, which will erase
        all of the document's data.
      operationId: apply-document-redactions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Redactions have been successfully applied.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentProperties'
        '401':
          description: You are unauthorized.
        '404':
          description: The document doesn't exist.
      tags:
        - Redaction
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/redact \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/redact",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/redact")
              .post(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/redact");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("POST", "/api/documents/{documentId}/redact", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/attachments/{attachmentId}:
    get:
      summary: Get Attachment
      description: |-
        Attachments are files that are attached to a document.

        This endpoint provides a way to fetch an attachment's contents.
      operationId: get-document-attachment
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/AttachmentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The attachment for the document
          content:
            image/png:
              schema:
                type: string
                format: binary
                description: The binary content of the image file.
                example: <PNG data>
            image/jpg:
              schema:
                type: string
                format: binary
                description: The binary content of the image file.
                example: <JPEG data>
        '401':
          description: Unauthorized
        '404':
          description: Attachment not found
      tags:
        - Attachments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/attachments/{attachmentId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/attachments/{attachmentId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/attachments/{attachmentId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/attachments/{attachmentId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/attachments/{attachmentId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/form-fields:
    get:
      summary: Get Form Fields
      description: You can use this endpoint to fetch all form fields from the document's default layer.
      operationId: get-document-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned document's form fields
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FormFieldWithWidgets'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-fields")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-fields");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/form-fields", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Form Fields
      description: |-
        This endpoint allows you to add a new form field to the document's default layer.

        The `id` of each form field is optional, and will be generated by Document Engine if not provided.
        The `user_id` is set as the creator of the form field. The `group` of the form field will be inherited by the widgets and values associated with it.
      operationId: create-document-form-field
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFields
              properties:
                formFields:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldCreate'
      responses:
        '200':
          description: The form fields have been added to the document.
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
                        description: An array of the IDs for the newly created form fields
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFields":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFields: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    v: 1,
                    type: 'pspdfkit/form-field/button',
                    id: '7KPSXX1NMNJ2WFDKN7BKQK9KZ',
                    name: 'Form-Field',
                    label: 'Form Field',
                    annotationIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '7KPS6T4DKYN71VB7G5KBGB5R51'],
                    pdfObjectId: 0,
                    flags: ['required'],
                    buttonLabel: 'string'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-fields")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-fields");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Form Fields
      description: |-
        This endpoint allows you to update an existing form field in the document's default layer

        The `id` is required. If you provide the `group` in this operation
        then the new group will cascade to all the widgets and values associated with this field.
      operationId: update-document-form-field
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFields
              properties:
                formFields:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldUpdate'
      responses:
        '200':
          description: The form fields have been updated
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
                        description: An array of IDs for the form fields that were updated successfully.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFields":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFields: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    v: 1,
                    type: 'pspdfkit/form-field/button',
                    id: '7KPSXX1NMNJ2WFDKN7BKQK9KZ',
                    name: 'Form-Field',
                    label: 'Form Field',
                    annotationIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '7KPS6T4DKYN71VB7G5KBGB5R51'],
                    pdfObjectId: 0,
                    flags: ['required'],
                    buttonLabel: 'string'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-fields")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-fields");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Form Fields
      description: |-
        This endpoint allows you to remove multiple form fields from the document's default layer.

        Deleting a form field will cascade delete all its associated widgets and values.

        The endpoint accepts content type `application/json`. The request body is an object with a field `formFieldIds`
        that is set to either a JSON array of IDs, or "all" in order to remove all form fields in one request.
      operationId: remove-document-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - type: object
                  title: Form Field IDs
                  required:
                    - formFieldIds
                  properties:
                    formFieldIds:
                      type: array
                      items:
                        $ref: '#/components/schemas/RecordId'
                      description: An array of form field IDs
                      example:
                        - 01DNEDPQQ22W49KDXRFPG4EPEQ
                        - 01DNEDPQQ22W49KDXRFPG4EPEM
                    user_id:
                      $ref: '#/components/schemas/User'
                - type: object
                  title: All Form Fields
                  required:
                    - formFieldIds
                  properties:
                    formFieldIds:
                      type: string
                      enum:
                        - all
                    user_id:
                      $ref: '#/components/schemas/User'
      responses:
        '200':
          description: The form field(s) have been deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
                        description: An array of IDs for the form fields that were successfully deleted
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","01DNEDPQQ22W49KDXRFPG4EPEM"],"user_id":"string"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '01DNEDPQQ22W49KDXRFPG4EPEM'],
              user_id: 'string'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-fields")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-fields");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/form-fields/{formFieldId}:
    get:
      summary: Get a Form Field
      description: Use this endpoint to get the form field with the specified ID from the document's default layer.
      operationId: get-document-form-field
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/FormFieldIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with the form field
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FormFieldWithWidgets'
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/form-fields/{formFieldId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-fields/{formFieldId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-fields/{formFieldId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-fields/{formFieldId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/form-fields/{formFieldId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/form-field-widgets:
    get:
      summary: Get Widgets
      description: You can use this endpoint to fetch all widgets from the document's default layer.
      operationId: get-document-form-field-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned document's widgets
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FormFieldWidgetWithFormField'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-widgets")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-widgets");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/form-field-widgets", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Widgets
      description: |-
        This endpoint allows you to add a new widget to the document's default layer.

        The `id` is optional, and will be generated by Document Engine if not provided.
      operationId: create-document-form-field-widget
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFieldWidgets
              properties:
                formFieldWidgets:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldWidgetCreate'
      responses:
        '200':
          description: The widgets have been added to the document.
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgets":[{"id":"7KPSXX1NMNJ2WFDKN7BKQK9KZE","user_id":"string","content":{"v":2,"type":"pspdfkit/widget","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"formFieldName":"First-Name","borderColor":"#ffffff","borderStyle":"solid","borderWidth":0,"font":"Helvetica","fontSize":10,"fontColor":"#ffffff","fontStyle":["bold"],"horizontalAlign":"left","verticalAlign":"top","rotation":0,"backgroundColor":"#000000"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgets: [
                {
                  id: '7KPSXX1NMNJ2WFDKN7BKQK9KZE',
                  user_id: 'string',
                  content: {
                    v: 2,
                    type: 'pspdfkit/widget',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    formFieldName: 'First-Name',
                    borderColor: '#ffffff',
                    borderStyle: 'solid',
                    borderWidth: 0,
                    font: 'Helvetica',
                    fontSize: 10,
                    fontColor: '#ffffff',
                    fontStyle: ['bold'],
                    horizontalAlign: 'left',
                    verticalAlign: 'top',
                    rotation: 0,
                    backgroundColor: '#000000'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-widgets")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-widgets");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Widgets
      description: This endpoint allows you to update an existing widget in the document's default layer
      operationId: update-document-form-field-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFieldWidgets
              properties:
                formFieldWidgets:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldWidgetUpdate'
      responses:
        '200':
          description: The widgets have been updated
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgets":[{"content":{"v":2,"type":"pspdfkit/widget","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"formFieldName":"First-Name","borderColor":"#ffffff","borderStyle":"solid","borderWidth":0,"font":"Helvetica","fontSize":10,"fontColor":"#ffffff","fontStyle":["bold"],"horizontalAlign":"left","verticalAlign":"top","rotation":0,"backgroundColor":"#000000"},"user_id":"string","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZE"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgets: [
                {
                  content: {
                    v: 2,
                    type: 'pspdfkit/widget',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    formFieldName: 'First-Name',
                    borderColor: '#ffffff',
                    borderStyle: 'solid',
                    borderWidth: 0,
                    font: 'Helvetica',
                    fontSize: 10,
                    fontColor: '#ffffff',
                    fontStyle: ['bold'],
                    horizontalAlign: 'left',
                    verticalAlign: 'top',
                    rotation: 0,
                    backgroundColor: '#000000'
                  },
                  user_id: 'string',
                  id: '7KPSXX1NMNJ2WFDKN7BKQK9KZE'
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-widgets")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-widgets");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Widgets
      description: |-
        This endpoint allows you to remove multiple widgets from the document's default layer.

        The endpoint accepts content type `application/json`. The request body is an object that is set to either
        a JSON array of widget ids, or "all" in order to remove all widgets in one go.
      operationId: remove-document-form-field-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - type: object
                  title: Widget IDs
                  required:
                    - formFieldWidgetIds
                  properties:
                    formFieldWidgetIds:
                      type: array
                      items:
                        type: string
                      description: An array of widget IDs
                      example:
                        - 01DNEDPQQ22W49KDXRFPG4EPEQ
                        - 01DNEDPQQ22W49KDXRFPG4EPEM
                    user_id:
                      $ref: '#/components/schemas/User'
                - type: object
                  title: All Widgets
                  required:
                    - formFieldWidgetIds
                  properties:
                    formFieldWidgetIds:
                      type: string
                      enum:
                        - all
                    user_id:
                      $ref: '#/components/schemas/User'
      responses:
        '200':
          description: The widget(s) have been deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        description: An array of IDs for the widgets that were successfully deleted
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgetIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","01DNEDPQQ22W49KDXRFPG4EPEM"],"user_id":"string"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgetIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '01DNEDPQQ22W49KDXRFPG4EPEM'],
              user_id: 'string'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-widgets")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-widgets");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/fonts:
    get:
      summary: Get fonts
      operationId: get-fonts
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            List of fonts used in the document.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FontFile'
        '401':
          description: Unauthorized
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/fonts \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/fonts",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/fonts")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/fonts");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/fonts", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/font_substitutions:
    get:
      summary: Get font substitutions
      operationId: get-font-substitutions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      description: |-
        This endpoint allows you to get font substitutions that were set for the specific document.

        Note that font substitutions returned by this endpoint will include the font substitutions defined for the specified document,
        as well as any font substitutions defined in the `font-substitutions.json` configuration file, if a `font-substitutions.json` file is mounted on Nutrient Document Engine.

        The font substitutions for the document will be merged with the font substitutions in `font-substitutions.json` if any,
        with the substitutions in the document having priority over any substitutions `font-substitutions.json` may define.
        It is this combination of font substitutions that will be applied by Nutrient Document Engine
        when performing operations on the document where a font is unavailable and needs to be substituted.

        Learn more about the `font-substitutions.json` file from the documentation available here:
        https://www.nutrient.io/guides/document-engine/configuration/custom-fonts/#font-substitutions
      responses:
        '200':
          description: |
            List of font substitutions used in the document.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/FontSubstitutionList'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/font_substitutions")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/font_substitutions");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/font_substitutions", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Replaces font substitutions in the document
      tags:
        - Fonts
      description: |-
        This endpoint allows you to replace font substitutions in the document.
        It will delete any existing font substitutions defined for the document and replace them with these new ones

        If no font substitutions existed for the document prior, it will create them.

        **Note that this endpoint does not affect the font substitutions specified in the `font-substitutions.json` configuration file, if any.**
      operationId: update-font-substitutions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        description: |
          List of font substitutions to replace the old ones with.
        content:
          application/json:
            schema:
              type: object
              required:
                - fontSubstitutions
              properties:
                fontSubstitutions:
                  $ref: '#/components/schemas/FontSubstitutionList'
      responses:
        '200':
          description: |
            List of font substitutions that were successfully created to replace the old ones
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        $ref: '#/components/schemas/FontSubstitutionList'
        '400':
          description: Invalid request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BatchOperationResult'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"fontSubstitutions":[{"pattern":"Roboto-*","target":"Courier New"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({fontSubstitutions: [{pattern: 'Roboto-*', target: 'Courier New'}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/font_substitutions")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/font_substitutions");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/font_substitutions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Deletes all font substitutions in the document
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      tags:
        - Fonts
      description: |-
        This endpoint allows you to delete all font substitutions in the document.
        Note that it won't delete other font substitutions that are associated with a different layer.
        To delete the font substitutions in a specific layer, make a request to the specified layer

        Also note that this endpoint does not affect the font substitutions specified in the `font-substitutions.json` configuration file, if any.
      operationId: delete-font-substitutions
      responses:
        '200':
          description: |
            List of font substitutions that were deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        $ref: '#/components/schemas/FontSubstitutionList'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/font_substitutions")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/font_substitutions");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/font_substitutions", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/form-field-widgets/{formFieldWidgetId}:
    get:
      summary: Get a Widget
      description: Use this endpoint to get the widget with the specified ID from the document's default layer.
      operationId: get-document-form-field-widget
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/FormFieldWidgetIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with the widget
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FormFieldWidgetWithFormField'
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/form-field-widgets/{formFieldWidgetId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/form-field-widgets/{formFieldWidgetId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/form-field-widgets/{formFieldWidgetId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/form-field-widgets/{formFieldWidgetId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/form-field-widgets/{formFieldWidgetId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/ocg-layers:
    get:
      summary: Get available OCG layers for the document
      operationId: get-ocg-layers
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: List of the OCG Layers for the document
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OCGLayerResponse'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/ocg-layers \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/ocg-layers",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/ocg-layers")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/ocg-layers");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/ocg-layers", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers:
    get:
      summary: Get Document's Layers
      description: Fetches a list of document's layers.
      operationId: list-layers
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The list of layers for the given document.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      type: string
                      example: my-layer
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create a New Layer
      description: |-
        This endpoint allows you to create a new layer for a document. It supports three modes
        of operation:
        - *create a new layer based on a source layer*: this essentially copies a layer in a document
          to a new layer in the same document
        - *create a new layer based on an Instant JSON file*: this creates a new layer by copying document's
          base layer and applying the provided Instant JSON payload
        - *create a new layer based on a source layer and an Instant JSON file*: the same as above, but instead
          of copying the base layer, the source layer is used

        **NOTE**: When the provided source layer name doesn't exist, the base layer is used instead.

        In case of success, the new layer name is returned along with a list of errors from importing the Instant
        JSON file into the layer.
      operationId: create-new-layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LayerCreateWithSourceLayer'
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/LayerCreateWithSourceLayerAndInstantJson'
            encoding:
              instant.json:
                contentType: application/json
      responses:
        '200':
          description: The new layer has been created.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/LayerCreated'
            multipart/form-data:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/LayerCreated'
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"name":"my-layer","source_layer_name":"my-existing-layer"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({name: 'my-layer', source_layer_name: 'my-existing-layer'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"name\":\"my-layer\",\"source_layer_name\":\"my-existing-layer\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"name\":\"my-layer\",\"source_layer_name\":\"my-existing-layer\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"name\":\"my-layer\",\"source_layer_name\":\"my-existing-layer\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}:
    delete:
      summary: Delete a Layer
      description: This endpoint allows you to delete a layer along with all of its contents.
      operationId: delete-layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
        - $ref: '#/components/parameters/LayerName'
      responses:
        '200':
          description: The layer has been successfully deleted.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pdf:
    get:
      summary: Download the Layer as a PDF
      description: |-
        This operation downloads the latest version of the document with
        annotations for the specified layer as a PDF file.

        For example, you can use this endpoint to download the PDF file generated
        after applying a series of document operations on a given layer.
      operationId: download-document-layer-pdf
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
        - in: query
          name: type
          required: false
          schema:
            type: string
            enum:
              - pdf
              - pdfa
            default: pdf
          description: Use this option to determine the format of the downloaded PDF file
        - in: query
          name: source
          required: false
          schema:
            type: boolean
          description: |-
            If set to `true`, the originally uploaded version of the PDF file will be fetched.
            The remaining properties are mutually exclusive with this property.
        - in: query
          name: flatten
          required: false
          schema:
            type: boolean
          description: |-
            Determines whether a flattened version of the PDF file will be downloaded. If set to `true`,
            the resulting PDF file will have its annotations burned into the document and will have no annotations.
        - in: query
          name: render_ap_streams
          required: false
          schema:
            type: boolean
          description: If set to `true`, the resulting PDF file will have its custom AP streams rendered into the document.
        - in: query
          name: annotations
          required: false
          schema:
            type: boolean
          description: If set to `true`, annotations will be included in the downloaded file.
        - in: query
          name: comments
          required: false
          schema:
            type: boolean
          description: If set to `true`, comments will be included in the downloaded file.
        - in: query
          name: optimize
          required: false
          schema:
            type: object
            properties:
              grayscaleText:
                type: boolean
                default: false
              grayscaleGraphics:
                type: boolean
                default: false
              grayscaleImages:
                type: boolean
                default: false
              grayscaleFormFields:
                type: boolean
                default: false
              grayscaleAnnotations:
                type: boolean
                default: false
              disableImages:
                type: boolean
                default: false
              mrcCompression:
                type: boolean
                default: false
              imageOptimizationQuality:
                type: integer
                default: 2
                minimum: 1
                maximum: 4
              linearize:
                type: boolean
                default: false
                description: |
                  If set to `true`, the resulting PDF file will be linearized.
                  This means that the document will be optimized in a special way that allows it to be loaded faster over the network.
                  You need the `Linearization` feature to be enabled in your Nutrient Document Engine license in order to use this option.
          description: If set, the resulting PDF file will be optimized according to the provided options.
        - in: query
          name: conformance
          required: false
          schema:
            type: string
            enum:
              - pdfa-1a
              - pdfa-1b
              - pdfa-2a
              - pdfa-2u
              - pdfa-2b
              - pdfa-3a
              - pdfa-3u
          description: Specify the conformance level of the PDF/A file. Requires the type parameter to be present and equal to `pdfa`.
      responses:
        '200':
          description: Document Engine responded with the PDF
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: |
            One or more of the provided request parameters are invalid, e.g. both `flatten`
            and `source` were provided at the same time.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pdf?type={string_value}&source={boolean_value}&flatten={boolean_value}&render_ap_streams={boolean_value}&annotations={boolean_value}&comments={boolean_value}&optimize=SOME_OBJECT_VALUE&conformance={string_value}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Download the Layer as a PDF
      description: |-
        This operation downloads the latest version of the document with annotations
        as a PDF file.
      operationId: download-document-layer-pdf-post
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required:
                - type
              properties:
                type:
                  type: string
                  example: pdfa
                  description: The type of output file. Can be pdfa or pdf.
                  enum:
                    - pdf
                    - pdfa
                source:
                  type: boolean
                  description: |
                    If set to `true`, the originally uploaded version of the PDF file will be fetched.
                    The remaining properties are mutually exclusive with this property.
                flatten:
                  type: boolean
                  description: |
                    Determines whether a flattened version of the PDF file will be downloaded. If set to `true`,
                    the resulting PDF file will have its annotations burned into the document and will have no annotations.
                render_ap_streams:
                  type: boolean
                  description: |
                    If set to `true`, the resulting PDF file will have its custom AP streams rendered into the document.
                annotations:
                  type: boolean
                  description: |
                    If set to `true`, annotations will be included in the downloaded file
                comments:
                  type: boolean
                  description: |
                    If set to `true`, comments will be included in the downloaded file.
                conformance:
                  type: string
                  example: pdfa-1a
                  default: pdfa-1b
                  enum:
                    - pdfa-1a
                    - pdfa-1b
                    - pdfa-2a
                    - pdfa-2u
                    - pdfa-2b
                    - pdfa-3a
                    - pdfa-3u
                  description: |
                    The level of conformance of the pdfa file. Defaults to `pdfa-1b` if the type is set to `pdfa` and conformance is not explicitly specified.
                optimize:
                  $ref: '#/components/schemas/OptimizePdf'
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: |
            Provided parameters in the request json are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"type":"pdfa","source":true,"flatten":true,"render_ap_streams":true,"annotations":true,"comments":true,"conformance":"pdfa-1a","optimize":{"grayscaleText":false,"grayscaleGraphics":false,"grayscaleImages":false,"grayscaleFormFields":false,"grayscaleAnnotations":false,"disableImages":false,"mrcCompression":false,"imageOptimizationQuality":2,"linearize":false}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pdf",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              type: 'pdfa',
              source: true,
              flatten: true,
              render_ap_streams: true,
              annotations: true,
              comments: true,
              conformance: 'pdfa-1a',
              optimize: {
                grayscaleText: false,
                grayscaleGraphics: false,
                grayscaleImages: false,
                grayscaleFormFields: false,
                grayscaleAnnotations: false,
                disableImages: false,
                mrcCompression: false,
                imageOptimizationQuality: 2,
                linearize: false
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"type\":\"pdfa\",\"source\":true,\"flatten\":true,\"render_ap_streams\":true,\"annotations\":true,\"comments\":true,\"conformance\":\"pdfa-1a\",\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/pdf", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/annotations:
    get:
      summary: Get Annotations in a Layer
      description: |-
        You can use this endpoint to fetch all annotations from the given layer.

        If `Accept: application/json` header is used, only the first 1000 annotations
        from the page will be returned. If the page has more than 1000 annotations,
        the `truncated` property in the response is set to `true`.

        In order to consume greater number of annotations in a controlled manner, use `application/x-ndjson`
        as accepted content type. When `Accept: application/x-ndjson` header is used, the response will be
        returned as [Newline delimited JSON](http://ndjson.org/), allowing the client to process annotations
        individually or in batches before the complete response body has been received.
      operationId: get-document-layer-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned layers's first 1000 annotations or a stream of all the document's
            annotations.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
                      truncated:
                        type: boolean
                        description: |
                          Indicates whether the returned annotations are not all of the document's
                          annotations.
            application/x-ndjson:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/annotations", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Annotations in a Layer
      description: |-
        This endpoint allows you to add one or more new annotations to a specific layer in the document.

        The endpoint accepts two content types:
        - `application/json` - in this case, the request body is a JSON representation of
          one or more annotation; you can check the schema for more details.
        - `multipart/form-data` - with multipart request, annotation(s) can be uploaded along
          with a new attachment. Annotations are one part of the request, followed by
          attachments.

        The annotation `id` is optional, and will be generated by Document Engine if not provided.
        The `user_id` is set as the creator of the annotation.
      operationId: create-document-layer-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        description: One or more annotations to create.
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/AnnotationCreateMultiple'
                - $ref: '#/components/schemas/AnnotationCreateSingle'
          multipart/form-data:
            schema:
              oneOf:
                - $ref: '#/components/schemas/AnnotationCreateMultipleWithAttachment'
                - $ref: '#/components/schemas/AnnotationCreateSingleWithAttachment'
      responses:
        '200':
          description: Annotation(s) created
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/AnnotationMultipleResponse'
                  - type: object
                    description: Single annotation created successfully.
                    properties:
                      data:
                        type: object
                        properties:
                          id:
                            $ref: '#/components/schemas/AnnotationId'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotations":[{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              annotations: [
                {
                  content: {
                    v: 2,
                    type: 'pspdfkit/markup/highlight',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    rects: [[100, 200, 300, 400]],
                    blendMode: 'normal',
                    color: '#fcee7c',
                    note: 'string'
                  },
                  user_id: 'string',
                  group: 'string'
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Annotations in a Layer
      description: |-
        This endpoint allows you to update multiple annotations in the document's specified layer.

        The annotation's content will be completely replaced with the `content` provided in
        the request, and its `updatedBy` field will be set to `user_id`.

        The endpoint accepts two content types:
        - `application/json` - in this case, the request body is a JSON representation of
          one or more annotation; you can check the schema for more details.
        - `multipart/form-data` - with multipart request, annotation(s) can be uploaded along
          with a new attachment. Annotations are one part of the request, followed by
          attachments.

        The annotation `id` is required, and it should correspond to an already existing annotation
        in the document. The `user_id` is set as the creator of the annotation.
      operationId: update-document-layer-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        description: Multiple annotations to update.
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AnnotationUpdateMultiple'
          multipart/form-data:
            schema:
              type: object
              properties:
                annotation:
                  $ref: '#/components/schemas/AnnotationUpdateMultiple'
              additionalProperties:
                $ref: '#/components/schemas/AttachmentContent'
      responses:
        '200':
          description: Annotation(s) updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AnnotationMultipleResponse'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotations":[{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"replace_this_with_an_actual_annotation_id"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              annotations: [
                {
                  content: {
                    v: 2,
                    type: 'pspdfkit/markup/highlight',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    rects: [[100, 200, 300, 400]],
                    blendMode: 'normal',
                    color: '#fcee7c',
                    note: 'string'
                  },
                  user_id: 'string',
                  group: 'string',
                  id: 'replace_this_with_an_actual_annotation_id'
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotations\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Annotations in a Layer.
      description: |-
        This endpoint allows you to remove multiple annotations from the given layer.

        The endpoint accepts one content type `application/json`. The request body is either a JSON
        array of annotations ids, or "all" in order to remove all annotations in one go.
      operationId: remove-document-layer-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeleteAnnotations'
      responses:
        '200':
          description: The annotations have been deleted from the layer.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotationIds":"all"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({annotationIds: 'all'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotationIds\":\"all\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotationIds\":\"all\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotationIds\":\"all\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/annotations", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations:
    get:
      summary: Get Annotations on a Page in a Layer
      description: |-
        You can use this endpoint to fetch annotations on the given page from the given layer.

        If `Accept: application/json` header is used, only the first 1000 annotations
        from the page will be returned. If the page has more than 1000 annotations,
        the `truncated` property in the response is set to `true`.

        In order to consume greater number of annotations in a controlled manner, use `application/x-ndjson`
        as accepted content type. When `Accept: application/x-ndjson` header is used, the response will be
        returned as [Newline delimited JSON](http://ndjson.org/), allowing the client to process annotations
        individually or in batches before the complete response body has been received.
      operationId: get-document-layer-page-annotations
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine responded with first 1000 annotation, or a stream of annotations,
            from the given page in the layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
                      truncated:
                        type: boolean
                        description: |
                          Indicates whether the returned annotations are not all of the document's
                          annotations.
            application/x-ndjson:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: Unauthorized
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/annotations", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}:
    get:
      summary: Get an Annotation From a Layer
      operationId: get-document-layer-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with the annotation.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update an Annotation in a Layer
      description: |-
        This endpoint allows you to update an annotation in the given layer.

        The annotation's content will be completely replaced with the `content` provided in
        the request, and its `updatedBy` field will be set to `user_id`.
      operationId: update-document-layer-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AnnotationUpdate'
      responses:
        '200':
          description: The annotation has been updated.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"replace_this_with_an_actual_annotation_id"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                v: 2,
                type: 'pspdfkit/markup/highlight',
                pageIndex: 0,
                bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                action: {type: 'goTo', pageIndex: 0},
                opacity: 1,
                pdfObjectId: 0,
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                flags: ['noPrint'],
                createdAt: '2019-09-16T15:05:03.712909Z',
                updatedAt: '2019-09-16T15:05:03.712909Z',
                name: 'string',
                creatorName: 'string',
                customData: {foo: 'bar'},
                rects: [[100, 200, 300, 400]],
                blendMode: 'normal',
                color: '#fcee7c',
                note: 'string'
              },
              user_id: 'string',
              group: 'string',
              id: 'replace_this_with_an_actual_annotation_id'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"replace_this_with_an_actual_annotation_id\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete an Annotation in a Layer.
      description: This endpoint allows you to delete an annotation in the given layer.
      operationId: delete-document-layer-annotation
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The annotation has been updated.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation or the document doesn't exist.
      tags:
        - Annotations
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments:
    get:
      summary: Get Comments For a Root Annotation in a Layer
      description: Use this endpoint to list all the comments attached to the given annotation in the document's layer with the specified name.
      operationId: fetch-document-layer-annotation-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with comments
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsList'
        '400':
          description: The annotation is neither markup annotation nor comment marker.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation, the layer, or the document doesn't exist.
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Add Comments to a Root Annotation in a Layer
      description: |-
        Use this endpoint to add new comments to the existing annotation in the given layer.
        Note that the annotation needs to be either a markup annotation or a comment marker.
        The `id` and `createdAt` properties of the comment are autogenerated by Document Engine if they are not provided.
      operationId: create-document-layer-annotation-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/AnnotationIdPathParam'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommentsCreate'
      responses:
        '200':
          description: The comments have been added to the annotation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreated'
        '400':
          description: The annotation is neither markup annotation nor comment marker.
        '401':
          description: You are unauthorized.
        '404':
          description: The annotation, the layer, or the document doesn't exist.
        '422':
          description: One or mote of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreateErrors'
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"comments":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"text":"What a wonderful idea!","createdAt":"2019-11-14T15:05:03.089Z","updatedAt":"2019-11-22T18:05:03.712Z","customData":{},"creatorName":"John Doe"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              comments: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    text: 'What a wonderful idea!',
                    createdAt: '2019-11-14T15:05:03.089Z',
                    updatedAt: '2019-11-22T18:05:03.712Z',
                    customData: {},
                    creatorName: 'John Doe'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/annotations/{annotationId}/comments", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/comments:
    post:
      summary: Add Comments in a Layer
      description: |-
        Use this endpoint to add comments and their root annotation at the same time.

        Note that the annotation needs to be either a markup annotation or a comment marker.

        The `id` and `createdAt` properties of the comment are autogenerated by Document Engine
        if they are not provided.
      operationId: create-document-layer-comments
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommentsCreateWithRoot'
      responses:
        '200':
          description: The comments have been added to the annotation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreatedWithRoot'
        '401':
          description: You are unauthorized.
        '404':
          description: The layer or the document doesn't exist.
        '422':
          description: One or mote of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CommentsCreateErrorsWithRoot'
      tags:
        - Comments
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/comments \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"annotation":{"content":{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"},"user_id":"string","group":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"},"comments":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"text":"What a wonderful idea!","createdAt":"2019-11-14T15:05:03.089Z","updatedAt":"2019-11-22T18:05:03.712Z","customData":{},"creatorName":"John Doe"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/comments",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              annotation: {
                content: {
                  v: 2,
                  type: 'pspdfkit/markup/highlight',
                  pageIndex: 0,
                  bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                  action: {type: 'goTo', pageIndex: 0},
                  opacity: 1,
                  pdfObjectId: 0,
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  flags: ['noPrint'],
                  createdAt: '2019-09-16T15:05:03.712909Z',
                  updatedAt: '2019-09-16T15:05:03.712909Z',
                  name: 'string',
                  creatorName: 'string',
                  customData: {foo: 'bar'},
                  rects: [[100, 200, 300, 400]],
                  blendMode: 'normal',
                  color: '#fcee7c',
                  note: 'string'
                },
                user_id: 'string',
                group: 'string',
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
              },
              comments: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    text: 'What a wonderful idea!',
                    createdAt: '2019-11-14T15:05:03.089Z',
                    updatedAt: '2019-11-22T18:05:03.712Z',
                    customData: {},
                    creatorName: 'John Doe'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/comments")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/comments");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"annotation\":{\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"},\"user_id\":\"string\",\"group\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"},\"comments\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"text\":\"What a wonderful idea!\",\"createdAt\":\"2019-11-14T15:05:03.089Z\",\"updatedAt\":\"2019-11-22T18:05:03.712Z\",\"customData\":{},\"creatorName\":\"John Doe\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/comments", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/redactions:
    post:
      summary: Create Redactions in a Layer
      description: |-
        Use this endpoint to add multiple redaction annotations in a single request.

        Available strategies are:

        - `preset` - creates redactions on top of text and annotations matching the predefined
          pattern. For the full list of presets, see the request schema.
        - `regex` - creates redactions on top of text and annotations matching the provided
          regular expression. The regular expressions needs to comply with the
          [ICU regex standard](http://userguide.icu-project.org/strings/regexp).
        - `text` - creates redactions on top of text and annotations matching the provided string
          search term. Note that the search is case-insensitive.

        The shape of the `strategyOptions` depends on the chosen strategy. Currently each
        strategy supports the `includeAnnotations` options (`true` by default), which controls
        whether redactions should also cover annotations whose content match the search query.

        The `user_id` key allows to specify the owner of the newly created annotations,
        and `content` allows to override their visual properties.

        On success, an array of created redaction annotations is returned.
      operationId: create-document-layer-redactions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateRedactions'
      responses:
        '200':
          description: The redaction annotations have been added to the layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      annotations:
                        type: array
                        items:
                          $ref: '#/components/schemas/AnnotationRecord'
        '401':
          description: You are unauthorized.
        '404':
          description: The document doesn't exist.
        '422':
          description: One or more of the request parameters are invalid.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateRedactionsErrors'
      tags:
        - Redaction
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redactions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"strategy":"preset","strategyOptions":{"preset":"email-address","includeAnnotations":true,"start":0,"limit":null},"user_id":"string","content":{"v":2,"type":"pspdfkit/markup/redaction","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"outlineColor":"#ffffff","fillColor":"string","overlayText":"string","repeatOverlayText":"string","color":"#ffffff","rotation":0,"note":"string"}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/redactions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              strategy: 'preset',
              strategyOptions: {preset: 'email-address', includeAnnotations: true, start: 0, limit: null},
              user_id: 'string',
              content: {
                v: 2,
                type: 'pspdfkit/markup/redaction',
                pageIndex: 0,
                bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                action: {type: 'goTo', pageIndex: 0},
                opacity: 1,
                pdfObjectId: 0,
                id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                flags: ['noPrint'],
                createdAt: '2019-09-16T15:05:03.712909Z',
                updatedAt: '2019-09-16T15:05:03.712909Z',
                name: 'string',
                creatorName: 'string',
                customData: {foo: 'bar'},
                rects: [[100, 200, 300, 400]],
                outlineColor: '#ffffff',
                fillColor: 'string',
                overlayText: 'string',
                repeatOverlayText: 'string',
                color: '#ffffff',
                rotation: 0,
                note: 'string'
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redactions")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redactions");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"strategy\":\"preset\",\"strategyOptions\":{\"preset\":\"email-address\",\"includeAnnotations\":true,\"start\":0,\"limit\":null},\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/markup/redaction\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"outlineColor\":\"#ffffff\",\"fillColor\":\"string\",\"overlayText\":\"string\",\"repeatOverlayText\":\"string\",\"color\":\"#ffffff\",\"rotation\":0,\"note\":\"string\"}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/redactions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/redact:
    post:
      summary: Apply Redactions to a Layer
      description: |-
        Use this endpoint to apply existing redaction annotation to the default layer, erasing
        any content and annotations below them.

        Applying redactions removes the existing redaction annotations and rewrites the underlying
        PDF file.

        Note that regardless of applied redactions, the content and annotations from the originally
        uploaded file are always stored at the document's immutable base layer.
        In some circumstances, e.g. due to legal requirements, this may be undesirable.
        In these cases, you can delete the document after applying redactions, which will erase
        all of the document's data.
      operationId: apply-document-layer-redactions
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Redactions have been successfully applied.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentProperties'
        '401':
          description: You are unauthorized.
        '404':
          description: The document doesn't exist.
      tags:
        - Redaction
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redact \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/redact",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redact")
              .post(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/redact");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/redact", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/form-field-values:
    get:
      summary: Gets Layer's Form Field Values
      operationId: get-document-layer-form-field-values
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The layer form field values
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      formFieldValues:
                        $ref: '#/components/schemas/FormFieldValuesRecords'
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Form Filling
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-values",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/form-field-values", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Update Layer's Form Field Values
      operationId: update-document-layer-form-field-values
      description: To update existing form field values, send a POST request with a JSON body containing the list of form fields and their values.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/FormFieldValueUpdate'
      responses:
        '200':
          description: Form field values correctly updated.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
        '422':
          description: One or more of the request parameters were invalid.
      tags:
        - Form Filling
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldValues":[{"name":"string","value":"string"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-values",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({formFieldValues: [{name: 'string', value: 'string'}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-values");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/form-field-values", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/sign:
    post:
      summary: Digitally Sign a Layer
      description: |-
        Use this endpoint to digitally sign a document's layer.

        You can apply a signature to a specific Instant layer. This lets you maintain independent
        versions of the same document with separate signatures. For example, if you're working on
        a contract, you can maintain two layers: one for the original document, and one for a copy
        that will be digitally signed.

        You can sign an Instant layer using the parent document ID and the layer name. If you use a
        layer name that maps to a non-existing layer, it will be copied automatically from the document
        base layer and then signed.

        ### Signing Service

        The actual signing of the current state of the document is performed by a signing service callback
        that needs to be maintained and operated separately. It needs to expose a single HTTP endpoint
        that receives all callbacks required during the document signing flow differentiated by an `action`
        property in the request's JSON.

        URL of the signing service needs to be configured via `SIGNING_SERVICE_URL` environment variable.

        ### Watermark and Graphic

        The appearance of a digital signature can include a watermark, which is an image typically depicting a company logo or stamp placed in the center, and a graphic, which is an image usually containing the signer's name in the form of a handwritten signature image positioned on the left side of the signature. You can find more information about these different signature appearance options at https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/configure-digital-signature-appearance/.

        To specify the image to be used as the watermark or graphic in the digital signature, send a multipart request
        with the `application/json` part containing the sign request options and the `image` part containing the watermark image, and the `graphicImage` part containing the graphic.
      operationId: sign-document-layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DigitalSignatureCreate'
          multipart/form-data:
            schema:
              type: object
              properties:
                image:
                  type: string
                  format: binary
                  description: The watermark image to be used as part of the signature's appearance
                  example: <Image data>
                graphicImage:
                  type: string
                  format: binary
                  description: The graphic image to be used as part of the signature's appearance
                  example: <Image data>
                data:
                  $ref: '#/components/schemas/DigitalSignatureCreate'
      callbacks:
        SigningService:
          $ref: '#/components/callbacks/signing-service'
      responses:
        '200':
          description: The newly created document layer's digital signature.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignature'
        '400':
          description: |
            Malformed request.

            If the underlying signing service returns an error in the 4xx range,
            the endpoint will respond with a 400 response. Please check the Nutrient Document Engine logs
            for more information about the nature of the error.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/sign \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"signatureType":"cades","flatten":false,"appearance":{"mode":"signatureOnly","contentType":"image/png","showSigner":true,"showReason":true,"showLocation":true,"showWatermark":true,"showSignDate":true},"position":{"pageIndex":0,"rect":[0,0,100,100]},"signatureMetadata":{"signerName":"John Appleseed","signatureReason":"accepted","signatureLocation":"Vienna"},"cadesLevel":"b-lt","signatureContainer":"raw","signingToken":"user-1-with-rights"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/sign",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              signatureType: 'cades',
              flatten: false,
              appearance: {
                mode: 'signatureOnly',
                contentType: 'image/png',
                showSigner: true,
                showReason: true,
                showLocation: true,
                showWatermark: true,
                showSignDate: true
              },
              position: {pageIndex: 0, rect: [0, 0, 100, 100]},
              signatureMetadata: {
                signerName: 'John Appleseed',
                signatureReason: 'accepted',
                signatureLocation: 'Vienna'
              },
              cadesLevel: 'b-lt',
              signatureContainer: 'raw',
              signingToken: 'user-1-with-rights'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/sign")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/sign");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"signatureType\":\"cades\",\"flatten\":false,\"appearance\":{\"mode\":\"signatureOnly\",\"contentType\":\"image/png\",\"showSigner\":true,\"showReason\":true,\"showLocation\":true,\"showWatermark\":true,\"showSignDate\":true},\"position\":{\"pageIndex\":0,\"rect\":[0,0,100,100]},\"signatureMetadata\":{\"signerName\":\"John Appleseed\",\"signatureReason\":\"accepted\",\"signatureLocation\":\"Vienna\"},\"cadesLevel\":\"b-lt\",\"signatureContainer\":\"raw\",\"signingToken\":\"user-1-with-rights\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/sign", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/refresh_ltv:
    post:
      summary: Refresh signatures on a document's layer
      description: |-
        Use this endpoint to refresh LTV signatures for the given document layer.

        Learn more about CAdES and LTV signatures here:
        https://www.nutrient.io/guides/web/signatures/digital-signatures/standards/#understanding-ltv-pades-b-lt

        It will refresh the signatures with IDs provided in the `signatureFQNs` field.
        If `signatureFQNs` is not set, or empty, then all the signatures in the document layer will be refreshed.
      operationId: refresh-document-layer-signatures
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RefreshDigitalSignatures'
      callbacks:
        SigningService:
          $ref: '#/components/callbacks/signing-service'
      responses:
        '200':
          description: The updated digital signatures for the document layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignature'
        '400':
          description: |
            Malformed request.

            If the underlying signing service returns an error in the 4xx range,
            the endpoint will respond with a 400 response. Please check the Nutrient Document Engine logs
            for more information about the nature of the error.
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/refresh_ltv \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"signatureFQNs":["Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85"]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/refresh_ltv",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({signatureFQNs: ['Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85']}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/refresh_ltv")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/refresh_ltv");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"signatureFQNs\":[\"Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85\"]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/refresh_ltv", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/signatures:
    get:
      summary: Get Digital Signatures in a Layer
      description: |-
        Returns a layer's digital signatures.

        You can fetch the digital signature status of an individual layer using the parent
        document ID and the layer name.

        If you use a layer name that maps to a non-existing layer, Nutrient Document Engine will report
        the status of the document base layer without creating a new one:
      operationId: get-document-layer-digital-signatures
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The document's digital signatures
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DigitalSignatures'
        '401':
          description: Unauthorized
        '403':
          description: Incorrect document password
        '404':
          description: Document not found
      tags:
        - Digital Signatures
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/signatures \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/signatures",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/signatures")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/signatures");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/signatures", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/document.xfdf:
    get:
      summary: Export Layer's Annotations as an XFDF
      operationId: get-document-layer-xfdf
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the XFDF file.
          content:
            application/vnd.adobe.xfdf:
              schema:
                type: string
                example: <XFDF data>
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.xfdf \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/document.xfdf",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.xfdf")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.xfdf");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/document.xfdf", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/document.json:
    get:
      summary: Export Layer's Records as an Instant JSON
      operationId: get-document-layer-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the Instant JSON file.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InstantJson'
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.json \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/document.json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.json")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document.json");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/document.json", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/document_info:
    get:
      summary: Fetch Document Layer Information
      operationId: fetch-document-layer-info
      description: |-
        This endpoint allows you to fetch the page count,
        the dimensions of each page, and the document's permissions.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/Password'
        - $ref: '#/components/parameters/LayerName'
      responses:
        '200':
          description: Document Engine returned the document information for the layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentInfo'
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document_info \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/document_info",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document_info")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/document_info");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/document_info", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/apply_instant_json:
    post:
      summary: Apply an Instant JSON to a Layer
      operationId: layer-apply-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
      responses:
        '200':
          description: The Instant JSON has been applied successfully.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'instant.json={"format":"https://pspdfkit.com/instant-json/v1","annotations":[{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"}],"attachments":{"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b":{"binary":"YXR0YWNobWVudCBjb250ZW50cwo=","contentType":"image/png"},"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b":{"binary":"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==","contentType":"plain/text"}},"formFields":[{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}],"formFieldValues":[{"name":"string","value":"string","type":"pspdfkit/form-field-value","v":1,"optionIndexes":[0],"isFitting":false}],"bookmarks":[{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"}],"skippedPdfObjectIds":[0],"pdfId":{"permanent":"9C3nLxNzQBuBBzv96LbdMg==","changing":"Oi+XccZpDHChV7I="}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/apply_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/apply_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json:
    post:
      summary: Download a PDF, Applying the Instant JSON to a Layer
      description: |-
        To import an Instant JSON file and download the resulting PDF, you can
        `POST` a `multipart/form` request including an `instant.json` file.

        This will create a new PDF containing the latest annotations of the
        default layer, import the uploaded Instant JSON, and respond with the
        resulting PDF. Please note that this action will not modify the
        existing document, but rather only import the Instant JSON on a
        temporary file that will be downloaded in the process.
      operationId: download-document-layer-with-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
      responses:
        '200':
          description: Document Engine responded with the PDF file
          content:
            application/pdf:
              schema:
                type: string
                format: binary
                example: <PDF file>
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form 'instant.json={"format":"https://pspdfkit.com/instant-json/v1","annotations":[{"v":2,"type":"pspdfkit/markup/highlight","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"rects":[[100,200,300,400]],"blendMode":"normal","color":"#fcee7c","note":"string"}],"attachments":{"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b":{"binary":"YXR0YWNobWVudCBjb250ZW50cwo=","contentType":"image/png"},"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b":{"binary":"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==","contentType":"plain/text"}},"formFields":[{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}],"formFieldValues":[{"name":"string","value":"string","type":"pspdfkit/form-field-value","v":1,"optionIndexes":[0],"isFitting":false}],"bookmarks":[{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"}],"skippedPdfObjectIds":[0],"pdfId":{"permanent":"9C3nLxNzQBuBBzv96LbdMg==","changing":"Oi+XccZpDHChV7I="}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"instant.json\"\r\n\r\n{\"format\":\"https://pspdfkit.com/instant-json/v1\",\"annotations\":[{\"v\":2,\"type\":\"pspdfkit/markup/highlight\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"rects\":[[100,200,300,400]],\"blendMode\":\"normal\",\"color\":\"#fcee7c\",\"note\":\"string\"}],\"attachments\":{\"388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b\":{\"binary\":\"YXR0YWNobWVudCBjb250ZW50cwo=\",\"contentType\":\"image/png\"},\"ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b\":{\"binary\":\"YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==\",\"contentType\":\"plain/text\"}},\"formFields\":[{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}],\"formFieldValues\":[{\"name\":\"string\",\"value\":\"string\",\"type\":\"pspdfkit/form-field-value\",\"v\":1,\"optionIndexes\":[0],\"isFitting\":false}],\"bookmarks\":[{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"}],\"skippedPdfObjectIds\":[0],\"pdfId\":{\"permanent\":\"9C3nLxNzQBuBBzv96LbdMg==\",\"changing\":\"Oi+XccZpDHChV7I=\"}}\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/pdf_with_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/copy_with_instant_json:
    post:
      summary: Copy the Layer Into a New Document, Applying the Instant JSON
      description: |-
        If the content type of the request is `multipart/form-data`, the document with the chosen layer
        will be copied, and the uploaded `instant.json` file will be imported into the default layer.

        If the content type is `application/json`, the request body is ignored and the layer is copied
        as-is, without any modifications to the default layer.
      operationId: copy-document-layer-with-instant-json
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                instant.json:
                  $ref: '#/components/schemas/InstantJson'
            encoding:
              instant.json:
                contentType: application/json
          application/json:
            schema:
              type:
                - object
                - 'null'
      responses:
        '200':
          description: The layer has been copied successfully.
          content:
            application/json:
              schema:
                type: object
                required:
                  - createdAt
                  - documentId
                  - errors
                  - password_protected
                  - sourcePdfSha256
                  - title
                properties:
                  createdAt:
                    $ref: '#/components/schemas/IsoDateTime'
                  documentId:
                    $ref: '#/components/schemas/DocumentId'
                  errors:
                    $ref: '#/components/schemas/Errors'
                  password_protected:
                    $ref: '#/components/schemas/PasswordProtected'
                  sourcePdfSha256:
                    $ref: '#/components/schemas/SourcePdfSha256'
                  title:
                    $ref: '#/components/schemas/Title'
        '400':
          description: One or more of the provided request parameters are invalid.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/copy_with_instant_json \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/copy_with_instant_json",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/copy_with_instant_json")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/copy_with_instant_json");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/copy_with_instant_json", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pages/text:
    get:
      summary: Fetch Document Text
      description: This endpoint allows you to fetch the text of all pages in a document.
      operationId: get-document-layer-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the lines of text for all pages in the layer.
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/PageText'
                description: Text contents for all pages in a layer.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/text \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pages/text",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/text")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/text");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pages/text", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text:
    get:
      summary: Get Text of a Page in a Layer
      operationId: get-document-layer-page-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine returned the lines of text of the specified page in the layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  textLines:
                    type: array
                    items:
                      $ref: '#/components/schemas/TextLine'
                    description: All lines of text on the page.
        '401':
          description: You are unauthorized.
        '404':
          description: |
            The document with given ID doesn't exist, or the page index is invalid or out of bounds.
          content:
            text/plain:
              schema:
                type: string
                example: Parameter 'page_index' is invalid or out of bounds.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/text", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted:
    get:
      summary: Get Highlighted Text on a Page in a Layer
      description: |-
        Highlighted text in the document refers to any text that is highlighted with any of the
        markup annotations like underline, strikeout, or highlight.

        Note that the data returned by this endpoint is just an approximation and might not always
        exactly reflect the text highlighted in the PDF file.
      operationId: get-document-layer-page-highlighted-text
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned the highlighted text along with respective markup annotations.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/HighlightedText'
                    description: All highlighted text on the page.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/highlighted", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image:
    get:
      summary: Renders a Page in a Layer
      description: |-
        Returns an image with the rendered page from a document. Requires exactly one of
        `width` and `height` query parameters to set the required dimensions of the rendered image.

        Annotation AP streams are not rendered by default, use `render_ap_streams` query parameter
        to enable AP streams rendering.

        Rendered image format depends on the value of the `Accept` header. Supported content types
        are `image/png` (default) and `image/webp`.
      operationId: render-document-layer-page
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/PageIndex'
        - $ref: '#/components/parameters/Password'
        - in: query
          name: width
          required: false
          schema:
            type: number
          description: The width of the page to render.
        - in: query
          name: height
          required: false
          schema:
            type: number
          description: The height of the page to render.
        - in: query
          name: render_ap_streams
          required: false
          schema:
            type: boolean
          description: Whether to render annotation AP streams.
        - in: query
          name: ocg_layers
          schema:
            type: array
            items:
              type: integer
          description: A list of OCG Layer IDs
      responses:
        '200':
          description: Document Engine returned the rendering of the specified page in the document.
          content:
            image/png:
              schema:
                type: string
                format: binary
                example: <image file>
        '400':
          description: |
            One or more of the provided request parameters are invalid, e.g. both `width`
            and `height` were missing or were provided at the same time.
        '401':
          description: You are unauthorized.
        '404':
          description: |
            The document with given ID doesn't exist, or the page index is invalid or out of bounds.
          content:
            text/plain:
              schema:
                type: string
                example: Parameter 'page_index' is invalid or out of bounds.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url 'http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}' \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/pages/{pageIndex}/image?width={number_value}&height={number_value}&render_ap_streams={boolean_value}&ocg_layers={array_value}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/apply_instructions:
    post:
      operationId: document-layer-apply-instructions
      summary: Edit the Layer and Persist the Result
      description: |-
        This endpoints allows to use instructions pipeline for document modification.

        The current document's layer can be referred to by using `#self` anchor.
        ```
        {
          "document": { "id": "#self" }
        }
        ```

        The result of the processing will replace the layer after successful completion.

        Please refer to [Build Instructions](#tag/Build-API) schema for all options.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BuildInstructions'
          multipart/form-data:
            schema:
              type: object
              properties:
                instructions:
                  $ref: '#/components/schemas/BuildInstructions'
            encoding:
              instructions:
                contentType: application/json
      responses:
        '200':
          description: The document properties
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/DocumentProperties'
        '401':
          description: You are unauthorized.
        '404':
          description: The document or the page doesn't exist.
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instructions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"parts":[{"file":"pdf-file-from-multipart"}],"actions":[{"type":"applyInstantJson","file":{"url":"https://remote-file-storage/input-file","sha256":"string"}}],"output":{"metadata":{"title":"Nutrient Document Engine API Specification","author":"Document Author"},"labels":[{"pages":{"start":0,"end":-1},"label":"Page I-III"}],"user_password":"string","owner_password":"string","user_permissions":["printing"],"optimize":{"grayscaleText":false,"grayscaleGraphics":false,"grayscaleImages":false,"grayscaleFormFields":false,"grayscaleAnnotations":false,"disableImages":false,"mrcCompression":false,"imageOptimizationQuality":2,"linearize":false},"type":"pdf"}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/apply_instructions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              parts: [{file: 'pdf-file-from-multipart'}],
              actions: [
                {
                  type: 'applyInstantJson',
                  file: {url: 'https://remote-file-storage/input-file', sha256: 'string'}
                }
              ],
              output: {
                metadata: {title: 'Nutrient Document Engine API Specification', author: 'Document Author'},
                labels: [{pages: {start: 0, end: -1}, label: 'Page I-III'}],
                user_password: 'string',
                owner_password: 'string',
                user_permissions: ['printing'],
                optimize: {
                  grayscaleText: false,
                  grayscaleGraphics: false,
                  grayscaleImages: false,
                  grayscaleFormFields: false,
                  grayscaleAnnotations: false,
                  disableImages: false,
                  mrcCompression: false,
                  imageOptimizationQuality: 2,
                  linearize: false
                },
                type: 'pdf'
              }
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instructions")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/apply_instructions");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"parts\":[{\"file\":\"pdf-file-from-multipart\"}],\"actions\":[{\"type\":\"applyInstantJson\",\"file\":{\"url\":\"https://remote-file-storage/input-file\",\"sha256\":\"string\"}}],\"output\":{\"metadata\":{\"title\":\"Nutrient Document Engine API Specification\",\"author\":\"Document Author\"},\"labels\":[{\"pages\":{\"start\":0,\"end\":-1},\"label\":\"Page I-III\"}],\"user_password\":\"string\",\"owner_password\":\"string\",\"user_permissions\":[\"printing\"],\"optimize\":{\"grayscaleText\":false,\"grayscaleGraphics\":false,\"grayscaleImages\":false,\"grayscaleFormFields\":false,\"grayscaleAnnotations\":false,\"disableImages\":false,\"mrcCompression\":false,\"imageOptimizationQuality\":2,\"linearize\":false},\"type\":\"pdf\"}}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/apply_instructions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/bookmarks:
    get:
      summary: Gets Layer's Bookmarks
      operationId: get-document-layer-bookmarks
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The bookmarks included in the layer
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      bookmarks:
                        type: array
                        items:
                          $ref: '#/components/schemas/BookmarkRecord'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/bookmarks",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/bookmarks", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create a Bookmark in a Layer
      operationId: create-document-layer-bookmark
      description: |-
        Bookmarks can be created with and without specifying the ID for the bookmark. When no ID is specified,
        Nutrient Document Engine will assign a random ID to the bookmark. If you want to rely on a specific ID being the
        ID of the created bookmark, the ID can be set with the `id` property in the JSON payload.
        This is useful if you, for example, want a bookmark with the same ID in multiple documents.
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BookmarkRecord'
      responses:
        '200':
          description: The newly created bookmark
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      id:
                        type: string
                    required:
                      - id
        '400':
          description: Invalid bookmark params
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"},"createdBy":"string","updatedBy":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/bookmarks",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                name: 'string',
                type: 'pspdfkit/bookmark',
                v: 1,
                action: {type: 'goTo', pageIndex: 0},
                pdfBookmarkId: 'string'
              },
              createdBy: 'string',
              updatedBy: 'string',
              id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/bookmarks", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}:
    put:
      summary: Update a Bookmark in a Layer
      operationId: update-document-layer-bookmark
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/BookmarkId'
        - $ref: '#/components/parameters/Password'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BookmarkRecord'
      responses:
        '200':
          description: Update was successful.
        '400':
          description: Invalid update request. See body for reason.
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"content":{"name":"string","type":"pspdfkit/bookmark","v":1,"action":{"type":"goTo","pageIndex":0},"pdfBookmarkId":"string"},"createdBy":"string","updatedBy":"string","id":"01DNEDPQQ22W49KDXRFPG4EPEQ"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              content: {
                name: 'string',
                type: 'pspdfkit/bookmark',
                v: 1,
                action: {type: 'goTo', pageIndex: 0},
                pdfBookmarkId: 'string'
              },
              createdBy: 'string',
              updatedBy: 'string',
              id: '01DNEDPQQ22W49KDXRFPG4EPEQ'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"content\":{\"name\":\"string\",\"type\":\"pspdfkit/bookmark\",\"v\":1,\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"pdfBookmarkId\":\"string\"},\"createdBy\":\"string\",\"updatedBy\":\"string\",\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete a Bookmark in a Layer
      operationId: delete-document-layer-bookmark
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/BookmarkId'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Delete was successful.
        '400':
          description: Invalid update request. See body for reason.
        '401':
          description: Unauthorized
      tags:
        - Bookmarks
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/bookmarks/{bookmarkId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/embedded-files:
    get:
      summary: Get Layers's Embedded Files
      description: |-
        Returned records describe files that are attached to a layer.

        Use attachments API to retrieve the actual file contents.
      operationId: get-document-layer-embedded-files
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The embedded files included in the layer
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: object
                    properties:
                      embeddedFiles:
                        type: array
                        items:
                          $ref: '#/components/schemas/EmbeddedFile'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Embedded files
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/embedded-files \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/embedded-files",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/embedded-files")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/embedded-files");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/embedded-files", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/form-fields:
    get:
      summary: Get Form Fields in a Layer
      description: You can use this endpoint to fetch all form fields from a document's layer.
      operationId: get-document-layer-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned the form fields in the specified layer of the document
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FormFieldWithWidgets'
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/form-fields", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Form Fields in a Layer
      description: |-
        This endpoint allows you to add a new form field to a layer of the document.

        The `id` is optional, and will be generated by Document Engine if not provided. The `group` of the form field
        will be inherited by the widgets and form field values associated with it.
        The `user_id` is set as the creator of the form field.
      operationId: create-document-layer-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFields
              properties:
                formFields:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldCreate'
      responses:
        '200':
          description: The form fields have been added to the layer.
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
                        description: An array of the form field IDs for the form fields that were successfully created.
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFields":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFields: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    v: 1,
                    type: 'pspdfkit/form-field/button',
                    id: '7KPSXX1NMNJ2WFDKN7BKQK9KZ',
                    name: 'Form-Field',
                    label: 'Form Field',
                    annotationIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '7KPS6T4DKYN71VB7G5KBGB5R51'],
                    pdfObjectId: 0,
                    flags: ['required'],
                    buttonLabel: 'string'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Form Fields in a Layer
      description: |-
        This endpoint allows you to update an existing form field in a document's layer.

        The `id` is required. If you provide the `group` in this operation then the new group
        will cascade to all the widgets and form field values associated  with this field in this layer.
      operationId: update-document-layer-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFields
              properties:
                formFields:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldUpdate'
      responses:
        '200':
          description: The form fields have been updated
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFields":[{"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","user_id":"string","group":"string","content":{"v":1,"type":"pspdfkit/form-field/button","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZ","name":"Form-Field","label":"Form Field","annotationIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","7KPS6T4DKYN71VB7G5KBGB5R51"],"pdfObjectId":0,"flags":["required"],"buttonLabel":"string"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFields: [
                {
                  id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                  user_id: 'string',
                  group: 'string',
                  content: {
                    v: 1,
                    type: 'pspdfkit/form-field/button',
                    id: '7KPSXX1NMNJ2WFDKN7BKQK9KZ',
                    name: 'Form-Field',
                    label: 'Form Field',
                    annotationIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '7KPS6T4DKYN71VB7G5KBGB5R51'],
                    pdfObjectId: 0,
                    flags: ['required'],
                    buttonLabel: 'string'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFields\":[{\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"user_id\":\"string\",\"group\":\"string\",\"content\":{\"v\":1,\"type\":\"pspdfkit/form-field/button\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZ\",\"name\":\"Form-Field\",\"label\":\"Form Field\",\"annotationIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"7KPS6T4DKYN71VB7G5KBGB5R51\"],\"pdfObjectId\":0,\"flags\":[\"required\"],\"buttonLabel\":\"string\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Form Fields in a Layer
      description: |-
        This endpoint allows you to remove multiple form fields from a document's layer.

        Deleting a form field will cascade delete all its associated widgets and values in the specified layer.

        The endpoint accepts content type `application/json`. The request body is an object with a field `formFieldIds`
        that is set to either a JSON array of IDs, or "all" in order to remove all form fields in one request.
      operationId: remove-document-layer-form-fields
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - type: object
                  title: Form Field IDs
                  required:
                    - formFieldIds
                  properties:
                    formFieldIds:
                      type: array
                      items:
                        $ref: '#/components/schemas/RecordId'
                      description: An array of form field IDs
                      example:
                        - 01DNEDPQQ22W49KDXRFPG4EPEQ
                        - 01DNEDPQQ22W49KDXRFPG4EPEM
                    user_id:
                      $ref: '#/components/schemas/User'
                - type: object
                  title: All Form Fields
                  required:
                    - formFieldIds
                  properties:
                    formFieldIds:
                      type: string
                      enum:
                        - all
                    user_id:
                      $ref: '#/components/schemas/User'
      responses:
        '200':
          description: The form field(s) have been deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/RecordId'
                        description: An array of IDs for the form fields that were successfully deleted
                        example:
                          - id: 01DNEDPQQ22W49KDXRFPG4EPEQ
                          - id: 01DNEDPQQ22W49KDXRFPG4EPEM
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","01DNEDPQQ22W49KDXRFPG4EPEM"],"user_id":"string"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-fields",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '01DNEDPQQ22W49KDXRFPG4EPEM'],
              user_id: 'string'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/form-fields", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId}:
    get:
      summary: Get a Form Field in a Layer
      description: Use this endpoint to get the form field with a specified ID from a layer of the document
      operationId: get-document-layer-form-field
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/FormFieldIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: The  responded with the form field and its widgets, if any
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FormFieldWithWidgets'
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/form-fields/{formFieldId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/form-field-widgets:
    get:
      summary: Get Widgets in a Layer
      description: |-
        You can use this endpoint to fetch all widgets from a layer of the documents.
        The response will also contain details of the formField each widget is associated with,
        if it is associated with a form field.
      operationId: get-document-layer-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: |
            Document Engine returned the widgets on the specified layer of the document
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FormFieldWidgetWithFormField'
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/form-field-widgets", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    post:
      summary: Create Widgets in a Layer
      description: |-
        This endpoint allows you to add a new widget to a layer of the document

        The `id` is optional, and will be generated by Document Engine if not provided.
      operationId: create-document-layer-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFieldWidgets
              properties:
                formFieldWidgets:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldWidgetCreate'
      responses:
        '200':
          description: The widgets were created successfully
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
                        description: IDs of the widgets that were successfully created
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgets":[{"id":"7KPSXX1NMNJ2WFDKN7BKQK9KZE","user_id":"string","content":{"v":2,"type":"pspdfkit/widget","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"formFieldName":"First-Name","borderColor":"#ffffff","borderStyle":"solid","borderWidth":0,"font":"Helvetica","fontSize":10,"fontColor":"#ffffff","fontStyle":["bold"],"horizontalAlign":"left","verticalAlign":"top","rotation":0,"backgroundColor":"#000000"}}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgets: [
                {
                  id: '7KPSXX1NMNJ2WFDKN7BKQK9KZE',
                  user_id: 'string',
                  content: {
                    v: 2,
                    type: 'pspdfkit/widget',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    formFieldName: 'First-Name',
                    borderColor: '#ffffff',
                    borderStyle: 'solid',
                    borderWidth: 0,
                    font: 'Helvetica',
                    fontSize: 10,
                    fontColor: '#ffffff',
                    fontStyle: ['bold'],
                    horizontalAlign: 'left',
                    verticalAlign: 'top',
                    rotation: 0,
                    backgroundColor: '#000000'
                  }
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgets\":[{\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\",\"user_id\":\"string\",\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"}}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/documents/{documentId}/layers/{layerName}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Update Widgets in a Layer
      description: This endpoint allows you to update an existing widget in a layer of the document
      operationId: update-document-layer-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - formFieldWidgets
              properties:
                formFieldWidgets:
                  type: array
                  items:
                    $ref: '#/components/schemas/FormFieldWidgetUpdate'
      responses:
        '200':
          description: The widgets have been updated
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
                        description: IDs of the widgets that were successfully updated
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgets":[{"content":{"v":2,"type":"pspdfkit/widget","pageIndex":0,"bbox":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],"action":{"type":"goTo","pageIndex":0},"opacity":1,"pdfObjectId":0,"id":"01DNEDPQQ22W49KDXRFPG4EPEQ","flags":["noPrint"],"createdAt":"2019-09-16T15:05:03.712909Z","updatedAt":"2019-09-16T15:05:03.712909Z","name":"string","creatorName":"string","customData":{"foo":"bar"},"formFieldName":"First-Name","borderColor":"#ffffff","borderStyle":"solid","borderWidth":0,"font":"Helvetica","fontSize":10,"fontColor":"#ffffff","fontStyle":["bold"],"horizontalAlign":"left","verticalAlign":"top","rotation":0,"backgroundColor":"#000000"},"user_id":"string","id":"7KPSXX1NMNJ2WFDKN7BKQK9KZE"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgets: [
                {
                  content: {
                    v: 2,
                    type: 'pspdfkit/widget',
                    pageIndex: 0,
                    bbox: [255.10077620466092, 656.7566095695641, 145.91672653256705, 18.390804597701162],
                    action: {type: 'goTo', pageIndex: 0},
                    opacity: 1,
                    pdfObjectId: 0,
                    id: '01DNEDPQQ22W49KDXRFPG4EPEQ',
                    flags: ['noPrint'],
                    createdAt: '2019-09-16T15:05:03.712909Z',
                    updatedAt: '2019-09-16T15:05:03.712909Z',
                    name: 'string',
                    creatorName: 'string',
                    customData: {foo: 'bar'},
                    formFieldName: 'First-Name',
                    borderColor: '#ffffff',
                    borderStyle: 'solid',
                    borderWidth: 0,
                    font: 'Helvetica',
                    fontSize: 10,
                    fontColor: '#ffffff',
                    fontStyle: ['bold'],
                    horizontalAlign: 'left',
                    verticalAlign: 'top',
                    rotation: 0,
                    backgroundColor: '#000000'
                  },
                  user_id: 'string',
                  id: '7KPSXX1NMNJ2WFDKN7BKQK9KZE'
                }
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgets\":[{\"content\":{\"v\":2,\"type\":\"pspdfkit/widget\",\"pageIndex\":0,\"bbox\":[255.10077620466092,656.7566095695641,145.91672653256705,18.390804597701162],\"action\":{\"type\":\"goTo\",\"pageIndex\":0},\"opacity\":1,\"pdfObjectId\":0,\"id\":\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"flags\":[\"noPrint\"],\"createdAt\":\"2019-09-16T15:05:03.712909Z\",\"updatedAt\":\"2019-09-16T15:05:03.712909Z\",\"name\":\"string\",\"creatorName\":\"string\",\"customData\":{\"foo\":\"bar\"},\"formFieldName\":\"First-Name\",\"borderColor\":\"#ffffff\",\"borderStyle\":\"solid\",\"borderWidth\":0,\"font\":\"Helvetica\",\"fontSize\":10,\"fontColor\":\"#ffffff\",\"fontStyle\":[\"bold\"],\"horizontalAlign\":\"left\",\"verticalAlign\":\"top\",\"rotation\":0,\"backgroundColor\":\"#000000\"},\"user_id\":\"string\",\"id\":\"7KPSXX1NMNJ2WFDKN7BKQK9KZE\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Delete Widgets in a Layer
      description: |-
        This endpoint allows you to remove multiple widgets from a layer of the document.

        The endpoint accepts content type `application/json`. The request body is an object with a field `formFieldWidgetIds`
        that is set to either a JSON array of IDs, or "all" in order to remove all widgets in one request.
      operationId: remove-document-layer-widgets
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              oneOf:
                - type: object
                  title: Widget IDs
                  required:
                    - formFieldWidgetIds
                  properties:
                    formFieldWidgetIds:
                      type: array
                      items:
                        $ref: '#/components/schemas/FormFieldWidgetId'
                      description: An array of widget IDs
                      example:
                        - 01DNEDPQQ22W49KDXRFPG4EPEQ
                        - 01DNEDPQQ22W49KDXRFPG4EPEM
                    user_id:
                      $ref: '#/components/schemas/User'
                - type: object
                  title: All Widgets
                  required:
                    - formFieldWidgetIds
                  properties:
                    formFieldWidgetIds:
                      type: string
                      enum:
                        - all
                    user_id:
                      $ref: '#/components/schemas/User'
      responses:
        '200':
          description: The widget(s) have been deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        items:
                          type: object
                          properties:
                            id:
                              $ref: '#/components/schemas/FormFieldWidgetId'
                        description: An array of IDs for the widgets that were successfully deleted
                        example:
                          - id: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
                          - id: 7KPSXX1NMNJ2WFDKN7BKQKMM
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
        '422':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"formFieldWidgetIds":["01DNEDPQQ22W49KDXRFPG4EPEQ","01DNEDPQQ22W49KDXRFPG4EPEM"],"user_id":"string"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-widgets",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              formFieldWidgetIds: ['01DNEDPQQ22W49KDXRFPG4EPEQ', '01DNEDPQQ22W49KDXRFPG4EPEM'],
              user_id: 'string'
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets")
              .delete(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"formFieldWidgetIds\":[\"01DNEDPQQ22W49KDXRFPG4EPEQ\",\"01DNEDPQQ22W49KDXRFPG4EPEM\"],\"user_id\":\"string\"}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/form-field-widgets", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId}:
    get:
      summary: Get a Widget in a Layer
      description: Use this endpoint to get the widget with the specified ID from a layer of the document
      operationId: get-document-layer-widget
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/FormFieldWidgetIdPathParam'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: Document Engine responded with the widget
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FormFieldWidgetWithFormField'
        '401':
          description: You are unauthorized.
        '404':
          description: One or more of the provided request parameters are invalid.
      tags:
        - Forms
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId} \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId}",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId}")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/form-field-widgets/{formFieldWidgetId}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/fonts:
    get:
      summary: Get fonts
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      operationId: get-fonts-in-layer
      responses:
        '200':
          description: |
            List of fonts used in the document layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/FontFile'
        '401':
          description: Unauthorized
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/fonts \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/fonts",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/fonts")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/fonts");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/fonts", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/font_substitutions:
    get:
      summary: Get font substitutions
      operationId: get-font-substitutions-in-layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      description: |-
        This endpoint allows you to get font substitutions that were set for the specific document layer.

        Note that font substitutions returned by this endpoint will include the font substitutions defined for the specified document layer,
        as well as any font substitutions defined in the `font-substitutions.json` configuration file, if a `font-substitutions.json` file is mounted on Nutrient Document Engine.

        The font substitutions for the document layer will be merged with the font substitutions in `font-substitutions.json` if any,
        with the substitutions in the document layer having priority over any substitutions `font-substitutions.json` may define.
        It is this combination of font substitutions that will be applied by Nutrient Document Engine
        when performing operations on the document layer where a font is unavailable and needs to be substituted.

        Learn more about the `font-substitutions.json` file from the documentation available here:
        https://www.nutrient.io/guides/document-engine/configuration/custom-fonts/#font-substitutions
      responses:
        '200':
          description: |
            List of font substitutions used in the document layer.
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    $ref: '#/components/schemas/FontSubstitutionList'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Fonts
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/font_substitutions", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    put:
      summary: Replaces font substitutions in the document layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      tags:
        - Fonts
      description: |-
        This endpoint allows you to replace font substitutions in the specified document layer.
        It will delete any existing font substitutions for the document layer and replace them with these new ones

        If no font substitutions existed for the document layer prior, it will create them.
        Note that this endpoint does not affect the font substitutions specified in the `font-substitutions.json` configuration file, if any.
      operationId: update-font-substitutions-in-layer
      requestBody:
        required: true
        description: |
          List of font substitutions to replace the old ones with.
        content:
          application/json:
            schema:
              type: object
              required:
                - fontSubstitutions
              properties:
                fontSubstitutions:
                  $ref: '#/components/schemas/FontSubstitutionList'
      responses:
        '200':
          description: |
            List of font substitutions that were successfully created to replace the old ones
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        $ref: '#/components/schemas/FontSubstitutionList'
        '400':
          description: Invalid request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BatchOperationResult'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request PUT \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --header 'pspdfkit-pdf-password: password' \
              --data '{"fontSubstitutions":[{"pattern":"Roboto-*","target":"Courier New"}]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "PUT",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({fontSubstitutions: [{pattern: 'Roboto-*', target: 'Courier New'}]}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions")
              .put(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions");
            var request = new RestRequest(Method.PUT);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"fontSubstitutions\":[{\"pattern\":\"Roboto-*\",\"target\":\"Courier New\"}]}"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("PUT", "/api/documents/{documentId}/layers/{layerName}/font_substitutions", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    delete:
      summary: Deletes all font substitutions in the document layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      tags:
        - Fonts
      description: |-
        This endpoint allows you to delete all font substitutions in the document layer.

        Note that this endpoint does not affect the font substitutions specified in the `font-substitutions.json` configuration file, if any.
      operationId: delete-font-substitutions-in-layer
      responses:
        '200':
          description: |
            List of font substitutions that were deleted
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        $ref: '#/components/schemas/FontSubstitutionList'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request DELETE \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "DELETE",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/font_substitutions",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions")
              .delete(null)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/font_substitutions");
            var request = new RestRequest(Method.DELETE);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("DELETE", "/api/documents/{documentId}/layers/{layerName}/font_substitutions", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/documents/{documentId}/layers/{layerName}/ocg-layers:
    get:
      summary: Get available OCG layers for layer
      operationId: get-ocg-layers-in-layer
      parameters:
        - $ref: '#/components/parameters/DocumentId'
        - $ref: '#/components/parameters/LayerName'
        - $ref: '#/components/parameters/Password'
      responses:
        '200':
          description: List of the OCG Layers for the layer
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OCGLayerResponse'
        '401':
          description: Unauthorized
        '404':
          description: Document not found
      tags:
        - Layers
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/documents/{documentId}/layers/{layerName}/ocg-layers \
              --header 'Authorization: Token token=secret' \
              --header 'pspdfkit-pdf-password: password'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/documents/{documentId}/layers/{layerName}/ocg-layers",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/ocg-layers")
              .get()
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/documents/{documentId}/layers/{layerName}/ocg-layers");
            var request = new RestRequest(Method.GET);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret"
                }

            conn.request("GET", "/api/documents/{documentId}/layers/{layerName}/ocg-layers", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/copy_document:
    post:
      summary: Copy a Document
      operationId: copy-document
      description: |-
        You can use this endpoint to copy the document, without having to reupload
        it to Document Engine

        The copy includes the latest version of all layers and their annotations
        from the original document.

        A common use case for copying a document is to create an individual document
        for each user, allowing different users work on the same file without seeing
        each other's annotations. However, we recommend leveraging named Instant Layers
        for such scenarios as they provide more efficient API to manage different document versions.
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required:
                - documentId
              properties:
                document_id:
                  type: string
                  description: The ID of the original document.
                  example: 7KPSA689RP53HB64GKKZX64XFV
                new_document_id:
                  type: string
                  description: The ID of the copy.
                  example: 7KPS5BP7NVPZPFTEMN2PB6D3XY
                storage:
                  $ref: '#/components/schemas/StorageConfiguration'
      responses:
        '200':
          description: The document has been copied.
          content:
            application/json:
              schema:
                type: object
                required:
                  - data
                properties:
                  data:
                    type: object
                    required:
                      - document_id
                    properties:
                      document_id:
                        type: string
                        description: The ID of the newly created document.
                        example: 7KPS5BP7NVPZPFTEMN2PB6D3XY
        '400':
          description: |
            One or more of the provided request parameters are invalid, e.g. both `flatten`
            and `source` were provided at the same time.
        '401':
          description: You are unauthorized.
        '404':
          description: The document with given ID doesn't exist.
      tags:
        - Documents
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/copy_document \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --data '{"document_id":"7KPSA689RP53HB64GKKZX64XFV","new_document_id":"7KPS5BP7NVPZPFTEMN2PB6D3XY","storage":{"backend":"s3","bucketName":"string","bucketRegion":"string"}}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/copy_document",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              document_id: '7KPSA689RP53HB64GKKZX64XFV',
              new_document_id: '7KPS5BP7NVPZPFTEMN2PB6D3XY',
              storage: {backend: 's3', bucketName: 'string', bucketRegion: 'string'}
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"document_id\":\"7KPSA689RP53HB64GKKZX64XFV\",\"new_document_id\":\"7KPS5BP7NVPZPFTEMN2PB6D3XY\",\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"}}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/copy_document")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/copy_document");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"document_id\":\"7KPSA689RP53HB64GKKZX64XFV\",\"new_document_id\":\"7KPS5BP7NVPZPFTEMN2PB6D3XY\",\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"}}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"document_id\":\"7KPSA689RP53HB64GKKZX64XFV\",\"new_document_id\":\"7KPS5BP7NVPZPFTEMN2PB6D3XY\",\"storage\":{\"backend\":\"s3\",\"bucketName\":\"string\",\"bucketRegion\":\"string\"}}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/copy_document", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/validate_pdfa:
    parameters:
      - $ref: '#/components/parameters/Password'
    post:
      summary: Validate PDF/A Compliance
      description: This endpoint allows you to validate the PDF/A compliance of a PDF file and returns a validation report.
      operationId: validate-pdfa
      requestBody:
        description: A request to validate PDF/A conformance of a document
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
                  description: PDF/A file on which to perform validation.
            encoding:
              file:
                contentType: application/pdf
          multipart/form-data (for URL):
            schema:
              type: object
              properties:
                url:
                  type: string
                  example: http://www.example.com/example.pdf
                  description: |
                    URL of the PDF/A file on which to perform validation.

                    Warning: This request will not execute as-is since the content type of
                    this request is `multipart/form-data (for URL)`. To run this example request
                    please copy the curl command and set the content type to `multipart/form-data`
                    and then run the curl command in the terminal.
            encoding:
              url:
                contentType: text/plain
          multipart/form-data (for document-id):
            schema:
              type: object
              properties:
                document:
                  type: string
                  example: 7KPV43VQYQK2W0VKGT4EP4HMQK
                  description: |
                    Document id of the PDF/A file uploaded on Document Engine on which to perform validation.
            encoding:
              document:
                contentType: text/plain
      responses:
        '200':
          description: PDF/A validation finished.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ValidatePDFAResult'
        '400':
          description: Bad request.
        '401':
          description: Unauthorized
      tags:
        - PDF/A Validation
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/validate_pdfa \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: multipart/form-data' \
              --header 'pspdfkit-pdf-password: password' \
              --form file=string
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/validate_pdfa",
              "headers": {
                "pspdfkit-pdf-password": "password",
                "Authorization": "Token token=secret",
                "content-type": "multipart/form-data"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write("-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\nstring\r\n-----011000010111000001101001--\r\n");
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
            RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\nstring\r\n-----011000010111000001101001--\r\n");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/validate_pdfa")
              .post(body)
              .addHeader("pspdfkit-pdf-password", "password")
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "multipart/form-data")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/validate_pdfa");
            var request = new RestRequest(Method.POST);
            request.AddHeader("pspdfkit-pdf-password", "password");
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "multipart/form-data");
            request.AddParameter("multipart/form-data", "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\nstring\r\n-----011000010111000001101001--\r\n", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"file\"\r\n\r\nstring\r\n-----011000010111000001101001--\r\n"

            headers = {
                'pspdfkit-pdf-password': "password",
                'Authorization': "Token token=secret",
                'content-type': "multipart/form-data"
                }

            conn.request("POST", "/api/validate_pdfa", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/revoke:
    post:
      summary: Revoke JWT
      description: |-
        This endpoint allows you to revoke JSON Web Tokens created by your service. Revoked tokens are invalided before they would normally expire. On top of preventing any future authentications with revoked JWTs, any active authenticated session is also destroyed immediately.

        It's only possible to revoke JWTs with an ID that needs to be specified in their `jti` claim. Note that revoking a particular JWTs will revoke all JWTs with the same ID as well.
      operationId: revoke-jwt
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                jwts:
                  type: array
                  items:
                    $ref: '#/components/schemas/JWT'
      responses:
        '200':
          description: Token revocation finished.
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/BatchOperationResult'
                  - type: object
                    properties:
                      data:
                        type: array
                        description: List of successfully revoked JWTs.
                        items:
                          $ref: '#/components/schemas/JWT'
        '400':
          description: Bad request.
        '401':
          description: Unauthorized
      tags:
        - Maintenance
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/revoke \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --data '{"jwts":["eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg"]}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/revoke",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({
              jwts: [
                'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg'
              ]
            }));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"jwts\":[\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg\"]}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/revoke")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/revoke");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"jwts\":[\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg\"]}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"jwts\":[\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg\"]}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/revoke", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/secrets/{secretType}:
    post:
      summary: Add a Secret
      description: Creates a new secret. This does not replace previous secrets of this type.
      operationId: create-secret
      parameters:
        - $ref: '#/components/parameters/SecretType'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - secret
              properties:
                secret:
                  type: string
                  description: The secret value.
                  example: Secret value
                expiresAt:
                  $ref: '#/components/schemas/IsoDateTime'
      responses:
        '200':
          description: Secret created successfully.
        '400':
          description: Bad request.
        '401':
          description: Unauthorized
      tags:
        - Secrets
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/secrets/{secretType} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --data '{"secret":"Secret value","expiresAt":"2019-09-16T15:05:03.712909Z"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/secrets/{secretType}",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({secret: 'Secret value', expiresAt: '2019-09-16T15:05:03.712909Z'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"secret\":\"Secret value\",\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/secrets/{secretType}")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/secrets/{secretType}");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"secret\":\"Secret value\",\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"secret\":\"Secret value\",\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/secrets/{secretType}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
    get:
      summary: List Secrets
      description: Gets all non-expired secret of the specified type.
      operationId: get-secrets
      parameters:
        - $ref: '#/components/parameters/SecretType'
      responses:
        '200':
          description: List of non-expired secrets of the specified type.
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: integer
                      description: Secret's ID, unique within the specified type.
                      example: 1
                    expiresAt:
                      $ref: '#/components/schemas/IsoDateTime'
        '401':
          description: Unauthorized
      tags:
        - Secrets
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request GET \
              --url http://localhost:5000/api/secrets/{secretType} \
              --header 'Authorization: Token token=secret'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "GET",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/secrets/{secretType}",
              "headers": {
                "Authorization": "Token token=secret"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            Request request = new Request.Builder()
              .url("http://localhost:5000/api/secrets/{secretType}")
              .get()
              .addHeader("Authorization", "Token token=secret")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/secrets/{secretType}");
            var request = new RestRequest(Method.GET);
            request.AddHeader("Authorization", "Token token=secret");
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            headers = { 'Authorization': "Token token=secret" }

            conn.request("GET", "/api/secrets/{secretType}", headers=headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/secrets/{secretType}/rotate:
    post:
      summary: Rotate a Secret
      description: Current secrets don't expire. To change current secrets, you'll need to rotate them.
      operationId: rotate-secret
      parameters:
        - $ref: '#/components/parameters/SecretType'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - secret
              properties:
                secret:
                  type: string
                  description: New secret value
                  example: New secret value
      responses:
        '200':
          description: Secret rotated successfully.
        '400':
          description: Bad request.
        '401':
          description: Unauthorized
      tags:
        - Secrets
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/secrets/{secretType}/rotate \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --data '{"secret":"New secret value"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/secrets/{secretType}/rotate",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({secret: 'New secret value'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"secret\":\"New secret value\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/secrets/{secretType}/rotate")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/secrets/{secretType}/rotate");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"secret\":\"New secret value\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"secret\":\"New secret value\"}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/secrets/{secretType}/rotate", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
  /api/secrets/{secretType}/{secretId}:
    post:
      summary: Update a Secret
      description: Updates existing secret. This is usually done to update the expiration date of existing secrets.
      operationId: expire-secret
      parameters:
        - $ref: '#/components/parameters/SecretType'
        - $ref: '#/components/parameters/SecretId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - expiresAt
              properties:
                expiresAt:
                  $ref: '#/components/schemas/IsoDateTime'
      responses:
        '200':
          description: Secret rotated successfully.
        '400':
          description: Bad request.
        '401':
          description: Unauthorized
      tags:
        - Secrets
      x-codeSamples:
        - lang: curl
          label: cURL
          source: |-
            curl --request POST \
              --url http://localhost:5000/api/secrets/{secretType}/{secretId} \
              --header 'Authorization: Token token=secret' \
              --header 'content-type: application/json' \
              --data '{"expiresAt":"2019-09-16T15:05:03.712909Z"}'
        - lang: JavaScript
          label: Node.js
          source: |-
            const http = require("http");

            const options = {
              "method": "POST",
              "hostname": "localhost",
              "port": "5000",
              "path": "/api/secrets/{secretType}/{secretId}",
              "headers": {
                "Authorization": "Token token=secret",
                "content-type": "application/json"
              }
            };

            const req = http.request(options, function (res) {
              const chunks = [];

              res.on("data", function (chunk) {
                chunks.push(chunk);
              });

              res.on("end", function () {
                const body = Buffer.concat(chunks);
                console.log(body.toString());
              });
            });

            req.write(JSON.stringify({expiresAt: '2019-09-16T15:05:03.712909Z'}));
            req.end();
        - lang: Java
          label: Java
          source: |-
            OkHttpClient client = new OkHttpClient();

            MediaType mediaType = MediaType.parse("application/json");
            RequestBody body = RequestBody.create(mediaType, "{\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}");
            Request request = new Request.Builder()
              .url("http://localhost:5000/api/secrets/{secretType}/{secretId}")
              .post(body)
              .addHeader("Authorization", "Token token=secret")
              .addHeader("content-type", "application/json")
              .build();

            Response response = client.newCall(request).execute();
        - lang: C#
          label: C#
          source: |-
            var client = new RestClient("http://localhost:5000/api/secrets/{secretType}/{secretId}");
            var request = new RestRequest(Method.POST);
            request.AddHeader("Authorization", "Token token=secret");
            request.AddHeader("content-type", "application/json");
            request.AddParameter("application/json", "{\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}", ParameterType.RequestBody);
            IRestResponse response = client.Execute(request);
        - lang: Python
          label: Python
          source: |-
            import http.client

            conn = http.client.HTTPConnection("localhost:5000")

            payload = "{\"expiresAt\":\"2019-09-16T15:05:03.712909Z\"}"

            headers = {
                'Authorization': "Token token=secret",
                'content-type': "application/json"
                }

            conn.request("POST", "/api/secrets/{secretType}/{secretId}", payload, headers)

            res = conn.getresponse()
            data = res.read()

            print(data.decode("utf-8"))
components:
  parameters:
    AttachmentId:
      name: attachmentId
      in: path
      required: true
      description: The ID of the attachment
      schema:
        type: string
    BookmarkId:
      name: bookmarkId
      in: path
      required: true
      description: The ID of the bookmark
      schema:
        type: string
    DocumentId:
      name: documentId
      in: path
      required: true
      description: The document ID
      schema:
        type: string
    JobId:
      name: jobId
      in: path
      required: true
      description: The async job ID
      schema:
        type: string
    LayerName:
      name: layerName
      in: path
      required: true
      description: The layer name
      schema:
        type: string
    PageIndex:
      name: pageIndex
      in: path
      required: true
      description: The index of the page in the document
      schema:
        type: integer
        minimum: 0
    AnnotationIdPathParam:
      name: annotationId
      in: path
      required: true
      description: The ID of the annotation
      schema:
        type: string
    Password:
      in: header
      name: pspdfkit-pdf-password
      schema:
        type: string
        default: ''
      description: |-
        The PDF document password.

        The value can be either either a plain-text password or a base64 encoded password in a form `base64:<encoded-password>`.
        Use the Base64 encoding if your password contains characters that are not allowed in HTTP header or would be otherwise mangled
        (e.g. trailing or leading spaces)

        If the document is password protected, any operations performed on it require supplying a password.
      examples:
        plainTextPassword:
          value: password
          summary: Plain-text password
        base64EncodedPassword:
          value: base64:Cg==
          summary: Base64 encoded password
    FormFieldIdPathParam:
      name: formFieldId
      in: path
      required: true
      description: The ID of the form field
      schema:
        type: string
    FormFieldWidgetIdPathParam:
      name: formFieldWidgetId
      in: path
      required: true
      description: The ID of the form field widget
      schema:
        type: string
    SecretType:
      name: secretType
      in: path
      required: true
      description: The Secret type
      schema:
        type: string
        enum:
          - jwt
          - dashboard_password
          - secret_key_base
    SecretId:
      name: secretId
      in: path
      required: true
      description: The Secret ID
      schema:
        type: integer
    Q:
      name: q
      in: query
      required: true
      description: 'The search query: a piece of text, a preset name, or a regular expression.'
      schema:
        oneOf:
          - type: string
            minimum: 3
            example: support@nutrient.io
          - type: string
            example: '@nutrient\\.io'
          - $ref: '#/components/schemas/SearchPreset'
    Type:
      name: type
      in: query
      required: false
      description: 'The type of the search: `text`, `preset`, or `regex`.'
      schema:
        type: string
        enum:
          - text
          - regex
          - preset
    Start:
      name: start
      in: query
      required: false
      description: The index of the page from where you want to start the search.
      schema:
        type: integer
        minimum: 0
        default: 0
    Limit:
      name: limit
      in: query
      required: false
      description: The index of the last page included in the search. The default is the page count of the document.
      schema:
        type: integer
        minimum: 0
    IncludeAnnotations:
      name: include_annotations
      in: query
      required: false
      description: When true, search inside the document annotations.
      schema:
        type: boolean
        default: false
    CaseSensitive:
      name: case_sensitive
      in: query
      required: false
      description: |-
        Overrides the default search case sensitivity: case insensitive for text
        search and case sensitive for regex/preset search.
      schema:
        type: boolean
    DocumentType:
      in: query
      name: type
      required: false
      schema:
        type: string
        enum:
          - pdf
          - pdfa
        default: pdf
      description: Use this option to determine the format of the downloaded PDF file
    Source:
      in: query
      name: source
      required: false
      schema:
        type: boolean
      description: |-
        If set to `true`, the originally uploaded version of the PDF file will be fetched.
        The remaining properties are mutually exclusive with this property.
    Flatten:
      in: query
      name: flatten
      required: false
      schema:
        type: boolean
      description: |-
        Determines whether a flattened version of the PDF file will be downloaded. If set to `true`,
        the resulting PDF file will have its annotations burned into the document and will have no annotations.
    RenderAPStreams:
      in: query
      name: render_ap_streams
      required: false
      schema:
        type: boolean
      description: If set to `true`, the resulting PDF file will have its custom AP streams rendered into the document.
    Annotations:
      in: query
      name: annotations
      required: false
      schema:
        type: boolean
      description: If set to `true`, annotations will be included in the downloaded file.
    Comments:
      in: query
      name: comments
      required: false
      schema:
        type: boolean
      description: If set to `true`, comments will be included in the downloaded file.
    Optimize:
      in: query
      name: optimize
      required: false
      schema:
        type: object
        properties:
          grayscaleText:
            type: boolean
            default: false
          grayscaleGraphics:
            type: boolean
            default: false
          grayscaleImages:
            type: boolean
            default: false
          grayscaleFormFields:
            type: boolean
            default: false
          grayscaleAnnotations:
            type: boolean
            default: false
          disableImages:
            type: boolean
            default: false
          mrcCompression:
            type: boolean
            default: false
          imageOptimizationQuality:
            type: integer
            default: 2
            minimum: 1
            maximum: 4
          linearize:
            type: boolean
            default: false
            description: |
              If set to `true`, the resulting PDF file will be linearized.
              This means that the document will be optimized in a special way that allows it to be loaded faster over the network.
              You need the `Linearization` feature to be enabled in your Nutrient Document Engine license in order to use this option.
      description: If set, the resulting PDF file will be optimized according to the provided options.
    Conformance:
      in: query
      name: conformance
      required: false
      schema:
        type: string
        enum:
          - pdfa-1a
          - pdfa-1b
          - pdfa-2a
          - pdfa-2u
          - pdfa-2b
          - pdfa-3a
          - pdfa-3u
      description: Specify the conformance level of the PDF/A file. Requires the type parameter to be present and equal to `pdfa`.
    KeepSignatures:
      in: query
      name: keep_signatures
      required: false
      schema:
        type: boolean
      description: If set to `false`, the signatures and form fields will get flattened in the resulting PDF. Defaults to `true`.
  securitySchemes:
    ApiAuthToken:
      type: apiKey
      in: header
      name: Authorization
  schemas:
    DocumentEngineAnnotation:
      $ref: '#/components/schemas/AnnotationRecord'
    AnnotationCreateSingle:
      type: object
      required:
        - content
      properties:
        content:
          $ref: '#/components/schemas/AnnotationContent'
        user_id:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
        id:
          $ref: '#/components/schemas/AnnotationId'
      description: Represents a single annotation to be created.
    AnnotationCreateSingleWithAttachment:
      type: object
      properties:
        annotation:
          type: object
          required:
            - content
          properties:
            content:
              $ref: '#/components/schemas/AnnotationContent'
            user_id:
              $ref: '#/components/schemas/User'
            group:
              $ref: '#/components/schemas/Group'
      additionalProperties:
        $ref: '#/components/schemas/AttachmentContent'
      description: Represents a single annotation to be created with attachment.
    AnnotationCreateMultiple:
      type: object
      required:
        - annotations
      properties:
        annotations:
          type: array
          items:
            type: object
            required:
              - content
            properties:
              content:
                $ref: '#/components/schemas/AnnotationContent'
              user_id:
                $ref: '#/components/schemas/User'
              group:
                $ref: '#/components/schemas/Group'
      description: Represents multiple annotations to be created.
    AnnotationCreateMultipleWithAttachment:
      type: object
      required:
        - annotations
      properties:
        annotations:
          type: object
          required:
            - annotations
          properties:
            annotations:
              type: array
              items:
                type: object
                required:
                  - content
                properties:
                  content:
                    $ref: '#/components/schemas/AnnotationContent'
                  user_id:
                    $ref: '#/components/schemas/User'
                  group:
                    $ref: '#/components/schemas/Group'
      additionalProperties:
        $ref: '#/components/schemas/AttachmentContent'
      description: Represents multiple annotations to be created with attachment.
    AnnotationId:
      type: string
      description: Annotation ID, unique in scope of a single Instant Layer.
      example: 01DNEDPQQ22W49KDXRFPG4EPEQ
    AnnotationUpdate:
      type: object
      required:
        - content
      properties:
        content:
          $ref: '#/components/schemas/AnnotationContent'
        user_id:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
        id:
          type: string
          example: replace_this_with_an_actual_annotation_id
      description: Represents a single annotation to be updated.
    AnnotationUpdateMultiple:
      type: object
      required:
        - annotations
      properties:
        annotations:
          type: array
          items:
            type: object
            required:
              - content
              - id
            properties:
              content:
                $ref: '#/components/schemas/AnnotationContent'
              user_id:
                $ref: '#/components/schemas/User'
              group:
                $ref: '#/components/schemas/Group'
              id:
                type: string
                example: replace_this_with_an_actual_annotation_id
      description: Represents multiple annotations to be updated.
    AnnotationMultipleResponse:
      type: object
      title: MultipleAnnotationsResponse
      description: Response when multiple annotations are created / updated.
      properties:
        details:
          type: string
          description: A text summary of the status of the request
          example: Operation was partially successful
        request_id:
          type: string
        result:
          type: string
          enum:
            - partial_failure
            - success
            - failure
          description: |
            If all the items in the batch request were successful, then the status will be a success.
            A partial_failure will occur if only a few of the items in the batch request succeeded.
            Failure is when none of the items in the batch succeed.
        status:
          type: integer
          enum:
            - 200
            - 400
            - 500
          description: |
            HTTP status code for the request. The status code is 200 if the request was processed.
            This does not have anything to do with the result - the status code will be 200 even if part of the
            request failed. In the case of total failures such as malformed JSON, or document not found,
            this status will be other than 200.
        data:
          type: array
          description: List of successfully created / updated annotations.
          items:
            type: object
            required:
              - id
              - content
            properties:
              content:
                $ref: '#/components/schemas/AnnotationContent'
              user_id:
                $ref: '#/components/schemas/User'
              group:
                $ref: '#/components/schemas/Group'
              id:
                $ref: '#/components/schemas/AnnotationId'
              updatedBy:
                $ref: '#/components/schemas/User'
        failing_paths:
          type: array
          description: List of failing paths.
          items:
            type: object
            properties:
              path:
                type: string
                example: $.annotations[0]
                description: The index for array items will point to the item in the array Document Engine received in your request as opposed to the data array we are sending in this response
              error:
                type: string
                example: Page index out of bounds.
              details:
                type: string
                example: The page index of the given annotation was greater than the number of pages in the document.
    AsyncJobStatus:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          description: |
            `status` indicates the state of the job.
            If there is more relevant information - particularly important for failed and cancelled jobs,
            then that information will be in `details`.
          required:
            - status
          properties:
            status:
              type: string
              enum:
                - not_started
                - in_progress
                - completed
                - failed
                - cancelled
            details:
              oneOf:
                - type: string
                - type: object
                  additionalProperties: {}
    AttachmentContent:
      type: string
      format: binary
      description: |
        The binary content of an attachment.

        Part name is the SHA-256 hash of the attachment contents.
      example: <binary data>
    BookmarkRecord:
      title: BookmarkRecord
      type: object
      required:
        - id
        - content
      properties:
        content:
          $ref: '#/components/schemas/Bookmark'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        id:
          $ref: '#/components/schemas/RecordId'
    Comment:
      type: object
      description: A single comment in the document
      required:
        - id
        - group
        - createdBy
        - updatedBy
        - content
      properties:
        id:
          $ref: '#/components/schemas/RecordId'
        group:
          $ref: '#/components/schemas/Group'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        content:
          $ref: '#/components/schemas/CommentContent'
    CommentContent:
      oneOf:
        - $ref: '#/components/schemas/InstantComment.v1'
        - $ref: '#/components/schemas/InstantComment.v2'
    CommentCreatedAt:
      type: string
      description: ISO8601 timestamp of when the comment was written
      example: '2019-11-14T15:05:03.089Z'
    CommentCreatorName:
      type:
        - string
        - 'null'
      description: Name of the comment author
      example: John Doe
    CommentCreate:
      type: object
      required:
        - content
      properties:
        id:
          $ref: '#/components/schemas/RecordId'
        user_id:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
        content:
          type: object
          required:
            - text
          properties:
            text:
              $ref: '#/components/schemas/CommentText'
            createdAt:
              $ref: '#/components/schemas/CommentCreatedAt'
            updatedAt:
              $ref: '#/components/schemas/CommentUpdatedAt'
            customData:
              $ref: '#/components/schemas/CustomData'
            creatorName:
              $ref: '#/components/schemas/CommentCreatorName'
    CommentsCreate:
      type: object
      required:
        - comments
      properties:
        comments:
          type: array
          items:
            $ref: '#/components/schemas/CommentCreate'
          description: A list of comments to be added
    CommentsCreateErrors:
      type: object
      properties:
        comments:
          type: array
          items:
            type: object
            example:
              content:
                text:
                  - is required
          description: |
            A list of errors encountered when creating comments.

            Each entry in the list represents errors for a single comment.
    CommentsCreated:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - comments
          properties:
            comments:
              type: array
              items:
                type: object
                required:
                  - id
                properties:
                  id:
                    $ref: '#/components/schemas/RecordId'
              description: IDs of the added comments
    CommentsCreateWithRoot:
      type: object
      required:
        - annotation
        - comments
      properties:
        annotation:
          $ref: '#/components/schemas/AnnotationCreateSingle'
        comments:
          type: array
          items:
            $ref: '#/components/schemas/CommentCreate'
          description: A list of comments to be added
    CommentsCreateErrorsWithRoot:
      type: object
      properties:
        annotation:
          type: object
          example:
            content:
              - is required
          description: |
            Errors encountered when creating root annotation.
        comments:
          type: array
          items:
            type: object
            example:
              content:
                text:
                  - is required
          description: |
            A list of errors encountered when creating comments.

            Each entry in the list represents errors for a single comment.
    CommentsCreatedWithRoot:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - annotation
            - comments
          properties:
            annotation:
              type: object
              required:
                - id
              properties:
                id:
                  $ref: '#/components/schemas/AnnotationId'
            comments:
              type: array
              items:
                type: object
                required:
                  - id
                properties:
                  id:
                    $ref: '#/components/schemas/RecordId'
              description: IDs of the added comments
    CommentsList:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - comments
          properties:
            comments:
              type: array
              description: A list of all comments under the given annotation
              items:
                $ref: '#/components/schemas/Comment'
    CommentText:
      type:
        - string
        - 'null'
      description: Text of a comment
      example: What a wonderful idea!
    CommentUpdatedAt:
      type:
        - string
        - 'null'
      description: ISO8601 timestamp of when the comment was edited
      example: '2019-11-22T18:05:03.712Z'
    CustomData:
      title: CustomData
      type:
        - object
        - 'null'
      additionalProperties: true
      description: Object of arbitrary properties attached to an entity
    CreateDocumentAttachment:
      type: string
      format: binary
      description: |
        Nutrient Document Engine supports importing an XFDF or Instant JSON
        file on upload. This replaces all existing annotations
         in the uploaded PDF with the annotations from the uploaded
         XFDF or Instant JSON file.

        If you want to add annotations to already existing ones
        instead of replacing them when you import an XFDF file, you
        can set `keep_current_annotations` to `true`.
    CreateDocumentId:
      type: string
      description: |
        The document ID.

        Nutrient Document Engine supports providing an arbitrary `document_id`
        on upload. This can be useful when you want to use your own
        identifiers for documents.

        This feature can also be used to migrate from an existing
        document management solution on demand, as we explained in
        the [document migration
        guide](https://www.nutrient.io/guides/document-engine/file-management/migrate/from-amazon-s3/).
      example: 7KPSE41NWKDGK5T9CFS3S53JTP
    CreateDocumentKeepCurrentAnnotations:
      type: boolean
      default: false
      description: |
        Only effective when attaching an XFDF file.

        If you want to add annotations to already existing ones
        instead of replacing them when you import an XFDF file, you
        can set `keep_current_annotations` to `true`.
    CreateDocumentOverwriteExistingDocument:
      type: boolean
      default: false
      description: |
        By default an error is thrown when uploading a document with
        an already existing id.

        If this is set to `true` any existing document will be removed
        before the new document is created using the provided id.
    CreateDocumentSha256:
      type: string
      description: |
        SHA256 checksum of the PDF file.

        When using the API to add a document from a URL, your backend storage must
        always deliver the same file, since the SHA256 will never be recalculated after
        the document is created. If the file on your storage backend changes and
        Nutrient Document Engine needs to refetch the file (e.g. because it's no longer cached),
        this will result in a `hash_mismatch` error on Nutrient Document Engine.
    CreateDocumentTitle:
      type: string
      description: |
        The document title.

        Nutrient Document Engine supports providing an arbitrary `title` on upload,
        which will override the title included in the PDF document (if present).

        The title specified here will not be embedded in the PDF. If you download the PDF,
        the original title will still be shown. In place of the title upload parameter,
        you can set the title via Build instructions with title specified in the PDF output metadata.
        This will actually embed the title in the PDF.
    CreateDocumentInstructions:
      title: Add Document with Instructions
      type: object
      required:
        - instructions
      properties:
        instructions:
          $ref: '#/components/schemas/BuildInstructions'
        storage:
          $ref: '#/components/schemas/StorageConfiguration'
        document_id:
          $ref: '#/components/schemas/CreateDocumentId'
        title:
          $ref: '#/components/schemas/CreateDocumentTitle'
        overwrite_existing_document:
          $ref: '#/components/schemas/CreateDocumentOverwriteExistingDocument'
    CreateDocumentUpload:
      title: Add Document from Upload
      type: object
      required:
        - file
      properties:
        file:
          type: string
          format: binary
          description: The binary content of the file.
          example: <PDF data>
        storage:
          $ref: '#/components/schemas/StorageConfiguration'
        document_id:
          $ref: '#/components/schemas/CreateDocumentId'
        title:
          $ref: '#/components/schemas/CreateDocumentTitle'
        attachment:
          $ref: '#/components/schemas/CreateDocumentAttachment'
        keep_current_annotations:
          $ref: '#/components/schemas/CreateDocumentKeepCurrentAnnotations'
        overwrite_existing_document:
          $ref: '#/components/schemas/CreateDocumentOverwriteExistingDocument'
    CreateDocumentUrl:
      title: Add Document from URL
      type: object
      required:
        - url
      properties:
        document_id:
          $ref: '#/components/schemas/CreateDocumentId'
        title:
          $ref: '#/components/schemas/CreateDocumentTitle'
        url:
          type: string
          description: |
            Absolute URL of the PDF document.

            When using the API to add a document from a URL, your backend storage must
            always deliver the same file, since the SHA256 will never be recalculated after
            the document is created. If the file on your storage backend changes and
            Nutrient Document Engine needs to refetch the file (e.g. because it's no longer cached),
            this will result in a `hash_mismatch` error on Nutrient Document Engine.
        storage:
          $ref: '#/components/schemas/StorageConfiguration'
        copy_asset_to_storage_backend:
          $ref: '#/components/schemas/CreateDocumentCopyAssetToStorageBackend'
        sha256:
          $ref: '#/components/schemas/CreateDocumentSha256'
        attachment:
          $ref: '#/components/schemas/CreateDocumentAttachment'
        keep_current_annotations:
          $ref: '#/components/schemas/CreateDocumentKeepCurrentAnnotations'
        overwrite_existing_document:
          $ref: '#/components/schemas/CreateDocumentOverwriteExistingDocument'
    CreateDocumentCopyAssetToStorageBackend:
      type: boolean
      default: false
      description: |
        By default, a document added by a URL is not persistently stored in
        Nutrient Document Engine and will be fetched from the URL when necessary

        If this is set to `true`, the document will be stored persistently.

        Ignored when the document is not being created by a URL.
    DigitalSignature:
      title: DigitalSignature
      type: object
      description: |
        Represents a digital signature associated with a portion of the document.
        A signature's status is expressed via two properties:
          - **integrity**, which guarantees that the content covered by the signature byte-range hasn't changed since the signature has been applied.
          - **validity**, which guarantees that the entity who applied the signature is who they claim to be.
      required:
        - documentIntegrityStatus
        - certificateChainValidationStatus
        - signatureValidationStatus
        - isTrusted
        - isSelfSigned
        - isExpired
        - documentModifiedSinceSignature
      properties:
        signerName:
          type: string
          example: John Appleseed
        creationDate:
          type: string
          example: '2013-12-19 14:45:26'
        signatureReason:
          type: string
          example: accepted
        signatureLocation:
          type: string
          example: Vienna
        documentIntegrityStatus:
          type: string
          enum:
            - ok
            - tampered_document
            - failed_to_retrieve_signature_contents
            - failed_to_retrieve_byterange
            - failed_to_compute_digest
            - failed_to_retrieve_signing_certificate
            - failed_to_retrieve_public_key
            - failed_encryption_padding
            - failed_unsupported_signature_type
            - general_failure
        certificateChainValidationStatus:
          type: string
          enum:
            - ok
            - ok_but_self_signed
            - ok_but_could_not_check_revocation
            - untrusted
            - expired
            - not_yet_valid
            - invalid
            - revoked
            - failed_to_retrieve_signature_contents
            - general_validation_problem
        signatureValidationStatus:
          type: string
          enum:
            - valid
            - warning
            - error
        isTrusted:
          type: boolean
        isSelfSigned:
          type: boolean
        isExpired:
          type: boolean
        documentModifiedSinceSignature:
          type: boolean
        validFrom:
          type: string
          example: '2023-12-01T15:34:15Z'
        validUntil:
          type: string
          example: '2025-11-30T15:34:14Z'
        type:
          type: string
          enum:
            - pspdfkit/signature-info
        signatureFormFQN:
          type: string
          example: Signature-a9c0376e-15cd-416f-9b8f-bbf341fae0ca
        ltv:
          type: boolean
          example: false
        signatureType:
          type: string
          enum:
            - cms
            - cades
    DigitalSignatures:
      title: DigitalSignatures
      type: object
      properties:
        checkedAt:
          type: string
          format: datetime
        documentModifiedSinceSignature:
          type: boolean
        status:
          type: string
          enum:
            - valid
            - warning
            - error
        signatures:
          type: array
          items:
            $ref: '#/components/schemas/DigitalSignature'
    DigitalSignatureCreate:
      allOf:
        - $ref: '#/components/schemas/CreateDigitalSignature'
        - $ref: '#/components/schemas/CreateDigitalSignatureCustom'
    DigitalSignaturesRefresh:
      $ref: '#/components/schemas/RefreshDigitalSignatures'
    DocumentId:
      type: string
      example: 7KPZW8XFGM4F1C92KWBK1B748M
      description: The ID of the document.
    DocumentInfo:
      title: DocumentInfo
      type: object
      required:
        - pageCount
      properties:
        hasXFA:
          type: boolean
          description: Are XFA forms present in the document?
        metadata:
          type: object
          properties:
            title:
              type: string
            author:
              type: string
            subject:
              type: string
            keywords:
              type: string
            producer:
              type: string
            creator:
              type: string
            dateCreated:
              $ref: '#/components/schemas/IsoDateTime'
            dateModified:
              $ref: '#/components/schemas/IsoDateTime'
        pageCount:
          type: integer
          description: The number of pages of the document.
          minimum: 1
          example: 3
        pages:
          type: array
          items:
            $ref: '#/components/schemas/Page'
        permissions:
          type: object
          description: |
            The [document's permission](https://www.nutrient.io/guides/web/features/document-permissions/).
          properties:
            annotationAndForms:
              type: boolean
              description: |
                Indicates whether annotations and form fields can be added or modified,
                and if form fields can be filled in.
              example: true
            assemble:
              type: boolean
              description: |
                Indicates whether document pages can be rotated, added or deleted.
                Also determines if outline items and thumbnail images can be created.
              example: false
            extract:
              type: boolean
              description: Indicates whether text and graphics in the document can be extracted (copied).
              example: true
            extractAccessibility:
              type: boolean
              description: |
                Indicates whether text and graphics in the document can be extracted in support of accessibility
                to users with disabilities or for other purposes.
              example: true
            fillForms:
              type: boolean
              description: Indicates whether form fields can be filled in.
              example: true
            modification:
              type: boolean
              description: |
                Indicates whether the document can be modified in any other way than specified
                by other permissions.
              example: false
            print:
              type: boolean
              description: Indicates whether the document can be printed.
              example: true
            printHighQuality:
              description: Indicates whether the document can be printed in high quality.
              type: boolean
              example: false
        title:
          $ref: '#/components/schemas/Title'
    DocumentCreated:
      type: object
      required:
        - document_id
        - errors
        - password_protected
        - sourcePdfSha256
        - title
        - createdAt
      properties:
        document_id:
          $ref: '#/components/schemas/DocumentId'
        errors:
          $ref: '#/components/schemas/Errors'
        password_protected:
          $ref: '#/components/schemas/PasswordProtected'
        sourcePdfSha256:
          $ref: '#/components/schemas/SourcePdfSha256'
        title:
          $ref: '#/components/schemas/Title'
        createdAt:
          $ref: '#/components/schemas/IsoDateTime'
    DocumentProperties:
      title: DocumentProperties
      type: object
      required:
        - passwordProtected
        - sourcePdfSha256
        - title
        - byteSize
        - createdAt
      properties:
        passwordProtected:
          $ref: '#/components/schemas/PasswordProtected'
        sourcePdfSha256:
          $ref: '#/components/schemas/SourcePdfSha256'
        title:
          $ref: '#/components/schemas/Title'
        byteSize:
          $ref: '#/components/schemas/ByteSize'
        createdAt:
          $ref: '#/components/schemas/IsoDateTime'
        storage:
          type: object
          description: |
            Information about the assert storage for the underlying PDF file.
          required:
            - type
          properties:
            type:
              type: string
              description: |
                * When the type is `built-in`, it uses the built-in database-backed storage.
                * When the type is `s3`, it uses the S3 asset storage. The response also includes the S3 bucket used.
                * When the type is `remote`, it indicates a remote PDF file. The response includes the URL of the file.
              enum:
                - built-in
                - remote
                - s3
            bucket:
              type: string
              description: Name of the S3 bucket storing the PDF file. Set only if storage type is `s3`.
            url:
              type: string
              description: URL pointing at the PDF file. Set only if storage type is `remote`.
    EmbeddedFile:
      title: EmbeddedFile
      type: object
      required:
        - id
      properties:
        content:
          type: object
          required:
            - type
            - fileAttachmentId
            - v
          properties:
            v:
              type: integer
              minimum: 1
              example: 1
            type:
              type: string
              enum:
                - pspdfkit/embedded-file
            fileAttachmentId:
              type: string
            contentType:
              type: string
            description:
              type: string
            fileName:
              type: string
            fileSize:
              type: integer
              example: 22348
            updatedAt:
              $ref: '#/components/schemas/IsoDateTime'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        id:
          type: string
    Errors:
      type: array
      description: |
        An array of errors encountered during the operation.
      items:
        $ref: '#/components/schemas/Error'
    Error:
      type: object
      description: A single error with a reason.
      required:
        - reason
      properties:
        reason:
          type: string
    FormFieldValueRecord:
      allOf:
        - $ref: '#/components/schemas/FormFieldValue'
        - type: object
          required:
            - createdBy
            - updatedBy
          properties:
            createdBy:
              $ref: '#/components/schemas/User'
            updatedBy:
              $ref: '#/components/schemas/User'
            group:
              type:
                - string
                - 'null'
              description: |
                The form field value group. Group allows to grant access to resources via Collaboration Permissions.

                The group of the form field value is always the group of the associated form field.
    FormFieldValueUpdate:
      type: object
      properties:
        formFieldValues:
          type: array
          items:
            type: object
            required:
              - name
              - value
            properties:
              name:
                type: string
              value:
                type: string
    FormFieldValuesRecords:
      type: array
      items:
        $ref: '#/components/schemas/FormFieldValueRecord'
    FormFieldWidgetId:
      type: string
      description: A unique identifier for the form field widget. It is unique in a layer
      example: 7KPSXX1NMNJ2WFDKN7BKQK9KZE
    FormFieldWidgetContent:
      $ref: '#/components/schemas/WidgetAnnotation'
    FormFieldWidgetCreate:
      type: object
      description: A single widget in a document layer
      required:
        - content
      properties:
        id:
          $ref: '#/components/schemas/FormFieldWidgetId'
          description: An identifier for a widget. It is unique across a layer
        user_id:
          $ref: '#/components/schemas/User'
        content:
          $ref: '#/components/schemas/WidgetAnnotation'
    FormFieldWidgetUpdate:
      type: object
      required:
        - content
        - id
      properties:
        content:
          $ref: '#/components/schemas/WidgetAnnotation'
        user_id:
          $ref: '#/components/schemas/User'
        id:
          $ref: '#/components/schemas/FormFieldWidgetId'
          description: This is an identifier for this widget. It is unique across the layer. It is required for update operations.
      description: |
        Note that you cannot set the group for a widget.
        The widget will inherit the group of the form field it is associated with.
    FormFieldWidget:
      type: object
      description: A single form field widget in a document layer
      required:
        - id
        - group
        - createdBy
        - updatedBy
        - content
      properties:
        id:
          type: string
          description: An identifier for a form field widget. It is unique across a layer
        group:
          $ref: '#/components/schemas/Group'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        content:
          $ref: '#/components/schemas/WidgetAnnotation'
    FormFieldWidgetWithFormField:
      type: object
      description: A single form field widget in a document layer and the form field it's associated with
      required:
        - id
        - group
        - createdBy
        - updatedBy
        - content
      properties:
        id:
          type: string
          description: An identifier for a form field widget. It is unique across a layer
        group:
          $ref: '#/components/schemas/Group'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        content:
          $ref: '#/components/schemas/WidgetAnnotation'
        formField:
          $ref: '#/components/schemas/FormFieldRecord'
    FormFieldCreate:
      type: object
      required:
        - content
      description: |
        Any widget IDs you set in the `content.annotationIds` field will automatically associate those widgets
        with the form field you are creating.
        Note that the form field's group will be inherited by any widgets and values associated with it
      properties:
        id:
          $ref: '#/components/schemas/RecordId'
        user_id:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
        content:
          $ref: '#/components/schemas/FormField'
    FormFieldUpdate:
      type: object
      required:
        - content
        - id
      description: |
        Any widget IDs you set in the `content.annotationIds` field will automatically associate those widgets
        with the form field you are updating while dropping previously associated widgets.
        Note that the form field's group will be inherited by any widgets and values associated with it
      properties:
        id:
          $ref: '#/components/schemas/RecordId'
        user_id:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
        content:
          $ref: '#/components/schemas/FormField'
    FormFieldRecord:
      type: object
      properties:
        id:
          $ref: '#/components/schemas/RecordId'
        group:
          $ref: '#/components/schemas/Group'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        createdAt:
          $ref: '#/components/schemas/IsoDateTime'
        updatedAt:
          $ref: '#/components/schemas/IsoDateTime'
        content:
          $ref: '#/components/schemas/FormField'
    FormFieldWithWidgets:
      type: object
      allOf:
        - $ref: '#/components/schemas/FormFieldRecord'
        - type: object
          properties:
            widgetAnnotations:
              type: array
              items:
                $ref: '#/components/schemas/FormFieldWidget'
              description: The widgets associated with this form field.
    HighlightedText:
      type: object
      required:
        - annotation
        - text
      properties:
        annotation:
          $ref: '#/components/schemas/AnnotationRecord'
        text:
          type: string
          description: The highlighted text.
          example: a very important piece of content
      description: |
        A piece highlighted text along with corresponding markup annotation.
    InstantJson:
      title: Instant JSON
      description: |
        Instant JSON is a format for bringing annotations and bookmarks into a modern format while keeping all important properties to make the Instant JSON spec work with PDF.
      type: object
      properties:
        format:
          type: string
          enum:
            - https://pspdfkit.com/instant-json/v1
        annotations:
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/Annotation'
              - $ref: '#/components/schemas/Annotation.v1'
        attachments:
          $ref: '#/components/schemas/Attachments'
        formFields:
          type: array
          items:
            $ref: '#/components/schemas/FormField'
        formFieldValues:
          type: array
          items:
            $ref: '#/components/schemas/FormFieldValue'
        bookmarks:
          type: array
          items:
            $ref: '#/components/schemas/Bookmark'
        skippedPdfObjectIds:
          type: array
          description: An array of PDF object IDs that should be skipped during the import process. Whenever an object ID is marked as skipped, it'll no longer be loaded from the original PDF. Instead, it could be defined inside the annotations array with the same pdfObjectId. If this is the case, the PDF viewer will display the new annotation, which signals an update to the original one. If an object ID is marked as skipped but the annotations array doesn't contain an annotation with the same pdfObjectId, it'll be interpreted as a deleted annotation. An annotation inside the annotations array without the pdfObjectId property is interpreted as a newly created annotation.
          items:
            type: integer
            minimum: 0
        pdfId:
          type: object
          description: PDF document identifiers, base64 encoded. This is used to track version of PDF document this JSON has been exported from.
          properties:
            permanent:
              type: string
              description: Permanent document identifier based on the contents of the file at the time it was originally created. Does not change when the file is saved incrementally.
              example: 9C3nLxNzQBuBBzv96LbdMg==
            changing:
              type: string
              description: Document identifier based on the file's contents at the time it was last updated.
              example: Oi+XccZpDHChV7I=
      required:
        - format
    IsoDateTime:
      title: IsoDateTime
      type: string
      description: Date and time in ISO8601 format with timezone.
      example: '2019-09-16T15:05:03.712909Z'
    LayerCreateWithSourceLayer:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          description: The name of the new layer.
          example: my-layer
        source_layer_name:
          type: string
          description: |
            The name of the layer the new one will be based on. If not provided or the layer with
            the given name doesn't exist, the base layer is assumed instead.
          example: my-existing-layer
    JWT:
      type: string
      example: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJtaXNzaW9ucyI6WyJyZWFkLWRvY3VtZW50Iiwid3JpdGUiLCJkb3dubG9hZCJdLCJkb2N1bWVudF9pZCI6IjdLUFNKTkZCVkpFNzlXR0IxM05DRzdTMlgzIiwibGF5ZXIiOiJwUUNHREVpVVFFWTdleEJfcW5zeC1BIiwiaWF0IjoxNjYwOTA4ODk0LCJleHAiOjE2NjExNjgwOTQsImp0aSI6IjU5OTAwZDVmLTIyMDgtNDNjMy1iYzk3LWMxMjgzNDI3NmM4YyJ9.BtBbivWY2cC3R_8tm1j_GxtcQFIvmGkTSsz78EXiJEsTUCkRcfZWN2lOsI0Dn2-M6sG21QSbToEhVMvL5r_4sg
      description: A JSON Web Token.
    LayerCreateWithSourceLayerAndInstantJson:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          description: The name of the new layer.
          example: my-layer
        source_layer_name:
          type: string
          description: |
            The name of the layer the new one will be based on. If not provided or the layer with
            the given name doesn't exist, the base layer is assumed instead.
          example: my-existing-layer
        instant.json:
          $ref: '#/components/schemas/InstantJson'
    LayerCreated:
      type: object
      required:
        - name
        - errors
      properties:
        name:
          type: string
          description: The name of the newly created layer.
          example: my-layer
        errors:
          $ref: '#/components/schemas/Errors'
    OutlineElements:
      title: OutlineElements
      type: array
      description: An array of outline elements.
      items:
        $ref: '#/components/schemas/OutlineElement'
    Prerender:
      type: object
      properties:
        scales:
          type: array
          items:
            type: integer
            enum:
              - 1
              - 2
              - 4
              - 6
              - 8
              - 12
              - 16
          default:
            - 1
            - 2
            - 4
          description: Allows to prerender multiple versions of the pages scaled by provided factors.
          example:
            - 1
            - 2
            - 4
        start_page:
          type: integer
          minimum: 0
          default: 0
          description: 0-based index of the first of the prerendered pages.
          example: 0
        end_page:
          type: integer
          minimum: 0
          default: 9
          description: |
            0-based index of the last of the prerendered pages. If this value
            is higher than the number of pages in the document, it will be
            automatically adjusted.
          example: 3
    RecordId:
      title: RecordId
      type: string
      description: |
        An unique Instant JSON identifier of the record. Must be unique in a layer.
      example: 01DNEDPQQ22W49KDXRFPG4EPEQ
    RedactionsCreate:
      $ref: '#/components/schemas/CreateRedactions'
    RedactionsCreateErrors:
      $ref: '#/components/schemas/CreateRedactionsErrors'
    StorageConfiguration:
      title: DocumentStorageConfiguration
      type: object
      oneOf:
        - type: object
          title: s3
          required:
            - backend
          properties:
            backend:
              type: string
              enum:
                - s3
            bucketName:
              type: string
            bucketRegion:
              type: string
        - type: object
          title: azure
          required:
            - backend
          properties:
            backend:
              type: string
              enum:
                - azure
        - type: object
          title: built_in
          required:
            - backend
          properties:
            backend:
              type: string
              enum:
                - built_in
    TextLine:
      type: object
      description: A line of text on the document's page.
      required:
        - contents
      properties:
        contents:
          type: string
          description: Contents of the line of text.
          example: PSPDKit is a leading PDF SDK for Mobile and Web
        height:
          type: number
          description: Height of the line of text in points.
          example: 14
        width:
          type: number
          description: Width of the line of text in points.
          example: 331.7496337890625
        left:
          type: number
          description: Distance from the left edge of the page in points.
          example: 79.02290344238281
        top:
          type: number
          description: Distance from the top edge of the page in points.
          example: 312.2259521484375
    PageText:
      type: object
      description: An object with text lines on the document's page.
      required:
        - pageIndex
        - textLines
      properties:
        pageIndex:
          $ref: '#/components/schemas/DocumentPageIndex'
        textLines:
          type: array
          items:
            $ref: '#/components/schemas/TextLine'
    Page:
      title: Page
      type: object
      required:
        - pageIndex
      properties:
        height:
          type: number
          description: Height of the page in points.
          example: 842
        matrix:
          type: array
          items:
            type: number
        rawPdfBoxes:
          type: object
          properties:
            cropBox:
              type: array
              items:
                type: number
            mediaBox:
              type: array
              items:
                type: number
            bleedBox:
              type: array
              items:
                type: number
            trimBox:
              type: array
              items:
                type: number
            artBox:
              type: array
              items:
                type: number
        reverseMatrix:
          type: array
          items:
            type: number
        transformedBBox:
          type: array
          items:
            type: number
        untransformedBBox:
          type: array
          items:
            type: number
        pageIndex:
          $ref: '#/components/schemas/DocumentPageIndex'
        pageLabel:
          type: string
          description: Label of the page.
          example: '1'
        rotation:
          type: integer
          enum:
            - 0
            - 90
            - 180
            - 270
          description: Clockwise rotation of the page.
          example: 0
        width:
          type: number
          description: Width of the page in points.
          example: 595
    PageIndex:
      $ref: '#/components/schemas/DocumentPageIndex'
    PasswordProtected:
      type: boolean
      description: Indicates whether the document is password protected.
      example: true
    ByteSize:
      type: integer
      minimum: 1
      description: The size of the document in bytes.
      example: 192000
    SourcePdfSha256:
      type: string
      description: SHA256 hash of the PDF file underlying the document.
      example: 1defd934dbbf77587eb9b7f45d162d2a3aea16c840a9e7cfa190fb2ea1f40a76
    SearchResults:
      title: SearchResults
      type: array
      items:
        $ref: '#/components/schemas/SearchResult'
      description: An array of search results.
    Title:
      type:
        - string
        - 'null'
      description: The document title.
      example: Nutrient Document Engine API Specification
    User:
      title: User
      type:
        - string
        - 'null'
      description: |
        The user identifier.

        Note that Nutrient Document Engine does not provide any kind of user management and accepts
        any string (or `null`) as a valid user ID.

        For records created or updated in the browser, the `user_id `is extracted from the
        JSON Web Token (JWT) used for authentication.
    ValidatePDFAResult:
      title: ValidatePDFAResult
      type: object
      description: PDF/A Validation report
      properties:
        Conformance:
          type: string
          description: The level of PDF/A conformance. `None` if PDF is non-conformant.
        IsValid:
          type: boolean
          description: true if PDF/A is conformant, false otherwise.
        ValidationLog:
          type: object
          properties:
            ValidationReport:
              type: object
              properties:
                Details:
                  type: object
                  properties:
                    FailedChecks:
                      type: object
                      properties:
                        '@Count':
                          type: string
                          description: Number of failed checks.
                        Check:
                          type: array
                          items:
                            type: object
                            properties:
                              '@ID':
                                type: string
                                description: ID of the failing check.
                              '@OccurenceCount':
                                type: string
                                description: Count of this failing check.
                              Occurence:
                                type: object
                                properties:
                                  '@Context':
                                    type: string
                                  '@ObjReference':
                                    type: string
                                  '@Statement':
                                    type: string
                                    description: Description of the failure.
                ValidationProfile:
                  type: object
                  properties:
                    '@Conformance':
                      type: string
                    '@Level':
                      type: string
                    '@Part':
                      type: string
                ValidationResult:
                  type: object
                  properties:
                    '@IsCompliant':
                      type: string
                    '@Statement':
                      type: string
    Group:
      title: Group
      type:
        - string
        - 'null'
      description: |
        The resource group.

        Group allows to grant access to resources via Collaboration Permissions.
    AnnotationIdsAll:
      title: All annotations
      type: string
      example: all
      description: The string "all" to remove all annotations.
    AnnotationIdsList:
      title: Annotation IDs
      type: array
      items:
        type: string
      description: A list of annotation ids to remove.
    DeleteAnnotations:
      type: object
      required:
        - annotationIds
      properties:
        annotationIds:
          example: all
          oneOf:
            - $ref: '#/components/schemas/AnnotationIdsAll'
            - $ref: '#/components/schemas/AnnotationIdsList'
    FileHandle:
      oneOf:
        - type: object
          title: Remote file
          description: Object pointing to remote file
          properties:
            url:
              type: string
              description: Specifies the URL from a file can be downloaded
              example: https://remote-file-storage/input-file
            sha256:
              type: string
              description: |
                Optional parameter to verify a downloaded file using provided SHA256 hash.
                It is expected to be base16 encoded using lowercase.
          required:
            - url
        - type: string
          title: Uploaded file
          description: Specifies the name of multipart part containing a file
          example: file-from-multipart
    PageRange:
      type: object
      description: |
        Defines the range of pages in a document. The indexing starts from 0. It is possible
        to use negative numbers to refer to pages from the last page. For example, `-1` refers to the last page.
      properties:
        start:
          type: integer
          default: 0
        end:
          type: integer
          default: -1
    PageLayout:
      type: object
      description: |
        Defines the layout of the generated pages.
      properties:
        orientation:
          type: string
          enum:
            - portrait
            - landscape
          description: |
            The orientation of generated pages.
          default: portrait
        size:
          oneOf:
            - type: string
              title: Preset
              description: |
                Page size preset.
              enum:
                - A0
                - A1
                - A2
                - A3
                - A4
                - A5
                - A6
                - A7
                - A8
                - Letter
                - Legal
            - type: object
              title: Custom
              description: |
                The dimensions of generated pages.
              properties:
                width:
                  type: number
                  description: |
                    The width of pages in mm.
                  example: 210
                  minimum: 1
                height:
                  type: number
                  description: |
                    The height of pages in mm.
                  example: 297
                  minimum: 1
        margin:
          type: object
          description: |
            The margins of generated pages. All dimensions are in mm.
          properties:
            left:
              type: number
              minimum: 0
              default: 0
            top:
              type: number
              minimum: 0
              default: 0
            right:
              type: number
              minimum: 0
              default: 0
            bottom:
              type: number
              minimum: 0
              default: 0
    ApplyInstantJsonAction:
      type: object
      required:
        - type
        - file
      properties:
        type:
          type: string
          description: |
            Apply the Instant JSON to the document to import annotations or forms to a document.
          enum:
            - applyInstantJson
        file:
          $ref: '#/components/schemas/FileHandle'
    ApplyXfdfAction:
      type: object
      required:
        - type
        - file
      properties:
        type:
          type: string
          description: |
            Apply the XFDF to the document to import annotations to a document.
          enum:
            - applyXfdf
        file:
          $ref: '#/components/schemas/FileHandle'
    FlattenAction:
      type: object
      required:
        - type
      properties:
        type:
          type: string
          description: |
            Flatten the annotations in the document.
          enum:
            - flatten
        annotationIds:
          type: array
          description: |
            Annotation IDs to flatten. These can be annotation IDs or `pdfObjectId`s.
            If not specified, all annotations will be flattened.
          items:
            oneOf:
              - type: string
              - type: integer
    OcrLanguage:
      type: string
      description: |
        Language to be used for the OCR text extraction. You can find the list of supported languages in our [guides](https://www.nutrient.io/guides/document-engine/ocr/language-support/)
      enum:
        - croatian
        - czech
        - danish
        - dutch
        - english
        - finnish
        - french
        - german
        - indonesian
        - italian
        - malay
        - norwegian
        - polish
        - portuguese
        - serbian
        - slovak
        - slovenian
        - spanish
        - swedish
        - turkish
        - welsh
    OcrAction:
      type: object
      required:
        - type
        - language
      properties:
        type:
          type: string
          description: |
            Perform optical character recognition (OCR) in the document.
          enum:
            - ocr
        language:
          $ref: '#/components/schemas/OcrLanguage'
    RotateAction:
      type: object
      required:
        - type
        - rotateBy
      properties:
        type:
          type: string
          description: |
            Rotate all pages by the angle specified.
          enum:
            - rotate
        rotateBy:
          type: number
          description: |
            The angle by which the pages should be rotated, clockwise.
          enum:
            - 90
            - 180
            - 270
    WatermarkDimension:
      type: object
      required:
        - value
        - unit
      properties:
        value:
          type: number
          description: Dimension value
          example: 100
        unit:
          type: string
          description: Dimension unit
          enum:
            - pt
            - '%'
    BaseWatermarkAction:
      type: object
      required:
        - type
        - width
        - height
      properties:
        type:
          type: string
          description: |
            Watermark all pages with text watermark.
          enum:
            - watermark
        width:
          allOf:
            - type: object
              description: |
                Width of the watermark in PDF points.
            - $ref: '#/components/schemas/WatermarkDimension'
        height:
          allOf:
            - type: object
              description: |
                Height of the watermark in PDF points.
            - $ref: '#/components/schemas/WatermarkDimension'
        top:
          allOf:
            - type: object
              description: |
                Offset of the watermark from the top edge of a page.
            - $ref: '#/components/schemas/WatermarkDimension'
        right:
          allOf:
            - type: object
              description: |
                Offset of the watermark from the right edge of a page.
            - $ref: '#/components/schemas/WatermarkDimension'
        bottom:
          allOf:
            - type: object
              description: |
                Offset of the watermark from the bottom edge of a page.
            - $ref: '#/components/schemas/WatermarkDimension'
        left:
          allOf:
            - type: object
              description: |
                Offset of the watermark from the left edge of a page.
            - $ref: '#/components/schemas/WatermarkDimension'
        rotation:
          type: number
          description: |
            Rotation of the watermark in counterclockwise degrees.
          default: 0
        opacity:
          type: number
          description: Watermark opacity. 0 is fully transparent, 1 is fully opaque.
          minimum: 0
          maximum: 1
    TextWatermarkAction:
      allOf:
        - $ref: '#/components/schemas/BaseWatermarkAction'
        - type: object
          title: Text
          required:
            - text
          properties:
            text:
              type: string
              description: |
                Text used for watermarking
            fontFamily:
              type: string
              description: The font to render the text. Fonts are client specific, so you should only use fonts you know are present in the browser where they should be displayed. If a font isn't found, PSPDFKit will automatically fall back to a sans-serif font.
              example: Helvetica
            fontSize:
              description: Size of the text in points.
              type: integer
              example: 10
            fontColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A foreground color of the text.
              example: '#ffffff'
            fontStyle:
              type: array
              description: Text style. Can be only italic, only bold, italic and bold, or none of these.
              items:
                type: string
                enum:
                  - bold
                  - italic
    ImageWatermarkAction:
      allOf:
        - $ref: '#/components/schemas/BaseWatermarkAction'
        - type: object
          title: Image
          required:
            - image
          properties:
            image:
              $ref: '#/components/schemas/FileHandle'
    WatermarkAction:
      oneOf:
        - $ref: '#/components/schemas/TextWatermarkAction'
        - $ref: '#/components/schemas/ImageWatermarkAction'
    _schemas_PageIndex:
      type: integer
      description: Page index of the annotation. 0 is the first page.
      example: 0
      minimum: 0
    AnnotationBbox:
      type: array
      minItems: 4
      maxItems: 4
      items:
        type: number
      description: Bounding box of the annotation within the page in a form [left, top, width, height].
      example:
        - 255.10077620466092
        - 656.7566095695641
        - 145.91672653256705
        - 18.390804597701162
    BaseAction:
      title: BaseAction
      type: object
      properties:
        subAction:
          type: object
          description: Sub-action to execute after the action has been executed.
    GoToAction:
      title: GoToAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: GoToAction
          type: object
          properties:
            type:
              type: string
              enum:
                - goTo
            pageIndex:
              type: integer
              description: Page index to navigate to. 0 is the first page.
              minimum: 0
          required:
            - type
            - pageIndex
    GoToRemoteAction:
      title: GoToRemoteAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: GoToRemoteAction
          type: object
          properties:
            type:
              type: string
              enum:
                - goToRemote
            relativePath:
              type: string
              description: The relative path of the file to open.
              example: /other_document.pdf
            namedDestination:
              type: string
          required:
            - type
            - relativePath
    GoToEmbeddedAction:
      title: GoToEmbeddedAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: GoToEmbeddedAction
          type: object
          properties:
            type:
              type: string
              enum:
                - goToEmbedded
            relativePath:
              type: string
              description: The relative path to the embedded file.
              example: /other_document.pdf
            newWindow:
              type: boolean
              description: Whether to open the file in a new window.
            targetType:
              type: string
              enum:
                - parent
                - child
          required:
            - type
            - relativePath
    LaunchAction:
      title: LaunchAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: LaunchAction
          type: object
          properties:
            type:
              type: string
              enum:
                - launch
            filePath:
              type: string
              description: The file path to launch.
              example: /other_document.pdf
          required:
            - type
            - filePath
    URIAction:
      title: URIAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: URIAction
          type: object
          properties:
            type:
              type: string
              enum:
                - uri
            uri:
              type: string
              example: https://www.nutrient.io
          required:
            - type
            - uri
    AnnotationReference:
      title: AnnotationReference
      type: object
      properties:
        fieldName:
          type: string
        pdfObjectId:
          type: integer
    HideAction:
      title: HideAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: HideAction
          type: object
          properties:
            type:
              type: string
              enum:
                - hide
            hide:
              type: boolean
            annotationReferences:
              type: array
              items:
                $ref: '#/components/schemas/AnnotationReference'
          required:
            - type
            - hide
            - annotationReferences
    JavaScriptAction:
      title: JavaScriptAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: JavaScriptAction
          type: object
          properties:
            type:
              type: string
              enum:
                - javascript
            script:
              type: string
          required:
            - type
            - script
    SubmitFormAction:
      title: SubmitFormAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: SubmitFormAction
          type: object
          properties:
            type:
              type: string
              enum:
                - submitForm
            uri:
              type: string
            flags:
              type: array
              items:
                type: string
                enum:
                  - includeExclude
                  - includeNoValueFields
                  - exportFormat
                  - getMethod
                  - submitCoordinated
                  - xfdf
                  - includeAppendSaves
                  - includeAnnotations
                  - submitPDF
                  - canonicalFormat
                  - excludeNonUserAnnotations
                  - excludeFKey
                  - embedForm
            fields:
              type: array
              items:
                $ref: '#/components/schemas/AnnotationReference'
          required:
            - type
            - uri
            - flags
    ResetFormAction:
      title: ResetFormAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: ResetFormAction
          type: object
          properties:
            type:
              type: string
              enum:
                - resetForm
            flags:
              type: string
              enum:
                - includeExclude
            fields:
              type: array
              items:
                $ref: '#/components/schemas/AnnotationReference'
          required:
            - type
    NamedAction:
      title: NamedAction
      allOf:
        - $ref: '#/components/schemas/BaseAction'
        - title: NamedAction
          type: object
          properties:
            type:
              type: string
              enum:
                - named
            action:
              type: string
              enum:
                - nextPage
                - prevPage
                - firstPage
                - lastPage
                - goBack
                - goForward
                - goToPage
                - find
                - print
                - outline
                - search
                - brightness
                - zoomIn
                - zoomOut
                - saveAs
                - info
          required:
            - type
            - action
    Action:
      description: |
        Represents a PDF action.

        There are many different action types. You can learn more about their semantics
        [here](https://www.nutrient.io/guides/ios/annotations/pdf-actions/).

        All actions have a `type` property. Depending on the type, the action object
        includes additional properties.
      example:
        type: goTo
        pageIndex: 0
      type: object
      oneOf:
        - $ref: '#/components/schemas/GoToAction'
        - $ref: '#/components/schemas/GoToRemoteAction'
        - $ref: '#/components/schemas/GoToEmbeddedAction'
        - $ref: '#/components/schemas/LaunchAction'
        - $ref: '#/components/schemas/URIAction'
        - $ref: '#/components/schemas/HideAction'
        - $ref: '#/components/schemas/JavaScriptAction'
        - $ref: '#/components/schemas/SubmitFormAction'
        - $ref: '#/components/schemas/ResetFormAction'
        - $ref: '#/components/schemas/NamedAction'
    AnnotationOpacity:
      type: number
      description: Annotation opacity. 0 is fully transparent, 1 is fully opaque.
      minimum: 0
      maximum: 1
    PdfObjectId:
      type: integer
      description: The PDF object ID of the annotation from the source PDF.
    AnnotationCustomData:
      type:
        - object
        - 'null'
      additionalProperties: true
      description: |
        Object of arbitrary properties attached to the annotations. PSPDFKit won't modify this data when processing annotations.
      example:
        foo: bar
    BaseAnnotation:
      title: BaseAnnotation
      type: object
      properties:
        v:
          type: integer
          enum:
            - 2
          description: The specification version that the record is compliant to.
        type:
          type: string
          description: The type of the annotation.
        pageIndex:
          $ref: '#/components/schemas/_schemas_PageIndex'
        bbox:
          $ref: '#/components/schemas/AnnotationBbox'
        action:
          $ref: '#/components/schemas/Action'
        opacity:
          $ref: '#/components/schemas/AnnotationOpacity'
        pdfObjectId:
          $ref: '#/components/schemas/PdfObjectId'
        id:
          type: string
          description: The unique Instant JSON identifier of the annotation.
          example: 01DNEDPQQ22W49KDXRFPG4EPEQ
        flags:
          type: array
          description: |
            Array of annotation flags.

            | Flag | Description |
            | ---- | ----------- |
            | noPrint | Don't print. |
            | noZoom | Don't zoom with page. |
            | noRotate | Don't rotate. |
            | noView | Don't display, can be still printed. |
            | hidden | Don't display, don't print, disable any interaction with user. |
            | invisible | Ignore annotation AP stream. |
            | readOnly | Don't allow the annotation to be deleted or its properties modified. |
            | locked | Same as `readOnly` but allows changing annotation contents. |
            | lockedContents | Don't allow the contents of the annotation to be modified. |
          items:
            type: string
            enum:
              - noPrint
              - noZoom
              - noRotate
              - noView
              - hidden
              - invisible
              - readOnly
              - locked
              - toggleNoView
              - lockedContents
        createdAt:
          type: string
          description: The date of the annotation creation. ISO 8601 with full date, time, and time zone information
          format: date-time
          example: '2019-09-16T15:05:03.712909Z'
        updatedAt:
          type: string
          description: The date of the last annotation update. ISO 8601 with full date, time, and time zone information
          format: date-time
          example: '2019-09-16T15:05:03.712909Z'
        name:
          type: string
          description: The name of the annotation used to identify the annotation.
        creatorName:
          type: string
          description: The name of the creator of the annotation.
        customData:
          $ref: '#/components/schemas/AnnotationCustomData'
      required:
        - type
        - pageIndex
        - bbox
        - v
    Rect:
      type: array
      title: Rect
      description: Rectangle in a form [left, top, width, height] in PDF points (pt).
      items:
        type: number
        minItems: 4
        maxItems: 4
      example:
        - 100
        - 200
        - 300
        - 400
    AnnotationRotation:
      type: integer
      title: Rotation
      description: Counterclockwise annotation rotation in degrees.
      enum:
        - 0
        - 90
        - 180
        - 270
    AnnotationNote:
      type: string
      title: Note
      description: Text of an annotation note.
    RedactionAnnotation:
      title: RedactionAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: RedactionAnnotation
          description: Redaction annotations determines the location of the area marked for redaction.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/markup/redaction
            rects:
              type: array
              description: Bounding boxes of the marked text.
              items:
                $ref: '#/components/schemas/Rect'
            outlineColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Outline color is the border color of a redaction annotation when it hasn't yet been applied to the document
              example: '#ffffff'
            fillColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Fill color is the background color that a redaction will have when applied to the document.
            overlayText:
              type: string
              description: The text that will be printed on top of an applied redaction annotation.
            repeatOverlayText:
              type: string
              description: Specifies whether or not the overlay text will be repeated multiple times to fill the boundaries of the redaction annotation.
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Color of the overlay text (if any).
              example: '#ffffff'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
    SearchPreset:
      type: string
      description: |
        - `credit-card-number` — matches a number with 13 to 19 digits that begins with 1—6.
        Spaces and `-` are allowed anywhere in the number.
        - `date` — matches date formats such as `mm/dd/yyyy`, `mm/dd/yy`, `dd/mm/yyyy`, and `dd/mm/yy`.
        It rejects any days greater than 31 or months greater than 12 and accepts a leading 0 in front of a single-digit day or month.
        The delimiter can be `-`, `.`, or `/`.
        - `email-address` — matches an email address. Expects the format of `*@*.*` with at least two levels of the domain name.
        - `international-phone-number` — matches international phone numbers.
        The number can have 7 to 15 digits with spaces or `-` occurring anywhere within the number, and it must have prefix of `+` or `00`.
        - `ipv4` — matches an IPv4 address with an optional mask at the end.
        - `ipv6` — matches a full and compressed IPv6 address as defined in [RFC 2373](http://www.faqs.org/rfcs/rfc2373.html).
        - `mac-address` — matches a MAC address with either `-` or `:` as a delimiter.
        - `north-american-phone-number` — matches North American-style phone numbers.
        NANPA standardization is used with international support.
        - `social-security-number` — matches a social security number.
        Expects the format of `XXX-XX-XXXX` or `XXXXXXXXX`, with X denoting digits.
        - `time` — matches time formats such as `00:00:00`, `00:00`, and `00:00 PM`. 12- and 24-hour formats are allowed.
        Seconds and AM/PM denotation are both optional.
        - `url` — matches a URL with a prefix of `http` or `https`, with an optional subdomain.
        - `us-zip-code` — matches a USA-style zip code. The format expected is `XXXXX`, `XXXXX-XXXX` or `XXXXX/XXXX`.
        - `vin` — matches US and ISO Standard 3779 Vehicle Identification Number. 
        The format expects 17 characters, with the last 5 characters being numeric. `I`, `i`, `O`, `o` ,`Q`, `q`, and `_` characters are not allowed.
      enum:
        - credit-card-number
        - date
        - email-address
        - international-phone-number
        - ipv4
        - ipv6
        - mac-address
        - north-american-phone-number
        - social-security-number
        - time
        - url
        - us-zip-code
        - vin
      example: email-address
    CreateRedactionsStrategyOptionsPreset:
      type: object
      required:
        - preset
      properties:
        preset:
          $ref: '#/components/schemas/SearchPreset'
        includeAnnotations:
          type: boolean
          default: true
          description: |
            Determines if redaction annotations are created on top of annotations whose
            content match the provided preset.
        start:
          type: integer
          default: 0
          description: |
            The index of the page from where you want to start the search.
        limit:
          type: integer
          default: null
          description: |
            Starting from start, the number of pages to search. Default is to the end of
            the document.
    CreateRedactionsStrategyOptionsRegex:
      type: object
      required:
        - regex
      properties:
        regex:
          type: string
          description: |
            Regex search term used for searching for text to redact.
          example: '@pspdfkit\\.com'
        includeAnnotations:
          type: boolean
          default: true
          description: |
            Determines if redaction annotations are created on top of annotations whose
            content match the provided preset.
        caseSensitive:
          type: boolean
          default: true
          description: |
            Determines if the search will be case sensitive.
        start:
          type: integer
          default: 0
          description: |
            The index of the page from where you want to start the search.
        limit:
          type: integer
          default: null
          description: |
            Starting from start, the number of pages to search. Default is to the end of
            the document.
    CreateRedactionsStrategyOptionsText:
      type: object
      required:
        - text
      properties:
        text:
          type: string
          description: |
            Search term used for searching for text to redact.
          example: '@nutrient.io'
        includeAnnotations:
          type: boolean
          default: true
          description: |
            Determines if redaction annotations are created on top of annotations whose
            content match the provided preset.
        caseSensitive:
          type: boolean
          default: false
          description: |
            Determines if the search will be case sensitive.
        start:
          type: integer
          default: 0
          description: |
            The index of the page from where you want to start the search.
        limit:
          type: integer
          default: null
          description: |
            Starting from start, the number of pages to search. Default is to the end of
            the document.
    CreateRedactionsAction:
      allOf:
        - type: object
          required:
            - type
            - strategy
            - strategyOptions
          properties:
            type:
              type: string
              description: |
                Creates redactions according to the given strategy. Once redactions are created, they need to be applied using the `applyRedactions` action.
                You can configure some visual aspects of the redaction annotation, including its background color, overlay text, and so on, by passing an optional `content` object.
              enum:
                - createRedactions
            content:
              $ref: '#/components/schemas/RedactionAnnotation'
        - oneOf:
            - type: object
              title: Preset
              required:
                - strategy
                - strategyOptions
              properties:
                strategy:
                  type: string
                  enum:
                    - preset
                strategyOptions:
                  $ref: '#/components/schemas/CreateRedactionsStrategyOptionsPreset'
            - type: object
              title: Regex
              required:
                - strategy
                - strategyOptions
              properties:
                strategy:
                  type: string
                  enum:
                    - regex
                strategyOptions:
                  $ref: '#/components/schemas/CreateRedactionsStrategyOptionsRegex'
            - type: object
              title: Text
              required:
                - strategy
                - strategyOptions
              properties:
                strategy:
                  type: string
                  enum:
                    - text
                strategyOptions:
                  $ref: '#/components/schemas/CreateRedactionsStrategyOptionsText'
    ApplyRedactionsAction:
      type: object
      required:
        - type
      properties:
        type:
          type: string
          description: |
            Applies the redactions created by an earlier `createRedactions` action.
          enum:
            - applyRedactions
    BuildAction:
      oneOf:
        - $ref: '#/components/schemas/ApplyInstantJsonAction'
        - $ref: '#/components/schemas/ApplyXfdfAction'
        - $ref: '#/components/schemas/FlattenAction'
        - $ref: '#/components/schemas/OcrAction'
        - $ref: '#/components/schemas/RotateAction'
        - $ref: '#/components/schemas/WatermarkAction'
        - $ref: '#/components/schemas/CreateRedactionsAction'
        - $ref: '#/components/schemas/ApplyRedactionsAction'
    FilePart:
      type: object
      properties:
        file:
          $ref: '#/components/schemas/FileHandle'
        password:
          type: string
          description: The password for the input file
        pages:
          $ref: '#/components/schemas/PageRange'
        layout:
          allOf:
            - type: object
              description: |
                Defines the layout of the generated pages. Only valid for email (e.g. EML and MSG) and spreadsheet (e.g. XLSX) inputs.
            - $ref: '#/components/schemas/PageLayout'
        content_type:
          type: string
          description: |
            The content type of the file. Used to determine the file type when the file content type is not available and can't be inferred.
          example: application/pdf
        actions:
          type: array
          items:
            $ref: '#/components/schemas/BuildAction'
      required:
        - file
      example:
        file: pdf-file-from-multipart
    HTMLPart:
      type: object
      required:
        - html
      properties:
        html:
          $ref: '#/components/schemas/FileHandle'
        assets:
          type: array
          description: |
            List of asset names imported in the HTML. References the name passed in the multipart request.
          items:
            type: string
        layout:
          $ref: '#/components/schemas/PageLayout'
        actions:
          type: array
          items:
            $ref: '#/components/schemas/BuildAction'
    NewPagePart:
      type: object
      required:
        - page
      properties:
        page:
          type: string
          enum:
            - new
        pageCount:
          type: integer
          minimum: 1
          default: 1
          description: Number of pages to be added.
        layout:
          $ref: '#/components/schemas/PageLayout'
        actions:
          type: array
          items:
            $ref: '#/components/schemas/BuildAction'
    schemas-DocumentId:
      type: string
      title: Document ID
      example: 7KPZW8XFGM4F1C92KWBK1B748M
      description: The ID of the document.
    DocumentPart:
      type: object
      description: |
        This allows to reference a document stored on Document Engine.
        It is also possible to refer to currently scoped file by using special ID:
          ```
          {"document": {"id": "#self"}}
          ```
      properties:
        document:
          type: object
          required:
            - id
          properties:
            id:
              oneOf:
                - $ref: '#/components/schemas/schemas-DocumentId'
                - type: string
                  title: Self
                  description: |
                    Special ID that allows to refer to currently scoped document (including layer if using layers path).
                  enum:
                    - '#self'
            layer:
              type: string
              description: |
                The name of the layer to be used.
              example: my-existing-layer
        password:
          type: string
          description: The password for the input file
        pages:
          $ref: '#/components/schemas/PageRange'
        actions:
          type: array
          items:
            $ref: '#/components/schemas/BuildAction'
      required:
        - document
    Part:
      oneOf:
        - $ref: '#/components/schemas/FilePart'
        - $ref: '#/components/schemas/HTMLPart'
        - $ref: '#/components/schemas/NewPagePart'
        - $ref: '#/components/schemas/DocumentPart'
    schemas-Title:
      type:
        - string
        - 'null'
      description: The document title.
      example: Nutrient Document Engine API Specification
    Metadata:
      type: object
      properties:
        title:
          $ref: '#/components/schemas/schemas-Title'
        author:
          type: string
          description: The document author.
          example: Document Author
    Label:
      type: object
      required:
        - pages
        - label
      properties:
        pages:
          $ref: '#/components/schemas/PageRange'
        label:
          type: string
          description: The label to apply to specified pages.
          example: Page I-III
    PDFUserPermission:
      type: string
      enum:
        - printing
        - modification
        - extract
        - annotations_and_forms
        - fill_forms
        - extract_accessibility
        - assemble
        - print_high_quality
    OptimizePdf:
      type: object
      properties:
        grayscaleText:
          type: boolean
          default: false
        grayscaleGraphics:
          type: boolean
          default: false
        grayscaleImages:
          type: boolean
          default: false
        grayscaleFormFields:
          type: boolean
          default: false
        grayscaleAnnotations:
          type: boolean
          default: false
        disableImages:
          type: boolean
          default: false
        mrcCompression:
          type: boolean
          default: false
        imageOptimizationQuality:
          type: integer
          default: 2
          minimum: 1
          maximum: 4
        linearize:
          type: boolean
          default: false
          description: |
            If set to `true`, the resulting PDF file will be linearized.
            This means that the document will be optimized in a special way that allows it to be loaded faster over the network.
            You need the `Linearization` feature to be enabled in your Nutrient Document Engine license in order to use this option.
    BasePDFOutput:
      type: object
      description: |
        Object representing PDF output.
      properties:
        metadata:
          $ref: '#/components/schemas/Metadata'
        labels:
          type: array
          items:
            $ref: '#/components/schemas/Label'
        user_password:
          type: string
          description: |
            Defines the password which allows to open a file with defined
            permissions
        owner_password:
          type: string
          description: |
            Defines the password which allows to manage the permissions for the file
        user_permissions:
          type: array
          description: |
            Defines the permissions which are granted when a file is opened with user password
          items:
            $ref: '#/components/schemas/PDFUserPermission'
        optimize:
          $ref: '#/components/schemas/OptimizePdf'
    PDFOutput:
      allOf:
        - $ref: '#/components/schemas/BasePDFOutput'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pdf
    PDFAOutput:
      allOf:
        - $ref: '#/components/schemas/BasePDFOutput'
        - type: object
          required:
            - type
          properties:
            type:
              type: string
              enum:
                - pdfa
            conformance:
              type: string
              enum:
                - pdfa-1a
                - pdfa-1b
                - pdfa-2a
                - pdfa-2u
                - pdfa-2b
                - pdfa-3a
                - pdfa-3u
              description: |
                Defines the conformance level of the output file.
                The default value is `pdfa-1b`.

                These are the only supported conformance levels at this time.
            vectorization:
              type: boolean
              default: true
              description: |
                When set to true, produces vector based graphic elements where applicable. For example: fonts and paths.
            rasterization:
              type: boolean
              default: true
              description: |
                When set to true, produces raster based graphic elements where applicable. For example: images.
    ImageOutput:
      type: object
      title: ImageOutput
      required:
        - type
      properties:
        type:
          type: string
          enum:
            - image
        format:
          type: string
          default: png
          description: |
            The format of the rendered image.
          enum:
            - png
            - jpeg
            - jpg
            - webp
        pages:
          $ref: '#/components/schemas/PageRange'
        width:
          type: number
          description: |
            The width of the rendered image in pixels. You must specify at least one of either width, height or dpi
        height:
          type: number
          description: |
            The height of the rendered image in pixels. You must specify at least one of either width, height or dpi
        dpi:
          type: number
          description: |
            The resolution of the rendered image in dots per inch. You must specify at least one of either width, height or dpi
      description: Render the document as an image.
    JSONContentOutput:
      type: object
      title: JSONContentOutput
      required:
        - type
      description: |
        JSON with document contents. Returned for `json-content` output type.
      properties:
        type:
          type: string
          enum:
            - json-content
        plainText:
          type: boolean
          default: true
          description: |
            When set to true, extracts document text. Text is extracted via OCR process.
        structuredText:
          type: boolean
          default: false
          description: |
            When set to true, extracts structured document text. This includes text words, characters, lines and paragraphs.
        keyValuePairs:
          type: boolean
          default: false
          description: |
            When set to true, extracts key-value pairs detected within the document contents. Example of detected values are phone numbers, email addresses, currencies, numbers, dates, etc.
        tables:
          type: boolean
          default: true
          description: |
            When set to true, extracts tabular data from the document.
        language:
          $ref: '#/components/schemas/OcrLanguage'
    OfficeOutput:
      type: object
      title: OfficeOutput
      required:
        - type
      properties:
        type:
          type: string
          description: |
            The output office file type.
          enum:
            - docx
            - xlsx
            - pptx
    BuildOutput:
      oneOf:
        - $ref: '#/components/schemas/PDFOutput'
        - $ref: '#/components/schemas/PDFAOutput'
        - $ref: '#/components/schemas/ImageOutput'
        - $ref: '#/components/schemas/JSONContentOutput'
        - $ref: '#/components/schemas/OfficeOutput'
    BuildInstructions:
      type: object
      properties:
        parts:
          type: array
          description: |
            Parts of the document to be built.

            Multiple types of parts are supported:
            * `FilePart` that represents a binary input file that can be either a part name in the `multipart/form-data` request or an URL of a remote file.
            * `HTMLPart` that represents an HTML input file along with it's assets.
            * `NewPagePart` that represents a document with empty pages.
            * `DocumentPart` that represents a document (with optional layer) managed by Nutrient Document Engine. Only applicable if used in a Document Engine context.
          items:
            $ref: '#/components/schemas/Part'
        actions:
          type: array
          description: |
            Actions to be performed on the document after it is built.
          items:
            $ref: '#/components/schemas/BuildAction'
        output:
          $ref: '#/components/schemas/BuildOutput'
      required:
        - parts
    FontFile:
      title: FontFile
      type: object
      description: A font used in the document.
      properties:
        fullName:
          type: string
          description: A friendly name for this font face
          example: Al Bayan Bold
        idx:
          type: number
          description: The index inside the font file where the font face is
          example: 2
        fileName:
          description: |
            The name of the font file that contains this font face
            This is the name of the file on Document Engine.
          type: string
          example: AlBayan.ttc"
    FontSubstitution:
      title: FontSubstitution
      type: object
      description: |
        Whenever Document Engine does not have the specified font (pattern),
        it will use the substitute font specified, if the substitute is available
      required:
        - pattern
        - target
      properties:
        pattern:
          type: string
          description: |
            Font family name replacements are made based upon pattern matching,
            allowing for a font family name to be replaced with a different name.

            Patterns are matched using the following rules:
            * `*` matches multiple characters
            * `?` matches a single character
            * Pattern and the target name are case-insensitive.
          example: Roboto-*
        target:
          type: string
          example: Courier New
    FontSubstitutionList:
      title: FontSubstitutionList
      description: |
        A list of font substitutions.

        Ordering matters -  As names could match multiple patterns, we have to stress that order matters when creating or replacing font substitutions.
      type: array
      items:
        $ref: '#/components/schemas/FontSubstitution'
    OutlineElement:
      title: OutlineElement
      type: object
      required:
        - type
      properties:
        type:
          type: string
          example: pspdfkit/outline-element
        isExpanded:
          type: boolean
          description: Indicates whether the outline element is expanded.
          example: true
        isItalic:
          type: boolean
          description: Indicates whether the outline element's title is italic.
          example: false
        isBold:
          type: boolean
          description: Indicates whether the outline element's title is bold.
          example: false
        title:
          type: string
          description: The outline element's title.
        action:
          $ref: '#/components/schemas/Action'
        children:
          type: array
          items:
            $ref: '#/components/schemas/OutlineElement'
          description: Array of outline elements nested under the current outline element.
          example: []
    DocumentPageIndex:
      title: PageIndex
      type: integer
      minimum: 0
      description: 0-based index of the page.
      example: 0
    SearchResult:
      title: SearchResult
      type: object
      required:
        - pageIndex
      properties:
        pageIndex:
          type: integer
          description: Index of the page where the text was found.
          minimum: 0
          example: 0
        previewText:
          type: string
          description: Sourrounding text of the search query.
          example: PSPDFKit supports almost all PDF annotation types
        rangeInPreview:
          type: array
          minItems: 2
          maxItems: 2
          items:
            type: integer
          description: |
            Location of the search query in the preview text. The first element of the array
            is a 0-based position of its first character within the text, and the second
            element is the query's length.
          example:
            - 2
            - 3
        rectsOnPage:
          type: array
          items:
            type: array
            minItems: 4
            maxItems: 4
            items:
              type: number
            description: Bounding box of the query on the page, denoted `[top, left, width, height]`.
            example:
              - 82.1448974609375
              - 61.14007568359375
              - 34.11000061035156
              - 18
          description: |
            Bounding boxes of all occurences of the query within the text in page
            coordinates.
        isAnnotation:
          type: boolean
          description: Currently always `false` - searching in annotations is not yet supported.
          example: false
      description: A single search result.
    BlendMode:
      type: string
      title: BlendMode
      enum:
        - normal
        - multiply
        - screen
        - overlay
        - darken
        - lighten
        - colorDodge
        - colorBurn
        - hardLight
        - softLight
        - difference
        - exclusion
    MarkupAnnotation:
      title: MarkupAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: MarkupAnnotation
          description: |
            Markup annotations include highlight, squiggly, strikeout, and underline. All of these require a list of rectangles that they're drawn to. The highlight annotation will lay the color on top of the element and apply the multiply blend mode.
          type: object
          properties:
            type:
              enum:
                - pspdfkit/markup/highlight
                - pspdfkit/markup/squiggly
                - pspdfkit/markup/strikeout
                - pspdfkit/markup/underline
            rects:
              type: array
              description: Bounding boxes of the marked text.
              items:
                $ref: '#/components/schemas/Rect'
            blendMode:
              $ref: '#/components/schemas/BlendMode'
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Foreground color
              example: '#fcee7c'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - rects
            - color
            - type
    AnnotationText:
      type: object
      description: The text contents.
      properties:
        format:
          type: string
          description: |
            The format of the annotation's contents. Can be either `xhtml` or `plain`.
            If `xhtml` is used, the text will be rendered as XHTML.
            If `plain` is used, the text will be rendered as plain text.

            Supported XHTML tags include `span`, `p`, `html`, `body`, `b`, `i`, and `a`.
            Hyperlinks are also supported in the `a` tags using the `href` attribute.
            Styles are supported by using inline styles with the `style` attribute.
            Supported CSS properties include `background-color`, `font-weight`, `font-style`, `text-decoration`, `color`
          enum:
            - xhtml
            - plain
        value:
          type: string
          description: |
            Actual text content of the annotation. This is the text that will be displayed in the annotation.
          example: Annotation with <b>xhtml</b> contents.
    FontSizeInt:
      title: FontSizeInt
      description: Size of the text in PDF points.
      type: integer
      example: 10
    FontStyle:
      type: array
      description: Text style. Can be only italic, only bold, italic and bold, or none of these.
      items:
        type: string
        enum:
          - bold
          - italic
    FontColor:
      title: FontColor
      type: string
      pattern: ^#[0-9a-fA-F]{6}$
      description: A foreground color of the text.
      example: '#ffffff'
    Font:
      title: Font
      type: string
      description: The font to render the text. Fonts are client specific, so you should only use fonts you know are present in the browser where they should be displayed. If a font isn't found, PSPDFKit will automatically fall back to a sans-serif font.
      example: Helvetica
    HorizontalAlign:
      title: HorizontalAlign
      type: string
      description: Alignment of the text along the horizontal axis.
      enum:
        - left
        - center
        - right
    VerticalAlign:
      title: VerticalAlign
      type: string
      description: |
        Alignment of the text along the vertical axis.

        Note that vertical align is a custom PSPDFKit extension that might not be honored by 3rd party readers.
      enum:
        - top
        - center
        - bottom
    Point:
      type: array
      title: Point
      description: Point coordinates in a form [x, y] in PDF points (pt).
      items:
        type: number
        minItems: 2
        maxItems: 2
      example:
        - 100
        - 200
    LineCap:
      type: string
      title: LineCap
      enum:
        - square
        - circle
        - diamond
        - openArrow
        - closedArrow
        - butt
        - reverseOpenArrow
        - reverseClosedArrow
        - slash
    BorderStyle:
      type: string
      title: BorderStyle
      enum:
        - solid
        - dashed
        - beveled
        - inset
        - underline
    CloudyBorderIntensity:
      title: CloudyBorderIntensity
      type: number
      minimum: 0
    CloudyBorderInset:
      title: CloudyBorderInset
      description: Inset used for drawing cloudy borders in a form [left, top, right, bottom].
      type: array
      items:
        type: number
        minItems: 4
        maxItems: 4
    TextAnnotation:
      title: TextAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: TextAnnotation
          description: A text box annotation that can be placed anywhere on the screen.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/text
            text:
              $ref: '#/components/schemas/AnnotationText'
            fontSize:
              $ref: '#/components/schemas/FontSizeInt'
            fontStyle:
              $ref: '#/components/schemas/FontStyle'
            fontColor:
              $ref: '#/components/schemas/FontColor'
            font:
              $ref: '#/components/schemas/Font'
            backgroundColor:
              title: BackgroundColor
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A background color that will fill the bounding box.
              example: '#000000'
            horizontalAlign:
              $ref: '#/components/schemas/HorizontalAlign'
            verticalAlign:
              $ref: '#/components/schemas/VerticalAlign'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            isFitting:
              type: boolean
              description: Specifies that the text is supposed to fit in the bounding box. This is only set on new annotations, as we can't easily figure out if an appearance stream contains all the text for existing annotations.
            callout:
              type: object
              description: Properties for callout version of text annotation.
              properties:
                start:
                  $ref: '#/components/schemas/Point'
                end:
                  $ref: '#/components/schemas/Point'
                innerRectInset:
                  type: array
                  description: Inset applied to the bounding box to size and position the rectangle for the text [left, top, right, bottom].
                  items:
                    type: number
                    minItems: 4
                    maxItems: 4
                cap:
                  $ref: '#/components/schemas/LineCap'
                knee:
                  $ref: '#/components/schemas/Point'
              required:
                - start
                - end
                - innerRectInset
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
            - text
            - fontSize
            - opacity
            - horizontalAlign
            - verticalAlign
    Intensity:
      title: Intensity
      type: number
      minimum: 0
      maximum: 1
      default: 0.5
    Lines:
      title: Lines
      type: object
      properties:
        intensities:
          type: array
          description: Intensities are used to weigh the point during natural drawing. They are received by pressure-sensitive drawing or touch devices. The default value should be used if it's not possible to obtain the intensity.
          items:
            type: array
            items:
              $ref: '#/components/schemas/Intensity'
        points:
          type: array
          description: Points are grouped in segments. Points inside a segment are joined to a line. There must be at least one  segment with at least one point.
          items:
            type: array
            items:
              $ref: '#/components/schemas/Point'
    BackgroundColor:
      title: BackgroundColor
      type: string
      pattern: ^#[0-9a-fA-F]{6}$
      description: A background color that will fill the bounding box.
      example: '#000000'
    InkAnnotation:
      title: InkAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: InkAnnotation
          description: Ink annotations are used for freehand drawings on a page. They can contain multiple line segments. Points within a segment are connected to a line.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/ink
            lines:
              $ref: '#/components/schemas/Lines'
            lineWidth:
              type: integer
              description: The width of the line in PDF points (pt).
              minimum: 0
            isDrawnNaturally:
              type: boolean
              description: Nutrient's natural drawing mode. This value is only used by Nutrient iOS SDK.
            isSignature:
              type: boolean
              description: True if the annotation should be considered a (soft) ink signature.
            strokeColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: The color of the line.
              example: '#ffffff'
            backgroundColor:
              $ref: '#/components/schemas/BackgroundColor'
            blendMode:
              $ref: '#/components/schemas/BlendMode'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - lines
            - lineWidth
    LinkAnnotation:
      title: LinkAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: LinkAnnotation
          description: A link can be used to trigger an action when clicked or pressed. The link will be drawn on the bounding box.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/link
            borderColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color of the link border.
              example: '#ffffff'
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - action
    NoteIcon:
      title: NoteIcon
      type: string
      enum:
        - comment
        - rightPointer
        - rightArrow
        - check
        - circle
        - cross
        - insert
        - newParagraph
        - note
        - paragraph
        - help
        - star
        - key
    NoteAnnotation:
      title: NoteAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: NoteAnnotation
          description: Note annotations are “sticky notes” attached to a point in the PDF document. They're represented as markers, and each one has an icon associated with it. Its text content is revealed on selection.
          type: object
          properties:
            text:
              $ref: '#/components/schemas/AnnotationText'
            icon:
              $ref: '#/components/schemas/NoteIcon'
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color that fills the note shape and its icon.
              example: '#ffd83f'
          required:
            - type
            - text
            - icon
    MeasurementScale:
      title: MeasurementScale
      type: object
      properties:
        unitFrom:
          type: string
          enum:
            - in
            - mm
            - cm
            - pt
        unitTo:
          type: string
          enum:
            - in
            - mm
            - cm
            - pt
            - ft
            - m
            - yd
            - km
            - mi
        from:
          type: number
        to:
          type: number
    MeasurementPrecision:
      title: MeasurementPrecision
      type: string
      enum:
        - whole
        - oneDp
        - twoDp
        - threeDp
        - fourDp
    ShapeAnnotation:
      title: ShapeAnnotation
      description: Shape annotations are used to draw different shapes on a page.
      type: object
      properties:
        strokeDashArray:
          type: array
          items:
            type: number
        strokeWidth:
          type: number
        strokeColor:
          type: string
          pattern: ^#[0-9a-fA-F]{6}$
          example: '#ffffff'
        note:
          $ref: '#/components/schemas/AnnotationNote'
        measurementScale:
          $ref: '#/components/schemas/MeasurementScale'
        measurementPrecision:
          $ref: '#/components/schemas/MeasurementPrecision'
    FillColor:
      title: FillColor
      type: string
      pattern: ^#[0-9a-fA-F]{6}$
      example: '#FF0000'
    EllipseAnnotation:
      title: EllipseAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - $ref: '#/components/schemas/ShapeAnnotation'
        - title: EllipseAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/ellipse
            fillColor:
              $ref: '#/components/schemas/FillColor'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
    RectangleAnnotation:
      title: RectangleAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - $ref: '#/components/schemas/ShapeAnnotation'
        - title: RectangleAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/rectangle
            fillColor:
              $ref: '#/components/schemas/FillColor'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
    LineCaps:
      title: LineCaps
      type: object
      properties:
        start:
          $ref: '#/components/schemas/LineCap'
        end:
          $ref: '#/components/schemas/LineCap'
    LineAnnotation:
      title: LineAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - $ref: '#/components/schemas/ShapeAnnotation'
        - title: LineAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/line
            startPoint:
              $ref: '#/components/schemas/Point'
            endPoint:
              $ref: '#/components/schemas/Point'
            fillColor:
              $ref: '#/components/schemas/FillColor'
            lineCaps:
              $ref: '#/components/schemas/LineCaps'
          required:
            - type
            - startPoint
            - endPoint
    PolylineAnnotation:
      title: PolylineAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - $ref: '#/components/schemas/ShapeAnnotation'
        - title: PolylineAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/polyline
            fillColor:
              $ref: '#/components/schemas/FillColor'
            points:
              type: array
              items:
                $ref: '#/components/schemas/Point'
            lineCaps:
              $ref: '#/components/schemas/LineCaps'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
            - points
    PolygonAnnotation:
      title: PolygonAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - $ref: '#/components/schemas/ShapeAnnotation'
        - title: PolygonAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/polygon
            fillColor:
              $ref: '#/components/schemas/FillColor'
            points:
              type: array
              items:
                $ref: '#/components/schemas/Point'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
          required:
            - type
            - points
    ImageAnnotation:
      title: ImageAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: ImageAnnotation
          description: Image annotations are used to annotate a PDF with images.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/image
            description:
              type: string
              description: A description of the image.
              example: PSPDFKit Logo
            fileName:
              type: string
              description: An optional file name for the image.
            contentType:
              type: string
              description: MIME type of the image.
              enum:
                - image/jpeg
                - image/png
                - application/pdf
            imageAttachmentId:
              type: string
              description: Either the SHA256 Hash of the attachment or the pdfObjectId of the attachment.
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            isSignature:
              type: boolean
              description: True if the annotation should be considered a (soft) signature.
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
    StampAnnotation:
      title: StampAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: StampAnnotation
          description: A stamp annotation represents a stamp in a PDF.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/stamp
            stampType:
              type: string
              description: A type defining the appearance of the stamp annotation. Type 'Custom' displays arbitrary title and subtitle.
              enum:
                - Accepted
                - Approved
                - AsIs
                - Completed
                - Confidential
                - Departmental
                - Draft
                - Experimental
                - Expired
                - Final
                - ForComment
                - ForPublicRelease
                - InformationOnly
                - InitialHere
                - NotApproved
                - NotForPublicRelease
                - PreliminaryResults
                - Rejected
                - Revised
                - SignHere
                - Sold
                - TopSecret
                - Void
                - Witness
                - Custom
            title:
              type: string
              description: Custom stamp's title.
            subtitle:
              type: string
              description: Custom stamp's subtitle.
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Custom stamp's fill color.
              example: '#ffffff'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - stampType
    AnnotationContent:
      title: Annotation Contents
      type: object
      description: |
        JSON representation of an annotation contents.
      oneOf:
        - $ref: '#/components/schemas/MarkupAnnotation'
        - $ref: '#/components/schemas/RedactionAnnotation'
        - $ref: '#/components/schemas/TextAnnotation'
        - $ref: '#/components/schemas/InkAnnotation'
        - $ref: '#/components/schemas/LinkAnnotation'
        - $ref: '#/components/schemas/NoteAnnotation'
        - $ref: '#/components/schemas/EllipseAnnotation'
        - $ref: '#/components/schemas/RectangleAnnotation'
        - $ref: '#/components/schemas/LineAnnotation'
        - $ref: '#/components/schemas/PolylineAnnotation'
        - $ref: '#/components/schemas/PolygonAnnotation'
        - $ref: '#/components/schemas/ImageAnnotation'
        - $ref: '#/components/schemas/StampAnnotation'
    BaseAnnotation.v1:
      title: BaseAnnotation
      type: object
      properties:
        v:
          type: integer
          enum:
            - 1
          description: The specification version that the record is compliant to.
        type:
          type: string
          description: The type of the annotation.
        pageIndex:
          type: integer
          description: Page index of the annotation. 0 is the first page.
          minimum: 0
        bbox:
          $ref: '#/components/schemas/AnnotationBbox'
        action:
          $ref: '#/components/schemas/Action'
        opacity:
          type: number
          description: Annotation opacity. 0 is fully transparent, 1 is fully opaque.
          minimum: 0
          maximum: 1
        pdfObjectId:
          type: integer
          description: The PDF object ID of the annotation from the source PDF.
        id:
          type: string
          description: The unique Instant JSON identifier of the annotation.
          example: 01DNEDPQQ22W49KDXRFPG4EPEQ
        flags:
          type: array
          description: |
            Array of annotation flags.

            | Flag | Description |
            | ---- | ----------- |
            | noPrint | Don't print. |
            | noZoom | Don't zoom with page. |
            | noRotate | Don't rotate. |
            | noView | Don't display, can be still printed. |
            | hidden | Don't display, don't print, disable any interaction with user. |
            | invisible | Ignore annotation AP stream. |
            | readOnly | Don't allow the annotation to be deleted or its properties modified. |
            | locked | Same as `readOnly` but allows changing annotation contents. |
            | lockedContents | Don't allow the contents of the annotation to be modified. |
          items:
            type: string
            enum:
              - noPrint
              - noZoom
              - noRotate
              - noView
              - hidden
              - invisible
              - readOnly
              - locked
              - toggleNoView
              - lockedContents
        createdAt:
          type: string
          description: The date of the annotation creation. ISO 8601 with full date, time, and time zone information
          format: date-time
          example: '2019-09-16T15:05:03.712909Z'
        updatedAt:
          type: string
          description: The date of the last annotation update. ISO 8601 with full date, time, and time zone information
          format: date-time
          example: '2019-09-16T15:05:03.712909Z'
        name:
          type: string
          description: The name of the annotation used to identify the annotation.
        creatorName:
          type: string
          description: The name of the creator of the annotation.
        customData:
          $ref: '#/components/schemas/AnnotationCustomData'
      required:
        - type
        - pageIndex
        - bbox
        - v
    MarkupAnnotation.v1:
      title: MarkupAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: MarkupAnnotation
          description: |
            Markup annotations include highlight, squiggly, strikeout, and underline. All of these require a list of rectangles that they're drawn to. The highlight annotation will lay the color on top of the element and apply the multiply blend mode.
          type: object
          properties:
            type:
              enum:
                - pspdfkit/markup/highlight
                - pspdfkit/markup/squiggly
                - pspdfkit/markup/strikeout
                - pspdfkit/markup/underline
            rects:
              type: array
              description: Bounding boxes of the marked text.
              items:
                $ref: '#/components/schemas/Rect'
            blendMode:
              $ref: '#/components/schemas/BlendMode'
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Foreground color
              example: '#fcee7c'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - rects
            - color
            - type
    RedactionAnnotation.v1:
      title: RedactionAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: RedactionAnnotation
          description: Redaction annotations determines the location of the area marked for redaction.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/markup/redaction
            rects:
              type: array
              description: Bounding boxes of the marked text.
              items:
                $ref: '#/components/schemas/Rect'
            outlineColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Outline color is the border color of a redaction annotation when it hasn't yet been applied to the document
              example: '#ffffff'
            fillColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Fill color is the background color that a redaction will have when applied to the document.
            overlayText:
              type: string
              description: The text that will be printed on top of an applied redaction annotation.
            repeatOverlayText:
              type: string
              description: Specifies whether or not the overlay text will be repeated multiple times to fill the boundaries of the redaction annotation.
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Color of the overlay text (if any).
              example: '#ffffff'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
    AnnotationPlainText:
      type: string
      description: The text contents.
      example: Annotation text.
    TextAnnotation.v1:
      title: TextAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: TextAnnotation
          description: A text box annotation that can be placed anywhere on the screen.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/text
            text:
              $ref: '#/components/schemas/AnnotationPlainText'
            fontSize:
              $ref: '#/components/schemas/FontSizeInt'
            fontStyle:
              type: array
              description: Text style. Can be only italic, only bold, italic and bold, or none of these.
              items:
                type: string
                enum:
                  - bold
                  - italic
            fontColor:
              $ref: '#/components/schemas/FontColor'
            font:
              $ref: '#/components/schemas/Font'
            backgroundColor:
              title: BackgroundColor
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A background color that will fill the bounding box.
              example: '#000000'
            horizontalAlign:
              $ref: '#/components/schemas/HorizontalAlign'
            verticalAlign:
              $ref: '#/components/schemas/VerticalAlign'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            isFitting:
              type: boolean
              description: Specifies that the text is supposed to fit in the bounding box. This is only set on new annotations, as we can't easily figure out if an appearance stream contains all the text for existing annotations.
            callout:
              type: object
              description: Properties for callout version of text annotation.
              properties:
                start:
                  $ref: '#/components/schemas/Point'
                end:
                  $ref: '#/components/schemas/Point'
                innerRectInset:
                  type: array
                  description: Inset applied to the bounding box to size and position the rectangle for the text [left, top, right, bottom].
                  items:
                    type: number
                    minItems: 4
                    maxItems: 4
                cap:
                  $ref: '#/components/schemas/LineCap'
                knee:
                  $ref: '#/components/schemas/Point'
              required:
                - start
                - end
                - innerRectInset
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
            - text
            - fontSize
    InkAnnotation.v1:
      title: InkAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: InkAnnotation
          description: Ink annotations are used for freehand drawings on a page. They can contain multiple line segments. Points within a segment are connected to a line.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/ink
            lines:
              $ref: '#/components/schemas/Lines'
            lineWidth:
              type: integer
              description: The width of the line in PDF points (pt).
              minimum: 0
            isDrawnNaturally:
              type: boolean
              description: Nutrient's natural drawing mode. This value is only used by Nutrient iOS SDK.
            isSignature:
              type: boolean
              description: True if the annotation should be considered a (soft) ink signature.
            strokeColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: The color of the line.
              example: '#ffffff'
            backgroundColor:
              $ref: '#/components/schemas/BackgroundColor'
            blendMode:
              $ref: '#/components/schemas/BlendMode'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - lines
            - lineWidth
    LinkAnnotation.v1:
      title: LinkAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: LinkAnnotation
          description: A link can be used to trigger an action when clicked or pressed. The link will be drawn on the bounding box.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/link
            borderColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color of the link border.
              example: '#ffffff'
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - action
    NoteAnnotation.v1:
      title: NoteAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: NoteAnnotation
          description: Note annotations are “sticky notes” attached to a point in the PDF document. They're represented as markers, and each one has an icon associated with it. Its text content is revealed on selection.
          type: object
          properties:
            text:
              $ref: '#/components/schemas/AnnotationPlainText'
            icon:
              $ref: '#/components/schemas/NoteIcon'
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color that fills the note shape and its icon.
              example: '#ffd83f'
          required:
            - type
            - text
            - icon
    ShapeAnnotation.v1:
      title: ShapeAnnotation
      description: Shape annotations are used to draw different shapes on a page.
      type: object
      properties:
        strokeDashArray:
          type: array
          items:
            type: number
        strokeWidth:
          type: number
        strokeColor:
          type: string
          pattern: ^#[0-9a-fA-F]{6}$
          example: '#ffffff'
        note:
          $ref: '#/components/schemas/AnnotationNote'
        measurementScale:
          $ref: '#/components/schemas/MeasurementScale'
        measurementPrecision:
          $ref: '#/components/schemas/MeasurementPrecision'
    EllipseAnnotation.v1:
      title: EllipseAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - $ref: '#/components/schemas/ShapeAnnotation.v1'
        - title: EllipseAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/ellipse
            fillColor:
              $ref: '#/components/schemas/FillColor'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
    RectangleAnnotation.v1:
      title: RectangleAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - $ref: '#/components/schemas/ShapeAnnotation.v1'
        - title: RectangleAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/rectangle
            fillColor:
              $ref: '#/components/schemas/FillColor'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
    LineAnnotation.v1:
      title: LineAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - $ref: '#/components/schemas/ShapeAnnotation.v1'
        - title: LineAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/line
            startPoint:
              $ref: '#/components/schemas/Point'
            endPoint:
              $ref: '#/components/schemas/Point'
            fillColor:
              $ref: '#/components/schemas/FillColor'
            lineCaps:
              $ref: '#/components/schemas/LineCaps'
          required:
            - type
            - startPoint
            - endPoint
    PolylineAnnotation.v1:
      title: PolylineAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - $ref: '#/components/schemas/ShapeAnnotation.v1'
        - title: PolylineAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/polyline
            fillColor:
              $ref: '#/components/schemas/FillColor'
            points:
              type: array
              items:
                $ref: '#/components/schemas/Point'
            lineCaps:
              $ref: '#/components/schemas/LineCaps'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
            cloudyBorderInset:
              $ref: '#/components/schemas/CloudyBorderInset'
          required:
            - type
            - points
    PolygonAnnotation.v1:
      title: PolygonAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - $ref: '#/components/schemas/ShapeAnnotation.v1'
        - title: PolygonAnnotation
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/shape/polygon
            fillColor:
              $ref: '#/components/schemas/FillColor'
            points:
              type: array
              items:
                $ref: '#/components/schemas/Point'
            cloudyBorderIntensity:
              $ref: '#/components/schemas/CloudyBorderIntensity'
          required:
            - type
            - points
    ImageAnnotation.v1:
      title: ImageAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: ImageAnnotation
          description: Image annotations are used to annotate a PDF with images.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/image
            description:
              type: string
              description: A description of the image.
              example: PSPDFKit Logo
            fileName:
              type: string
              description: An optional file name for the image.
            contentType:
              type: string
              description: MIME type of the image.
              enum:
                - image/jpeg
                - image/png
                - application/pdf
            imageAttachmentId:
              type: string
              description: Either the SHA256 Hash of the attachment or the pdfObjectId of the attachment.
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            isSignature:
              type: boolean
              description: True if the annotation should be considered a (soft) signature.
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
    StampAnnotation.v1:
      title: StampAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: StampAnnotation
          description: A stamp annotation represents a stamp in a PDF.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/stamp
            stampType:
              type: string
              description: A type defining the appearance of the stamp annotation. Type 'Custom' displays arbitrary title and subtitle.
              enum:
                - Accepted
                - Approved
                - AsIs
                - Completed
                - Confidential
                - Departmental
                - Draft
                - Experimental
                - Expired
                - Final
                - ForComment
                - ForPublicRelease
                - InformationOnly
                - InitialHere
                - NotApproved
                - NotForPublicRelease
                - PreliminaryResults
                - Rejected
                - Revised
                - SignHere
                - Sold
                - TopSecret
                - Void
                - Witness
                - Custom
            title:
              type: string
              description: Custom stamp's title.
            subtitle:
              type: string
              description: Custom stamp's subtitle.
            color:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: Custom stamp's fill color.
              example: '#ffffff'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            note:
              $ref: '#/components/schemas/AnnotationNote'
          required:
            - type
            - stampType
    FontSizeAuto:
      title: FontSizeAuto
      description: Size of the text that automatically adjusts to fit the bounding box.
      type: string
      enum:
        - auto
      example: auto
    WidgetAnnotation.v1:
      title: WidgetAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation.v1'
        - title: WidgetAnnotation
          description: |
            JSON representation of the form field widget annotation. Widget annotations are a type of annotation with the type always being 'pspdfkit/widget'.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/widget
            formFieldName:
              type: string
              example: First-Name
              description: See name property of the FormFieldContent schema for more details
            borderColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color of the annotation border.
              example: '#ffffff'
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            font:
              $ref: '#/components/schemas/Font'
            fontSize:
              oneOf:
                - $ref: '#/components/schemas/FontSizeInt'
                - $ref: '#/components/schemas/FontSizeAuto'
            fontColor:
              $ref: '#/components/schemas/FontColor'
            horizontalAlign:
              $ref: '#/components/schemas/HorizontalAlign'
            verticalAlign:
              $ref: '#/components/schemas/VerticalAlign'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            backgroundColor:
              $ref: '#/components/schemas/BackgroundColor'
          required:
            - type
    Annotation.v1:
      title: Annotation JSON v1
      type: object
      description: |
        JSON representation of an annotation.
      oneOf:
        - $ref: '#/components/schemas/MarkupAnnotation.v1'
        - $ref: '#/components/schemas/RedactionAnnotation.v1'
        - $ref: '#/components/schemas/TextAnnotation.v1'
        - $ref: '#/components/schemas/InkAnnotation.v1'
        - $ref: '#/components/schemas/LinkAnnotation.v1'
        - $ref: '#/components/schemas/NoteAnnotation.v1'
        - $ref: '#/components/schemas/EllipseAnnotation.v1'
        - $ref: '#/components/schemas/RectangleAnnotation.v1'
        - $ref: '#/components/schemas/LineAnnotation.v1'
        - $ref: '#/components/schemas/PolylineAnnotation.v1'
        - $ref: '#/components/schemas/PolygonAnnotation.v1'
        - $ref: '#/components/schemas/ImageAnnotation.v1'
        - $ref: '#/components/schemas/StampAnnotation.v1'
        - $ref: '#/components/schemas/WidgetAnnotation.v1'
    AnnotationRecord:
      title: AnnotationRecord
      type: object
      required:
        - createdBy
        - updatedBy
      properties:
        content:
          oneOf:
            - $ref: '#/components/schemas/AnnotationContent'
            - $ref: '#/components/schemas/Annotation.v1'
        id:
          $ref: '#/components/schemas/AnnotationId'
        createdBy:
          $ref: '#/components/schemas/User'
        updatedBy:
          $ref: '#/components/schemas/User'
        group:
          $ref: '#/components/schemas/Group'
      description: |
        Represents a PDF annotation.
    MigrateDocumentAssetsRequest:
      type: object
      required:
        - storage
      properties:
        storage:
          $ref: '#/components/schemas/StorageConfiguration'
        copy_remote_files_to_new_storage:
          type: boolean
          default: false
          description: |
            If set to `true`, all remote files will be copied to the new storage backend.
            If set to `false`, only assets that are already present in the old storage backend i.e non-remote assets
            will be moved to the new storage.

            Regardless of if remote assets are copied to the storage or not,
            The storage configuration in `storage` will be set as the default storage for any new assets
            associated with the document (or layer) in the future.

            For example, any image annotation attachments uploaded and associated with the document after migrating the document to the new storage
            will be stored in the new storage backend.
    MigrateDocumentAssetsResponse:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - jobId
          properties:
            jobId:
              type: string
              description: |
                The ID of the job that is migrating the document assets.
                Make a request to `/api/async/jobs/{jobId}` using the `jobId` to get the status of the job
    MigrateDocumentAssetsError:
      type: object
      required:
        - errors
      properties:
        errors:
          oneOf:
            - type: object
              additionalProperties: {}
            - type: array
              items:
                oneOf:
                  - type: object
                    additionalProperties: {}
                  - type: string
    OfficeTemplateModel:
      type: object
      properties:
        config:
          type: object
          description: |
            Configuration for the Office template processing.
          properties:
            delimiter:
              type: object
              description: |
                Pair of delimiters that encloses a template marker. The "model" object associates a
                template marker with the corresponding substitution in the final, produced document.
              properties:
                start:
                  type: string
                  default: '{'
                  example: '{{'
                end:
                  type: string
                  default: '}'
                  example: '}}'
        model:
          type: object
          description: |
            The model object that contains the data to be substituted into the template.

            Right now, we support placeholders and loops.
          additionalProperties:
            oneOf:
              - title: Placeholder marker
                description: |
                  An element in Office template's model that is to be substituted with text.
                type: string
              - title: Loop marker
                description: |
                  An element describing a loop that is expanded as a repetitions of a given pattern.
                  The syntax for loops in the template is `#` for the opening tag, and `/` for the closing one.
                  For instance:
                  ```
                  {#ITEMS} {name} {price} {/ITEMS}
                  ```

                  Here, "ITEMS" is the name of the loop template marker, and "name" and "price" are regular placeholder template markers. Given the following model:
                  ```
                  "model": {
                    "items": [
                      {"name": "A", "price": 10},
                      {"name": "B", "price": 15}
                    ]
                  }
                  ```

                  The output in a document will be:
                  ```
                  A 10
                  B 15
                  ```
                type: object
          example:
            placeholder: replacement value
            loop-name:
              - placeholder-within-loop: replacement value
                another-placeholder-within-loop: replacement value 2
              - placeholder-within-loop: another replacement value
                another-placeholder-within-loop: another replacement value 2
    ErrorResponse:
      type: object
      properties:
        details:
          type: string
          example: The request is malformed
        status:
          type: integer
          enum:
            - 400
            - 500
        requestId:
          type: string
          example: xy123zzdafaf
        failingPaths:
          type: array
          description: List of failing paths.
          items:
            type: object
            properties:
              path:
                type: string
                example: $.property[0]
              details:
                type: string
                example: Missing required property
    DocumentOperationPageIndex:
      oneOf:
        - type: integer
          title: Page index
        - type: string
          title: First page
          enum:
            - first
        - type: string
          title: Last page
          enum:
            - last
    PageRotation:
      type: integer
      enum:
        - 0
        - 90
        - 180
        - 270
      description: Clockwise rotation of the page.
      example: 0
    AddPageConfiguration:
      type: object
      required:
        - backgroundColor
        - pageWidth
        - pageHeight
        - rotateBy
      properties:
        backgroundColor:
          type: string
          pattern: ^#[0-9a-fA-F]{6}$
          description: A background color that will fill the page.
          example: '#000000'
        pageWidth:
          type: number
          description: Page width in points.
          example: 595
        pageHeight:
          type: number
          description: Page height in points.
          example: 842
        rotateBy:
          $ref: '#/components/schemas/PageRotation'
        insets:
          type: array
          minItems: 4
          maxItems: 4
          items:
            type: number
          description: Insets of the page in a form [left, top, width, height].
          example:
            - 10
            - 10
            - 10
            - 10
    DocumentOperationPageIndexes:
      oneOf:
        - type: array
          title: Page indexes
          items:
            $ref: '#/components/schemas/DocumentOperationPageIndex'
        - type: string
          title: All pages
          enum:
            - all
    DocumentOperation:
      description: |
        Represents an operation which can be applied to a document.

        All operations have a `type` property. Depending on the type, the action object
        includes additional properties.
      example:
        type: rotatePages
        pageIndexes:
          - 0
        rotateBy: 90
      type: object
      required:
        - type
      oneOf:
        - allOf:
            - type: object
              title: Add page (after)
              required:
                - afterPageIndex
              properties:
                type:
                  type: string
                  enum:
                    - addPage
                afterPageIndex:
                  $ref: '#/components/schemas/DocumentOperationPageIndex'
            - $ref: '#/components/schemas/AddPageConfiguration'
        - allOf:
            - type: object
              title: Add page (before)
              required:
                - beforePageIndex
              properties:
                type:
                  type: string
                  enum:
                    - addPage
                beforePageIndex:
                  $ref: '#/components/schemas/DocumentOperationPageIndex'
            - $ref: '#/components/schemas/AddPageConfiguration'
        - type: object
          title: Duplicate pages
          required:
            - pageIndexes
          properties:
            type:
              type: string
              enum:
                - duplicatePages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
        - type: object
          title: Move pages (after)
          required:
            - pageIndexes
            - afterPageIndex
          properties:
            type:
              type: string
              enum:
                - duplicatePages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            afterPageIndex:
              $ref: '#/components/schemas/DocumentOperationPageIndex'
        - type: object
          title: Move pages (before)
          required:
            - pageIndexes
            - beforePageIndex
          properties:
            type:
              type: string
              enum:
                - duplicatePages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            beforePageIndex:
              $ref: '#/components/schemas/DocumentOperationPageIndex'
        - type: object
          title: Rotate pages
          required:
            - pageIndexes
            - rotateBy
          properties:
            type:
              type: string
              enum:
                - rotatePages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            rotateBy:
              $ref: '#/components/schemas/PageRotation'
        - type: object
          title: Keep pages
          required:
            - pageIndexes
          properties:
            type:
              type: string
              enum:
                - keepPages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
        - type: object
          title: Remove pages
          required:
            - pageIndexes
          properties:
            type:
              type: string
              enum:
                - removePages
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
        - type: object
          title: Set page label
          required:
            - pageIndexes
            - pageLabel
          properties:
            type:
              type: string
              enum:
                - setPageLabel
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            pageLabel:
              type: string
              description: Page label to set.
        - type: object
          title: Apply XFDF
          required:
            - dataFilePath
          properties:
            type:
              type: string
              enum:
                - applyXfdf
            dataFilePath:
              type: string
              description: Name of the part in `multipart/form-data` request with XFDF data.
        - type: object
          title: Apply Instant JSON
          required:
            - dataFilePath
          properties:
            type:
              type: string
              enum:
                - applyInstantJson
            dataFilePath:
              type: string
              description: Name of the part in `multipart/form-data` request with Instant JSON data.
        - type: object
          title: OCR
          required:
            - pageIndexes
          properties:
            type:
              type: string
              enum:
                - performOcr
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            language:
              $ref: '#/components/schemas/OcrLanguage'
              type: string
        - type: object
          title: Flatten Annotations
          properties:
            type:
              type: string
              enum:
                - flattenAnnotations
            pageIndexes:
              $ref: '#/components/schemas/DocumentOperationPageIndexes'
            annotationIds:
              type: array
              description: |
                Annotation IDs to flatten. If not specified, all annotations will be flattened.
              items:
                type: integer
        - type: object
          title: Update metadata
          properties:
            type:
              type: string
              enum:
                - updateMetadata
            metadata:
              type: object
              properties:
                title:
                  type: string
                author:
                  type: string
        - type: object
          title: Apply redactions
          properties:
            type:
              type: string
              enum:
                - applyRedactions
    DocumentOperations:
      type: array
      items:
        $ref: '#/components/schemas/DocumentOperation'
      description: An array of operations which can be applied to the document.
    DownloadPDF:
      title: Download PDF
      type: object
      required:
        - type
      properties:
        type:
          type: string
          example: pdfa
          description: The type of output file. Can be pdfa or pdf.
          enum:
            - pdf
            - pdfa
        source:
          type: boolean
          description: |
            If set to `true`, the originally uploaded version of the PDF file will be fetched.
            The remaining properties are mutually exclusive with this property.
        flatten:
          type: boolean
          description: |
            Determines whether a flattened version of the PDF file will be downloaded. If set to `true`,
            the resulting PDF file will have its annotations burned into the document and will have no annotations.
        render_ap_streams:
          type: boolean
          description: |
            If set to `true`, the resulting PDF file will have its custom AP streams rendered into the document.
        annotations:
          type: boolean
          description: |
            If set to `true`, annotations will be included in the downloaded file
        comments:
          type: boolean
          description: |
            If set to `true`, comments will be included in the downloaded file.
        keep_signatures:
          type: boolean
          default: true
          description: |
            If set to `false`, signatures and form fields will get flattened in the resulting PDF.
            Defaults to `true`.
        conformance:
          type: string
          example: pdfa-1a
          default: pdfa-1b
          enum:
            - pdfa-1a
            - pdfa-1b
            - pdfa-2a
            - pdfa-2u
            - pdfa-2b
            - pdfa-3a
            - pdfa-3u
          description: |
            The level of conformance of the pdfa file. Defaults to `pdfa-1b` if the type is set to `pdfa` and conformance is not explicitly specified.
        optimize:
          $ref: '#/components/schemas/OptimizePdf'
    WidgetAnnotation:
      title: WidgetAnnotation
      allOf:
        - $ref: '#/components/schemas/BaseAnnotation'
        - title: WidgetAnnotation
          description: |
            JSON representation of the form field widget annotation. Widget annotations are a type of annotation with the type always being 'pspdfkit/widget'.
          type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/widget
            formFieldName:
              type: string
              example: First-Name
              description: See name property of the FormField schema for more details
            borderColor:
              type: string
              pattern: ^#[0-9a-fA-F]{6}$
              description: A color of the annotation border.
              example: '#ffffff'
            borderStyle:
              $ref: '#/components/schemas/BorderStyle'
            borderWidth:
              type: integer
              minimum: 0
            font:
              $ref: '#/components/schemas/Font'
            fontSize:
              oneOf:
                - $ref: '#/components/schemas/FontSizeInt'
                - $ref: '#/components/schemas/FontSizeAuto'
            fontColor:
              $ref: '#/components/schemas/FontColor'
            fontStyle:
              $ref: '#/components/schemas/FontStyle'
            horizontalAlign:
              $ref: '#/components/schemas/HorizontalAlign'
            verticalAlign:
              $ref: '#/components/schemas/VerticalAlign'
            rotation:
              $ref: '#/components/schemas/AnnotationRotation'
            backgroundColor:
              $ref: '#/components/schemas/BackgroundColor'
          required:
            - type
    Annotation:
      title: Annotation JSON v2
      type: object
      description: |
        JSON representation of an annotation.
      oneOf:
        - $ref: '#/components/schemas/MarkupAnnotation'
        - $ref: '#/components/schemas/RedactionAnnotation'
        - $ref: '#/components/schemas/TextAnnotation'
        - $ref: '#/components/schemas/InkAnnotation'
        - $ref: '#/components/schemas/LinkAnnotation'
        - $ref: '#/components/schemas/NoteAnnotation'
        - $ref: '#/components/schemas/EllipseAnnotation'
        - $ref: '#/components/schemas/RectangleAnnotation'
        - $ref: '#/components/schemas/LineAnnotation'
        - $ref: '#/components/schemas/PolylineAnnotation'
        - $ref: '#/components/schemas/PolygonAnnotation'
        - $ref: '#/components/schemas/ImageAnnotation'
        - $ref: '#/components/schemas/StampAnnotation'
        - $ref: '#/components/schemas/WidgetAnnotation'
    Attachment:
      title: Attachment
      description: |
        Represents a binary "attachment" associated with an Annotation.

        For example, this might be an image attachment for `ImageAnnotation`.
      type: object
      properties:
        binary:
          type: string
          description: |
            Base64-encoded binary data of the attachment.
        contentType:
          type: string
          description: |
            MIME type of the attachment's content. For example, `image/png`.
    Attachments:
      title: Attachments
      description: |
        Attachments are defined as an associative array.
        * Keys are SHA-256 hashes of the attachment contents or the `pdfObjectId`
        of the attachment (in case it's part of the source PDF).
        * Values are the actual `Attachment` objects with Base-64 encoded binary
        contents of the attachment and its content type.
      type: object
      additionalProperties:
        $ref: '#/components/schemas/Attachment'
      example:
        388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b:
          binary: YXR0YWNobWVudCBjb250ZW50cwo=
          contentType: image/png
        ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b:
          binary: YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==
          contentType: plain/text
    BaseFormField:
      title: BaseFormField
      type: object
      properties:
        v:
          type: integer
          enum:
            - 1
          description: The specification version that the record is compliant to.
        type:
          type: string
          description: The type of the form field.
        id:
          type: string
          description: The unique Instant JSON identifier of the form field.
          example: 7KPSXX1NMNJ2WFDKN7BKQK9KZ
        name:
          type: string
          description: |
            A unique identifier for the form field. This is not visible in the PDF.
          example: Form-Field
        label:
          type: string
          description: |
            The visible name of the form field. It is used to identify the field in the UI for accessibility.
          example: Form Field
        annotationIds:
          type: array
          description: |
            The list of Instant JSON identifiers of widget annotations that are associated with this form field.

            The widget annotation is used to define the visual appearance of the form field and
            to manage user interaction with the form field. Each interactive form control is
            associated with separate widget annotation.
          items:
            type: string
          example:
            - 01DNEDPQQ22W49KDXRFPG4EPEQ
            - 7KPS6T4DKYN71VB7G5KBGB5R51
        pdfObjectId:
          type: integer
          description: The PDF object ID of the form field from the source PDF.
        flags:
          type: array
          description: |
            Array of form field flags.

            | Flag | Description |
            | ---- | ----------- |
            | readOnly | Field can't be filled. |
            | required | Field needs to have a value when exported by a submit-form action |
            | _noExport_ | _(Not supported) Field shall not be exported by a submit-form action. PSPDFKit will read this flag from the PDF and write back changes to its state, but otherwise this flag has no effect._ |
          items:
            type: string
            enum:
              - readOnly
              - required
              - noExport
          example:
            - required
      required:
        - annotationIds
        - label
        - name
        - type
        - v
    ButtonFormField:
      title: ButtonFormField
      description: |
        A simple push button that responds immediately to user input without retaining any state.
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - type: object
          title: ButtonFormField
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/button
            buttonLabel:
              type: string
              description: Specifies the 'normal' caption of the button
          required:
            - type
            - buttonLabel
    FormFieldOption:
      type: object
      description: |
        A form option identifies a possible option for the form field.
      required:
        - label
        - value
      properties:
        label:
          type: string
          description: The label of the option.
          example: One
        value:
          type: string
          description: The export value of the option.
          example: Two
    FormFieldOptions:
      type: array
      description: |
        The list of form field options.

        The index of the widget annotation ID in the `annotationIds`
        property corresponds to an index in the  form field option array.
      items:
        $ref: '#/components/schemas/FormFieldOption'
      example:
        - label: MALE
          value: MALE
        - label: FEMALE
          value: FEMALE
    FormFieldDefaultValues:
      type: array
      description: |
        Default values corresponding to each option.
      items:
        type: string
    FormFieldAdditionalActionsEvent:
      type: object
      description: |
        Additional actions that can be performed on the form field.
      properties:
        onChange:
          allOf:
            - type: object
              description: |
                Action to be performed when the field's value is changed.
            - $ref: '#/components/schemas/Action'
        onCalculate:
          allOf:
            - type: object
              description: |
                Action to be performed to recalculate the value of a field.
            - $ref: '#/components/schemas/Action'
    ChoiceFormField:
      type: object
      properties:
        options:
          $ref: '#/components/schemas/FormFieldOptions'
        multiSelect:
          type: boolean
          description: |
            If true, more than one of the field's option items may be selected
            simultaneously.
          default: false
        commitOnChange:
          type: boolean
          description: |
            If true, the new value is committed as soon as a selection is made, without
            requiring the user to blur the field.
          default: false
        defaultValues:
          $ref: '#/components/schemas/FormFieldDefaultValues'
        additionalActions:
          $ref: '#/components/schemas/FormFieldAdditionalActionsEvent'
      required:
        - options
    FormFieldAdditionalActionsInput:
      type: object
      description: |
        Additional actions that can be performed on the form field.
      properties:
        onInput:
          allOf:
            - type: object
              description: |
                Action to be performed when the user types a key-stroke into a text
                field or combo box or modifies the selection in a scrollable list box.
            - $ref: '#/components/schemas/Action'
        onFormat:
          allOf:
            - type: object
              description: |
                Action to be performed before the field is formatted to display its current value.
            - $ref: '#/components/schemas/Action'
    ListBoxFormField:
      title: ListBoxFormField
      description: |
        A list box where multiple values can be selected.
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - $ref: '#/components/schemas/ChoiceFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/listbox
            additionalActions:
              allOf:
                - $ref: '#/components/schemas/FormFieldAdditionalActionsEvent'
                - $ref: '#/components/schemas/FormFieldAdditionalActionsInput'
    ComboBoxFormField:
      title: ComboBoxFormField
      description: |
        A combo box is a drop-down box with the option add custom entries (see `edit`).
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - $ref: '#/components/schemas/ChoiceFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/combobox
            edit:
              type: boolean
              description: |
                If true, the combo box includes an editable text box as well as a dropdown list. If false, it includes only a drop-down list.
              default: false
            doNotSpellCheck:
              type: boolean
              description: |
                If true, the text entered in the field is not spell-checked.
              default: false
          required:
            - edit
            - doNotSpellCheck
    CheckboxFormField:
      title: CheckBoxFormField
      description: |
        A check box that can either be checked or unchecked. One check box form field can also be associated to multiple single check box widgets
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/checkbox
            options:
              $ref: '#/components/schemas/FormFieldOptions'
            defaultValues:
              $ref: '#/components/schemas/FormFieldDefaultValues'
            additionalActions:
              $ref: '#/components/schemas/FormFieldAdditionalActionsEvent'
          required:
            - type
            - options
            - defaultValues
    FormFieldDefaultValue:
      type: string
      description: |
        Default value of the form field.
    RadioButtonFormField:
      title: RadioButtonFormField
      description: |
        A group of radio buttons. Similar to `CheckBoxFormField`, but there can only be one value set at the same time.
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/radio
            options:
              $ref: '#/components/schemas/FormFieldOptions'
            defaultValue:
              $ref: '#/components/schemas/FormFieldDefaultValue'
            noToggleToOff:
              type: boolean
              description: |
                If true, exactly one radio button must be selected at all times.
                Clicking the currently selected button has no effect. Otherwise,
                clicking the selected button deselects it, leaving no button selected.
              default: false
            radiosInUnison:
              type: boolean
              description: |
                If true, a group of radio buttons within a radio button field that use
                the same value for the on state will turn on and off in unions: If one is
                checked, they are all checked (the same behavior as HTML radio buttons).
                Otherwise, only the checked radio button will be marked checked.
              default: false
          required:
            - type
            - options
            - defaultValues
    TextFormField:
      title: TextFormField
      description: |
        A text input element, that can either span a single or multiple lines.
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/text
            password:
              type: boolean
              description: |
                If true, the field is intended for entering a secure password that should not be echoed visibly
                 to the screen. Characters typed from the keyboard should instead be echoed in some unreadable
                 form, such as asterisks or bullet characters.
              default: false
            maxLength:
              type: integer
              minimum: 0
              description: |
                The maximum length of the field's text, in characters. If none is set, the size is not limited.
            doNotSpellCheck:
              type: boolean
              description: |
                If true, the text entered in the field is not spell-checked.
              default: false
            doNotScroll:
              type: boolean
              description: |
                If true, the field does not scroll (horizontally for single-line fields, vertically for multiple-line fields)
                to accommodate more text than fits within its widget annotation's rectangle. Once the field is full, no further
                text is accepted.
              default: false
            multiLine:
              type: boolean
              description: |
                If true, the field can contain multiple lines of text. Otherwise, the field's text is restricted to a single line.
              default: false
            comb:
              type: boolean
              description: |
                If true, every character will have an input element on their own which is evenly distributed inside
                the bounding box of the widget annotation. When this is set, the form field must have a `maxLength``.
              default: false
            defaultValue:
              $ref: '#/components/schemas/FormFieldDefaultValue'
            richText:
              type: boolean
              default: false
              description: |
                _(Not Supported) Rich text rendering is not supported right now. Any rich text value will be displayed as plain text in case the regular text value is missing._
            richTextValue:
              type: string
              description: |
                _(Not Supported) Rich text rendering is not supported right now. Any rich text value will be displayed as plain text in case the regular text value is missing._
            additionalActions:
              allOf:
                - $ref: '#/components/schemas/FormFieldAdditionalActionsEvent'
                - $ref: '#/components/schemas/FormFieldAdditionalActionsInput'
          required:
            - type
            - doNotSpellCheck
            - doNotScroll
            - multiLine
            - comb
            - defaultValue
    SignatureFormField:
      title: SignatureFormField
      description: |
        A field that contains a digital signature.
      allOf:
        - $ref: '#/components/schemas/BaseFormField'
        - type: object
          properties:
            type:
              type: string
              enum:
                - pspdfkit/form-field/signature
    FormField:
      title: Form field JSON
      type: object
      description: |
        JSON representation of a form field
      oneOf:
        - $ref: '#/components/schemas/ButtonFormField'
        - $ref: '#/components/schemas/ListBoxFormField'
        - $ref: '#/components/schemas/ComboBoxFormField'
        - $ref: '#/components/schemas/CheckboxFormField'
        - $ref: '#/components/schemas/RadioButtonFormField'
        - $ref: '#/components/schemas/TextFormField'
        - $ref: '#/components/schemas/SignatureFormField'
    FormFieldValue:
      title: FormFieldValue
      description: |
        A record representing a form field value.

        ## Choice Fields

        When creating form fields with multiple widgets like `CheckBoxFormField` or `RadioButtonFormField`, you need to ensure two things:
        - The number of annotations in the `annotationIds` field must be equal to the number of elements in the `options` field.
        - For each option in `options` you need to specify the `annotationId` that is mapped to this specific option on the PDF.

        The list of `options` in a `CheckBoxFormField` or `RadioButtonFormField` are the names of the `ON` state appearance
        of each widget annotation that is a child of the form field. The `options` array and the `annotationWidgetIds`
        array keep the same order, that is, the `ON` state appearance name for `annotationIds[0]` is in `options[0]`.
        The value of the `OFF` state is customizable but always has the same name, "Off", so it's not included in the model.

        In order to check a checkbox or radio button, if the `options` list contains, for example, `["Checked"]`,
        then you need to and pass the same list. The system will internally notice that you are setting the form
        value of a checkbox or radio button and automatically interpret "Checked" not as text, but as the PDF name
        that represents an appearance stream named "Checked", representing the ON state.

        The same applies to the OFF state, which by design always has the name "Off", as explained previously.
      type: object
      required:
        - type
        - name
        - v
      properties:
        name:
          type: string
          description: |
            Unique name of the form field. This property is used to link form field value to a `FormField`.
        value:
          anyOf:
            - title: Single value
              type:
                - string
                - 'null'
              description: |
                Value of the form field.
            - title: Multiple values
              type: array
              items:
                type: string
                description: |
                  Values associated with the form field. Multiple values are allowed for
                  `ComboBoxFormField`, `ListBoxFormField` and `CheckBoxFormField`.
        type:
          type: string
          enum:
            - pspdfkit/form-field-value
        v:
          type: integer
          enum:
            - 1
          description: The specification version that the record is compliant to.
        optionIndexes:
          type: array
          description: |
            Radio buttons and checkboxes can have multiple widgets with the same form value associated,
            but can be selected independently. `optionIndexes`` contains the value indexes that should be actually set.

            If set, the value field doesn't get used, and the widget found at the corresponding indexes in
            the form field's annotationIds property are checked.

            If set on fields other than `RadioButtonFormField` or `CheckBoxFormField`, setting the form value will fail.
          items:
            type: integer
        isFitting:
          type: boolean
          default: false
          description: |
            Specifies if the given text should fit into the visible portion of the text form field.
    Bookmark:
      title: Bookmark
      description: |
        A record representing a bookmark.
      type: object
      required:
        - type
        - v
        - action
      properties:
        name:
          type: string
          description: |
            The optional bookmark name. This is used to identify the bookmark.
        type:
          type: string
          enum:
            - pspdfkit/bookmark
        v:
          type: integer
          enum:
            - 1
          description: The specification version that the record is compliant to.
        action:
          $ref: '#/components/schemas/Action'
        pdfBookmarkId:
          type: string
          description: |
            The PDF object ID of the bookmark in the PDF.
    CreateDigitalSignature:
      title: CreateDigitalSignature
      type: object
      required:
        - signatureType
      properties:
        signatureType:
          type: string
          description: |
            The signature type to create.
            Note: While this field is required if sending signature parameters,
            the entire `data` object itself is optional in the multipart request.
          enum:
            - cms
            - cades
          default: cms
        flatten:
          type: boolean
          description: |
            Controls whether to flatten the document before signing it.
            This is useful when you want the document's appearance to remain stable before signing and to ensure there's no indication that the document can be edited after signing.

            Note that the resulting document's records (annotations and form fields) will be deleted.
          default: false
        formFieldName:
          type: string
          description: |
            Name of the signature form field to sign. Use this when signing an existing signature form field.
            If a signature field with this name does not exist in the document, it will be created at the position specified with `position`.

            If a signature field with the specified name exists and `position` is also set, the request will result in an error.

            Note: Either `formFieldName` or `position` must be provided if creating a visible signature.
          example: signatureI-field
        appearance:
          description: |
            The appearance settings for the visible signature. Omit if you want an invisible signature to be created.
          type: object
          properties:
            mode:
              type: string
              description: |
                Specifies what will be rendered in the signature appearance: graphics, description, or both.           
                Visit the [Configure Digital Signature Appearance guide](https://www.nutrient.io/guides/web/signatures/digital-signatures/signature-lifecycle/configure-digital-signature-appearance/) for a detailed description of the signature modes.
              default: signatureAndDescription
              example: signatureOnly
              enum:
                - signatureOnly
                - signatureAndDescription
                - descriptionOnly
            contentType:
              type: string
              description: |
                The content type of the watermark image when provided in the `image` parameter of the multipart request.
                Supported types are `application/pdf`, `image/png`, and `image/jpeg`.
              example: image/png
            showSigner:
              type: boolean
              description: |
                Controls whether the signer name from `signatureMetadata` is shown in the signature appearance.
                When `false`, the name will not be shown in the signature appearance.
              default: true
            showReason:
              type: boolean
              description: |
                Controls whether the signing reason from `signatureMetadata` is shown in the signature appearance.
                When `false`, the reason will not be shown in the signature appearance.
              default: false
            showLocation:
              type: boolean
              description: |
                Controls whether the signing location from `signatureMetadata` is shown in the signature appearance.
                When `false`, the location will not be shown in the signature appearance.
              default: false
            showWatermark:
              type: boolean
              description: |
                Controls whether to include the watermark in the signature appearance.
                When `true` and a watermark image is provided via the `watermark` parameter, it will be included.
                When `true` and no watermark image is provided, the Nutrient logo will be used as the default watermark.
              default: true
            showSignDate:
              type: boolean
              description: |
                Controls whether to show the signing date and time in the signature appearance.
                When `true`, the date and time will be shown in ISO 8601 format.
                Example: 2023-06-15 13:57:31
              default: true
            showDateTimezone:
              type: boolean
              description: |
                Controls whether to include the timezone in the signing date.
                Only applies when `showSignDate` is `true`.
              default: false
        position:
          type: object
          description: |
            Position of the visible signature form field. Omit if you want an invisible signature or if you specified the `formFieldName` option.
          required:
            - pageIndex
            - rect
          properties:
            pageIndex:
              type: integer
              minimum: 0
              description: |
                The index of the page where the signature appearance will be rendered.
            rect:
              type: array
              description: |
                An array of 4 numbers (points) representing the bounding box where the signature appearance will be rendered on the specified `pageIndex`.

                [left, top, width, height]

                The unit is PDF points (1 PDF point equals 1⁄72 of an inch).
                The first two numbers describe the [left,top] coordinates of the top left corner of the bounding box,
                while the second two numbers describe the width and height of the bounding box.
              minItems: 4
              maxItems: 4
              items:
                type: number
              example:
                - 0
                - 0
                - 100
                - 100
        signatureMetadata:
          type: object
          description: |
            Optional metadata that describes the digital signature and becomes part of the signature itself.
            This information will be shown by PDF readers to end users and can be included in the visual appearance of the signature
            if you opted for a visible signature and enabled the necessary options in `appearance`.
          properties:
            signerName:
              type: string
              description: |
                The name of the person or organization signing the document.
              example: John Appleseed
            signatureReason:
              type: string
              description: |
                The reason for signing the document.
              example: Document Accepted
            signatureLocation:
              type: string
              description: |
                The geographical or digital location where the document is being signed.
              example: Vienna, Austria
        cadesLevel:
          type: string
          enum:
            - b-lt
            - b-t
            - b-b
          default: b-lt
          description: |
            The CAdES level to use when creating the signature. The default value is `CAdES B-LT`.
            This parameter is ignored when the `signatureType` is `cms`.

            If this API is invoked with the [Document Engine](https://www.nutrient.io/sdk/document-engine), you can override the default with the following environment variable: [`DIGITAL_SIGNATURE_CADES_LEVEL`](https://www.nutrient.io/guides/document-engine/configuration/options/).

            For Long-Term Validation (LTV) of the signature - when this API is invoked with the [Document Engine](https://www.nutrient.io/sdk/document-engine) - you need to ensure that the signing certificate chain links to a trusted anchor Certificate Authority (CA) at the time of signing.
            To add the root CA and necessary intermediate CAs to your Document Engine instance, follow the instructions in [our guide on Providing Trusted Root Certificates](https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/validation/#providing-trusted-root-certificates).
      example:
        signatureType: cades
        flatten: false
        appearance:
          mode: signatureOnly
          contentType: image/png
          showSigner: true
          showReason: true
          showLocation: true
          showWatermark: true
          showSignDate: true
        position:
          pageIndex: 0
          rect:
            - 0
            - 0
            - 100
            - 100
        signatureMetadata:
          signerName: John Appleseed
          signatureReason: accepted
          signatureLocation: Vienna
        cadesLevel: b-lt
    CreateDigitalSignatureCustom:
      title: CreateDigitalSignature
      type: object
      properties:
        signatureContainer:
          type: string
          description: |
            Controls the signature container that will be requested from the signing service:
              * `pkcs7` - signing service is expected to return PKCS#7 container with signed data.
              * `raw` - signing service is expected to return RSA signed data directly. Expects PKCS#1 v1.5 signed data.

            The default value is `pkcs7`.
          enum:
            - pkcs7
            - raw
          example: pkcs7
        hashAlgorithm:
          type: string
          description: |
            The hash algorithm to use when computing the digest of the document.

            The default value is `sha256`.
            It is recommended to use `sha256` or better.
          enum:
            - md5
            - sha160
            - sha224
            - sha256
            - sha384
            - sha512
          example: sha256
        certificates:
          type: array
          description: |
            A set of base64-encoded X.509 certificates that will be used to sign the document.

            Required for `raw` signature container or `cades` signature type. If not provided, will be requested from the signing service.
          items:
            type: string
        signingToken:
          type: string
          description: |
            A string token that will be forwarded to the underlying signing service.
          example: user-1-with-rights
        estimatedSize:
          type: integer
          minimum: 0
          description: |
            Estimated size of the signature (in bytes). The estimated size is the size for the signature
            that will be reserved in the PDF document before digitally signing it.

            A big estimated size will possibly make the signed
            document bigger than necessary, but a too small one will cause the
            signing process to fail. The value will be clamped to the nearest even value
            between 0 and 256 KB (262144 bytes).

            By default, Document Engine will set a size of 32 KB (32768 bytes), which should be enough to support even complex certificates.

            > ℹ️ Note: The `estimatedSize` corresponds to the `/Contents` field of the signature field
            — that is, the signature container. The size of the signature container mostly depends on the
            complexity of the certificates used for digital signatures.
          example: 65536
      example:
        signatureContainer: raw
        signatureType: cades
        signingToken: user-1-with-rights
        flatten: false
        appearance:
          mode: signatureOnly
          contentType: image/png
          showSigner: true
          showReason: true
          showLocation: true
          showWatermark: true
          showSignDate: true
        position:
          pageIndex: 0
          rect:
            - 0
            - 0
            - 100
            - 100
        signatureMetadata:
          signerName: John Appleseed
          signatureReason: accepted
          signatureLocation: Vienna
        cadesLevel: b-lt
    SignatureType:
      type: string
      description: |
        The signature type that is being created.
      enum:
        - cades
        - cms
    SigningToken:
      type: string
      description: |
        Sign requests accept an optional `signingToken` string parameter, which is forwarded to the signing service in
        the exact same shape. You can use it to pass a token that can be used to verify the authenticity of the signing
        request or to provide identity information about the user applying the signature.
      example: custom_signing_token
    RefreshDigitalSignatures:
      title: RefreshDigitalSignatures
      type: object
      properties:
        signatureFQNs:
          type: array
          description: |
            An optional list of signature IDs to refresh.

            If this list is empty then all the signatures in the document will be refreshed.
          items:
            type: string
            example: Signature-9c58d27b-7ea1-4d7b-8e22-9ef3bcc46c85
    InstantComment.v1:
      title: InstantComment
      type: object
      required:
        - text
        - pageIndex
      properties:
        createdAt:
          $ref: '#/components/schemas/IsoDateTime'
        creatorName:
          type: string
          description: |
            The name of the user who created the comment.
          example: John Doe
        customData:
          $ref: '#/components/schemas/CustomData'
        pageIndex:
          $ref: '#/components/schemas/_schemas_PageIndex'
        pdfObjectId:
          $ref: '#/components/schemas/PdfObjectId'
        rootId:
          type: string
          description: |
            The ID of the root annotation of the comment thread.
          example: 01HBDGR9D5JTFERPSCEMNH5GPG
        text:
          type: string
          description: The text of the comment
          example: A comment is made of words
        type:
          type: string
          enum:
            - pspdfkit/comment
        updatedAt:
          $ref: '#/components/schemas/IsoDateTime'
        v:
          type: integer
          enum:
            - 1
          description: |
            The instant JSON specification version that the record is compliant to.
    InstantComment.v2:
      title: InstantComment
      type: object
      required:
        - text
        - pageIndex
      properties:
        createdAt:
          $ref: '#/components/schemas/IsoDateTime'
        creatorName:
          type: string
          description: |
            The name of the user who created the comment.
          example: John Doe
        customData:
          $ref: '#/components/schemas/CustomData'
        pageIndex:
          $ref: '#/components/schemas/_schemas_PageIndex'
        pdfObjectId:
          $ref: '#/components/schemas/PdfObjectId'
        rootId:
          type: string
          description: |
            The ID of the root annotation of the comment thread.
          example: 01HBDGR9D5JTFERPSCEMNH5GPG
        text:
          $ref: '#/components/schemas/AnnotationText'
        type:
          type: string
          enum:
            - pspdfkit/comment
        updatedAt:
          $ref: '#/components/schemas/IsoDateTime'
        v:
          type: integer
          enum:
            - 2
          description: |
            The instant JSON specification version that the record is compliant to.
    CreateRedactions:
      title: CreateRedactions
      type: object
      oneOf:
        - type: object
          title: Preset
          required:
            - strategy
            - strategyOptions
          properties:
            strategy:
              type: string
              enum:
                - preset
            strategyOptions:
              $ref: '#/components/schemas/CreateRedactionsStrategyOptionsPreset'
            user_id:
              $ref: '#/components/schemas/User'
            content:
              $ref: '#/components/schemas/RedactionAnnotation'
        - type: object
          title: Regex
          required:
            - strategy
            - strategyOptions
          properties:
            strategy:
              type: string
              enum:
                - regex
            strategyOptions:
              $ref: '#/components/schemas/CreateRedactionsStrategyOptionsRegex'
            user_id:
              $ref: '#/components/schemas/User'
            content:
              $ref: '#/components/schemas/RedactionAnnotation'
        - type: object
          title: Text
          required:
            - strategy
            - strategyOptions
          properties:
            strategy:
              type: string
              enum:
                - text
            strategyOptions:
              $ref: '#/components/schemas/CreateRedactionsStrategyOptionsText'
            user_id:
              $ref: '#/components/schemas/User'
            content:
              $ref: '#/components/schemas/RedactionAnnotation'
    CreateRedactionsErrors:
      title: CreateRedactionsErrors
      type: object
      required:
        - error
      properties:
        error:
          type: object
          example:
            strategy:
              - is invalid
          description: |
            An object with errors encountered when creating redaction annotations.
    BatchOperationResult:
      title: BatchOperationResult
      type: object
      description: |
        This is the response of a batch operation.

        An example of a batch operation is a POST request to `{base_url}/form-fields`. For any request to a batch endpoint, one of three things can happen:
        - The request succeeds
        - The request fails completely
        - The request fails partially
        For example, if you attempt to create 3 form fields in one request and the creation of 1 of those fields is unsuccessful,
        the `failingPaths` attribute in this response will contain details of the failure, while the `data` attribute will contain the IDs
        for the 2 form fields that were created successfully

        The `path` in `failingPaths[index].path` corresponds to the request JSON you sent to Document Engine.

        For example, when you send a DELETE request to `/api/documents/:documentId/form-field-widgets` with body
        `{ formFieldWidgetIds: ["widgetId1", "widgetId2", "widgetId3"]}`,
        If Document Engine ran into a problem deleting "widgetId2", say, the record didn't exist, the path in `failingPaths` would be `$.formFieldWidgetIds[1]`
        where `[1]` is the index of the failing item in the request's `formFieldWidgetIds` array.

        The status field of this response will be the same as the HTTP status code is returned along with the response.

        These are the HTTP status codes you can expect to receive along with this response from Document Engine for different scenarios of your request:
        - `success`: Document Engine successfully created/updated/deleted all of the items in the batch (Status code: 200)
        - `partial_failure:` Document Engine successfully created/updated/deleted some, not all of the items in the batch (Status code: 200)
        - `failure`: Document Engine was able to parse the request, but could not successfully create/update/delete any of the items in the batch (Status code: 200)
        - `failure`: The request is badly formed, e.g. Document Engine was unable to parse the JSON (Status code: 400)
        - `failure`: Document Engine doesn't know what went wrong (Status code: 500)
      properties:
        details:
          type: string
          description: A text summary of the status of the request
          example: Operation was partially successful
        request_id:
          type: string
        result:
          type: string
          enum:
            - partial_failure
            - success
            - failure
          description: |
            If all the items in the batch request were successful, then the status will be a success.
            A partial_failure will occur if only a few of the items in the batch request succeeded.
            Failure is when none of the items in the batch succeed.
        status:
          type: integer
          enum:
            - 200
            - 400
            - 500
          description: |
            HTTP status code for the request. The status code is 200 if the request was processed.
            This does not have anything to do with the result - the status code will be 200 even if part of the
            request failed. In the case of total failures such as malformed JSON, or document not found,
            this status will be other than 200.
        failingPaths:
          type: array
          description: List of failing paths.
          items:
            type: object
            properties:
              path:
                type: string
                example: $.property[0]
                description: The index for array items will point to the item in the array Document Engine received in your request as opposed to the data array we are sending in this response.
              details:
                type: string
                example: Missing required property
    OCGLayerObject:
      title: OCGLayerObject
      type: object
      description: Layer object
      required:
        - ocgId
        - name
      properties:
        ocgId:
          type: integer
        name:
          type: string
          description: Name of the layer that can be displayed in the UI.
        radioGroup:
          type: integer
    OCGCollectionObject:
      title: OCGCollectionObject
      type: object
      description: Collection object
      required:
        - layers
      properties:
        ocgId:
          type: integer
          description: The ID of the collection, if available. If not, the collection can't be toggled on/off.
        name:
          type: string
          description: Name of the collection, may be null
        layers:
          type: array
          items:
            $ref: '#/components/schemas/OCGLayerObject'
    OCGLayerResponse:
      title: OCGLayerResponse
      type: object
      description: Response for OCG Layer
      required:
        - ocgs
      properties:
        ocgs:
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/OCGLayerObject'
              - $ref: '#/components/schemas/OCGCollectionObject'
          description: Array may contain either Layer or Collection
      example:
        ocgs:
          - name: Option 1
            ocgId: 118
            radioGroup: 0
          - name: Option 2
            ocgId: 108
            radioGroup: 0
          - layers:
              - name: Nested Layer 1
                ocgId: 86
              - name: Nested Layer 2
                ocgId: 72
            name: Nested Layers
            ocgId: 121
          - layers:
              - name: Layer 1
                ocgId: 86
              - name: Layer 2
                ocgId: 72
            name: Grouped layers
  responses:
    BuildResponseOk:
      description: |
        The processing result. One of the following:
        * PDF file for `pdf` and `pdfa` output types.
        * Image file for `image` output types.
        * JSON with document contents for `json-content` output type.
        * Office file for `docx`, `xlsx`, and `pptx` output types.
      content:
        application/pdf:
          schema:
            type: string
            description: The processed PDF file. Returned in case of `pdf` and `pdfa` output types.
            format: binary
            example: <PDF file>
        application/json:
          schema:
            $ref: '#/components/schemas/JSONContentOutput'
        application/jpeg:
          schema:
            type: string
            description: The rendered image file. Returned for `image` output type, `format` specified as `jpeg` and only a single page rendered.
            format: binary
            example: <JPEG data>
        application/png:
          schema:
            type: string
            description: The rendered image file. Returned for `image` output type, `format` specified as `png` and only a single page rendered.
            format: binary
            example: <PNG data>
        application/webp:
          schema:
            type: string
            description: The rendered image file. Returned for `image` output type, `format` specified as `webp` and only a single page rendered.
            format: binary
            example: <WebP data>
        application/zip:
          schema:
            type: string
            description: An archive with rendered pages. Returned for `image` output type, and multiple pages rendered.
            format: binary
            example: <ZIP data>
        application/vnd.openxmlformats-officedocument.wordprocessingml.document:
          schema:
            type: string
            description: Converted Office file. Returned for `docx` output type.
            format: binary
            example: <DOCX data>
        application/vnd.openxmlformats-officedocument.spreadsheetml.sheet:
          schema:
            type: string
            description: Converted Office file. Returned for `xlsx` output type.
            format: binary
            example: <XLSX data>
        application/vnd.openxmlformats-officedocument.presentationml.presentation:
          schema:
            type: string
            description: Converted Office file. Returned for `pptx` output type.
            format: binary
            example: <PPTX data>
    OfficeTemplateResponseOk:
      description: |
        The processed document with template populated.
      content:
        application/vnd.openxmlformats-officedocument.wordprocessingml.document:
          schema:
            type: string
            description: The processed document in DOCX format.
            format: binary
            example: <DOCX file>
  callbacks:
    signing-service:
      signing-service action=sign_pkcs7:
        post:
          operationId: signing-service-sign-pkcs7
          summary: PKCS#7 Signing
          description: |-
            When performing signing operation with `signatureContainer` set to `pkcs7` (default), signing service receives the byte range
            and a hash representation of the current state of the document. Signing service is responsible to digitally sign this payload
            by returning DER encoded [PKCS#7](https://www.ietf.org/rfc/rfc2315.html) signature container.
          requestBody:
            required: true
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    action:
                      type: string
                      enum:
                        - sign_pkcs7
                    signature_type:
                      $ref: '#/components/schemas/SignatureType'
                    digest:
                      type: string
                      description: |
                        Hex (base16) encoded hash of the document that needs to be signed.
                      example: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
                    hash_algorithm:
                      type: string
                      description: |
                        The hash algorithm that was used to create the document digest.
                      enum:
                        - md5
                        - sha160
                        - sha224
                        - sha256
                        - sha384
                        - sha512
                      example: sha256
                    encoded_contents:
                      type: string
                      description: |
                        Base64 encoded contents of the document that need to be signed. The `digest` was created by hashing the raw binary contents with `hash_algorithm`.
                      example: YmFzZSA2NCBlbmNvZGVkIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudAo
                    signing_token:
                      $ref: '#/components/schemas/SigningToken'
          responses:
            '200':
              description: |
                DER encoded [PKCS#7](https://www.ietf.org/rfc/rfc2315.html) signature container.
              content:
                application/octet-stream: {}
            default:
              description: |
                Signing service failed to sign the document. The response status and body will be printed to Document Engine log and signing process will fail.
      signing-service action=sign:
        post:
          operationId: signing-service-sign-raw
          summary: Raw Signing
          description: |-
            When performing signing operation with `signatureContainer` set to `raw`, signing service receives a binary representation of the
            current state of the document. Signing service is responsible to digitally sign this payload by returning DER encoded
            [RSASSA-PKCS1-v1_5](https://datatracker.ietf.org/doc/html/rfc3447#section-8.2) payload.
          requestBody:
            required: true
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    action:
                      type: string
                      enum:
                        - sign
                    signature_type:
                      $ref: '#/components/schemas/SignatureType'
                    hash_algorithm:
                      type: string
                      description: |
                        The hash algorithm that should be used to create digest of the `data_to_be_signed`.
                      enum:
                        - md5
                        - sha160
                        - sha224
                        - sha256
                        - sha384
                        - sha512
                      example: sha256
                    data_to_be_signed:
                      type: string
                      description: |
                        Base64 encoded data that needs to be signed.
                      example: MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZg==
                    signing_token:
                      $ref: '#/components/schemas/SigningToken'
          responses:
            '200':
              description: |
                DER encoded [RSASSA-PKCS1-v1_5](https://datatracker.ietf.org/doc/html/rfc3447#section-8.2) payload.
              content:
                application/octet-stream: {}
            default:
              description: |
                Signing service failed to sign the document. The response status and body will be printed to Document Engine log and signing process will fail.
      signing-service action=get_certificates:
        post:
          operationId: signing-service-get-certificates
          summary: Get Certificates
          description: |-
            When performing signing operation with `signature_type` `cades`, caller needs to provide a list of certificates used for signing
            either via signing request directly or via a signing service. If the certificates are not provided in the signing request, this
            callback will be invoked.

            Signing service needs to respond with a JSON with base64 encoded PEM certificates
          requestBody:
            required: true
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    action:
                      type: string
                      enum:
                        - get_certificates
                    signing_token:
                      $ref: '#/components/schemas/SigningToken'
          responses:
            '200':
              description: |
                List of certificates used for signing.
              content:
                application/json:
                  schema:
                    type: object
                    properties:
                      ca_certificates:
                        type: array
                        description: |
                          List of intermediate and CA certificates for the signer. Certificates need to be in PEM format encoded as Base64.
                        items:
                          type: string
                          example: YmFzZSA2NCBlbmNvZGVkIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudAo
                      certificates:
                        type: array
                        description: |
                          List of signer certificates. Certificates need to be in PEM format encoded as Base64.
                        items:
                          type: string
                          example: YmFzZSA2NCBlbmNvZGVkIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudAo
            default:
              description: |
                Signing service failed to retrieve certificates. The response status and body will be printed to Document Engine log and signing process will fail.
  requestBodies:
    ValidatePDFARequest:
      description: A request to validate PDF/A conformance of a document
      content:
        multipart/form-data:
          schema:
            type: object
            properties:
              file:
                type: string
                format: binary
                description: PDF/A file on which to perform validation.
          encoding:
            file:
              contentType: application/pdf
        multipart/form-data (for URL):
          schema:
            type: object
            properties:
              url:
                type: string
                example: http://www.example.com/example.pdf
                description: |
                  URL of the PDF/A file on which to perform validation.

                  Warning: This request will not execute as-is since the content type of
                  this request is `multipart/form-data (for URL)`. To run this example request
                  please copy the curl command and set the content type to `multipart/form-data`
                  and then run the curl command in the terminal.
          encoding:
            url:
              contentType: text/plain
        multipart/form-data (for document-id):
          schema:
            type: object
            properties:
              document:
                type: string
                example: 7KPV43VQYQK2W0VKGT4EP4HMQK
                description: |
                  Document id of the PDF/A file uploaded on Document Engine on which to perform validation.
          encoding:
            document:
              contentType: text/plain
x-tagGroups:
  - name: Documents
    tags:
      - Documents
      - Document Editing
      - Import and Export
      - Layers
  - name: Records
    tags:
      - Annotations
      - Form Filling
      - Forms
      - Comments
      - Bookmarks
      - Attachments
      - Embedded files
  - name: Features
    tags:
      - Digital Signatures
      - Redaction
      - PDF/A Validation
  - name: Management
    tags:
      - Secrets
      - Maintenance
      - Fonts
  - name: Reference
    tags:
      - File Type Support
      - Instant JSON
      - Build API
      - Configuration
      - JWT authorization
